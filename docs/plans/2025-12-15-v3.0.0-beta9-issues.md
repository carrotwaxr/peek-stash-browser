# Issues Found in v3.0.0-beta.9

**Date:** December 15, 2025
**To be addressed in separate branches before or after 3.0.0 release**

---

## Issue 1: Detail Page Tabs Not Loading (Non-Scenes Tabs)

**Severity:** HIGH - User-facing navigation broken

**Symptoms:**
- On Performer Detail, Studio Detail, Tag Detail, and Collection/Group Detail pages
- Clicking non-Scenes tabs (Galleries, Images, Groups) causes a flicker
- URL briefly shows `?tab=galleries` but immediately switches back to default (Scenes)
- Manually typing URL with `?tab=galleries` also reverts

**Root Cause Analysis:**

Looking at [PerformerDetail.jsx](client/src/components/pages/PerformerDetail.jsx):
- Lines 104-105: `activeTab` is read from `searchParams.get('tab')`
- Lines 237-245: `TabNavigation` component handles tab clicks
- Lines 248-297: Conditional rendering based on `activeTab`

Looking at [TabNavigation.jsx](client/src/components/ui/TabNavigation.jsx):
- Lines 17-18: **PROBLEM** - Tabs with `count === 0` are filtered out: `const visibleTabs = tabs.filter(tab => tab.count > 0);`
- If performer has `gallery_count: 0` or missing, the tab won't render BUT the URL param may still be set

**Likely Issue:**
The tab filtering happens AFTER the URL is set, causing a mismatch. Or the counts are coming back as 0/undefined from the API causing tabs to be hidden after initial render.

**Files to Investigate:**
- `client/src/components/ui/TabNavigation.jsx` - Tab filtering logic
- `client/src/components/pages/PerformerDetail.jsx` - How counts are passed to tabs
- `client/src/components/pages/StudioDetail.jsx`
- `client/src/components/pages/TagDetail.jsx`
- `client/src/components/pages/CollectionDetail.jsx` (if exists)
- Server endpoints returning performer/studio/tag with counts

**Potential Fix:**
- Check if the entity counts are properly being returned from the API
- Check if there's a race condition between URL update and tab visibility
- Verify `group_count`, `gallery_count`, `image_count` are populated on entity fetch

---

## Issue 2: Tags Query Performance

**Severity:** MEDIUM - Usability issue, not broken

**Symptoms:**
- Tags list page is slow to load
- Tag detail page is slow
- Not unusable but noticeably slower than other entity types

**Root Cause Analysis:**

Looking at [server/controllers/library/tags.ts](server/controllers/library/tags.ts):
- Lines 19-75: `enhanceTagsWithPerformerScenes()` is O(n*m) where n=scenes and m=performers
- It loads ALL scenes and ALL performers to calculate counts
- Lines 21-22: `getAllScenes()` and `getAllPerformers()` are called on every tag list request

This is a classic N+1 or full-table-scan pattern that doesn't scale.

**Files to Investigate:**
- `server/controllers/library/tags.ts` - The `enhanceTagsWithPerformerScenes` function
- `server/services/StashEntityService.ts` - `getAllScenes` and `getAllPerformers` implementations
- Check if there are indexes on the relevant junction tables

**Potential Fix Options:**
1. **Pre-compute counts on sync** - Store `scene_count_via_performers` in the StashTag table
2. **Use SQL aggregation** - Replace the in-memory calculation with a SQL COUNT query
3. **Cache the results** - Store the enhanced tags in memory/redis with TTL
4. **Lazy load** - Only calculate performer scene counts when specifically requested

---

## Issue 3: O History Stored in JSON Column

**Severity:** LOW - Technical debt, not user-facing

**Current Implementation:**

From [schema.prisma](server/prisma/schema.prisma) line 72:
```prisma
oHistory Json @default("[]") // Array of timestamp strings when O was incremented
```

The O history is stored as a JSON array of timestamp strings within the WatchHistory table.

**Problems with this approach:**
1. Cannot efficiently query "all O events in the last week"
2. Cannot aggregate O events across scenes/performers without loading all JSON
3. JSON arrays don't scale well for users with thousands of O events
4. No referential integrity

**Proposed Schema:**

```prisma
model OEvent {
  id           Int       @id @default(autoincrement())
  userId       Int
  sceneId      String
  timestamp    DateTime  @default(now())

  user         User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  watchHistory WatchHistory? @relation(fields: [userId, sceneId], references: [userId, sceneId])

  @@index([userId])
  @@index([sceneId])
  @@index([timestamp])
  @@index([userId, timestamp])
}
```

**Migration Strategy:**
1. Create the new OEvent table
2. Write a data migration to move existing oHistory JSON arrays to the new table
3. Update all services that read/write oHistory to use the new table
4. Keep oHistory JSON for backward compatibility during migration period
5. Eventually deprecate and remove oHistory column

**Files to Change:**
- `server/prisma/schema.prisma` - Add OEvent model
- `server/controllers/watchHistory.ts` - Update increment-o endpoint
- `server/services/UserStatsService.ts` - Update O counter aggregation
- `server/services/SceneQueryBuilder.ts` - Update any O history queries

---

## Issue 4: O Counter UI Shows Stale Value After Playlist Navigation

**Severity:** MEDIUM - Confusing UX

**Symptoms:**
1. User increments O counter on Scene A (e.g., 0 â†’ 1)
2. User navigates to next scene (Scene B) in playlist
3. Scene B shows O counter value of 1 (from Scene A) instead of Scene B's actual value
4. This persists as user navigates through playlist
5. If user goes back to Scene A and then navigates away again, it resets correctly

**Root Cause Analysis:**

Looking at [ScenePlayerContext.jsx](client/src/contexts/ScenePlayerContext.jsx):
- Line 66: `oCounter` is set from scene data on load: `oCounter: scene.o_counter || 0`
- Lines 79-90: `incrementOCounter` updates local state on success

Looking at [scenePlayerReducer.js](client/src/contexts/scenePlayerReducer.js):
- Lines 397-402: `INCREMENT_O_COUNTER_SUCCESS` just increments: `oCounter: state.oCounter + 1`
- Lines 244-257 (NEXT_SCENE): Does NOT reset `oCounter` when changing scenes
- Lines 313-322 (PREV_SCENE): Does NOT reset `oCounter` when changing scenes

**The Bug:**
When navigating to next/prev scene, the `oCounter` state is NOT reset. The scene loads fresh data which should set the correct oCounter, but there may be a race condition where the old value persists.

**Files to Fix:**
- `client/src/contexts/scenePlayerReducer.js` - Add `oCounter: 0` reset in NEXT_SCENE and PREV_SCENE cases
- Alternatively, ensure LOAD_SCENE_SUCCESS always overwrites the oCounter

**Quick Fix:**
In `scenePlayerReducer.js`, add to NEXT_SCENE and PREV_SCENE cases:
```javascript
return {
  ...state,
  currentIndex: nextIndex,
  // ... existing resets
  oCounter: 0,  // ADD THIS LINE
  // ...
};
```

---

## Summary Table

| # | Issue | Severity | Effort | Recommend Fix Before Release |
|---|-------|----------|--------|------------------------------|
| 1 | Detail page tabs not loading | HIGH | Medium | Yes |
| 2 | Tags query slow | MEDIUM | High | No (post-release) |
| 3 | O History JSON schema | LOW | High | No (post-release) |
| 4 | O Counter stale UI | MEDIUM | Low | Yes |

---

## Recommended Branch Strategy

1. **Branch: `bugfix/detail-page-tabs`** - Fix issue #1
2. **Branch: `bugfix/o-counter-stale-state`** - Fix issue #4
3. **Branch: `perf/tags-query-optimization`** - Fix issue #2 (post-release)
4. **Branch: `refactor/o-history-table`** - Fix issue #3 (post-release)
