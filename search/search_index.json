{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"/]+|(?!\\b)(?=[A-Z][a-z])|\\.(?!\\d)|&[lg]t;","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to Peek Stash Browser","text":"<p>A modern web application for browsing and streaming your Stash media library with adaptive video streaming, playlists, and watch history tracking.</p> <ul> <li> Quick Start</li> </ul> <p>Get up and running in minutes with Docker or unRAID</p> <p> Installation</p> <ul> <li> Configuration</li> </ul> <p>Set up Peek to connect with your Stash server</p> <p> Setup Guide</p> <ul> <li> Troubleshooting</li> </ul> <p>Common issues and solutions</p> <p> Get Help</p>"},{"location":"#what-is-peek","title":"What is Peek?","text":"<p>Peek is a web-based browser for your Stash library, offering a sleek modern interface optimized for video streaming and playback.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Adaptive Video Streaming - Real-time HLS transcoding with multiple quality options (720p/480p/360p)</li> <li>Watch History Tracking - Automatic progress tracking and resume playback (Learn more)</li> <li>Playlist Management - Create, organize, and play custom playlists (Learn more)</li> <li>Modern Interface - Responsive React UI with theme support</li> <li>Full Keyboard Navigation - Complete TV remote and keyboard control support (Learn more)</li> <li>Mobile Ready - Optimized for all devices</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#installation","title":"Installation","text":"DockerunRAID <pre><code>docker run -d \\\n  --name peek-stash-browser \\\n  -p 6969:80 \\\n  -v /path/to/stash/media:/app/media:ro \\\n  -v /path/to/peek/data:/app/data \\\n  -e STASH_URL=\"http://your-stash:9999/graphql\" \\\n  -e STASH_API_KEY=\"your_api_key\" \\\n  carrotwaxr/peek-stash-browser:latest\n</code></pre> <ol> <li>Open Community Applications</li> <li>Search for \"Peek Stash Browser\"</li> <li>Click Install and configure</li> <li>Access at <code>http://your-unraid-ip:6969</code></li> </ol>"},{"location":"#first-login","title":"First Login","text":"<p>Default Credentials:</p> <ul> <li>Username: <code>admin</code></li> <li>Password: <code>admin</code></li> </ul> <p>Important: Change Default Password</p> <p>Immediately change your password after first login via Settings \u2192 My Settings</p>"},{"location":"#requirements","title":"Requirements","text":"<ul> <li>Stash server with GraphQL API enabled</li> <li>Docker (or unRAID)</li> <li>Network access between Peek and Stash</li> <li>Shared media storage accessible to both containers</li> </ul>"},{"location":"#architecture","title":"Architecture","text":"<p>Peek uses a single-container architecture:</p> <ul> <li>Frontend: React 19 app served by nginx</li> <li>Backend: Node.js/Express API server (proxied through nginx)</li> <li>Database: SQLite (embedded, no separate container)</li> <li>Transcoding: FFmpeg for real-time video conversion</li> </ul>"},{"location":"#community-support","title":"Community &amp; Support","text":"<ul> <li>Bug Reports: GitHub Issues</li> <li>Feature Requests: GitHub Issues</li> <li>Stash Community: Discord - #third-party-integrations channel</li> </ul>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the MIT License.</p>"},{"location":"#acknowledgments","title":"Acknowledgments","text":"<p>Built with Stash, React, Express, FFmpeg, and other amazing open source projects.</p>"},{"location":"design/cache-scalability-brainstorm/","title":"Cache Scalability Brainstorm","text":"<p>Issues: #135, #160 Branch: <code>feature/cache-scalability-investigation</code> Date: 2025-12-08</p>"},{"location":"design/cache-scalability-brainstorm/#problem-statement","title":"Problem Statement","text":"<p>Peek's cache initialization fails on large Stash libraries: - Issue #135: 24k scenes - GraphQL 422 error on groups fetch with <code>per_page: -1</code> - Issue #160: 104k scenes - Node.js <code>ERR_STRING_TOO_LONG</code> (~512MB string limit exceeded)</p> <p>Both issues stem from the same root cause: unbounded GraphQL queries that don't scale.</p>"},{"location":"design/cache-scalability-brainstorm/#current-architecture","title":"Current Architecture","text":""},{"location":"design/cache-scalability-brainstorm/#data-flow","title":"Data Flow","text":"<pre><code>Stash Server (source of truth)\n    \u2502\n    \u25bc per_page: -1 (fetch ALL)\nStashCacheManager (in-memory Maps)\n    \u2502\n    \u251c\u2500\u2500\u25ba FilteredEntityCacheService (per-user filtered views)\n    \u2502\n    \u2514\u2500\u2500\u25ba 18+ files (controllers, services, middleware)\n</code></pre>"},{"location":"design/cache-scalability-brainstorm/#why-the-cache-exists","title":"Why the Cache Exists","text":"<ol> <li>Performance: Avoid repeated GraphQL queries for browsing/filtering</li> <li>URL Transformation: Rewrite Stash URLs to Peek proxy URLs (hide API keys)</li> <li>User Restrictions: Cascade filtering (hidden performers \u2192 hidden scenes)</li> <li>Aggregations: \"Most watched performer\", \"Top tags by play count\"</li> <li>Multi-user Support: Different users see different filtered content</li> </ol>"},{"location":"design/cache-scalability-brainstorm/#current-memory-estimates","title":"Current Memory Estimates","text":"<ul> <li>~3KB per scene (with nested performers, tags, studio, files, paths)</li> <li>~1KB per performer/tag/studio</li> <li>100k scenes \u2248 300MB just for scenes</li> <li>Total with galleries, groups, etc. \u2248 400-500MB for large libraries</li> </ul>"},{"location":"design/cache-scalability-brainstorm/#the-scaling-wall","title":"The Scaling Wall","text":"Scenes Approximate JSON Size Status 10,000 ~30MB Works fine 25,000 ~75MB Works, slow startup 50,000 ~150MB Edge case, may fail 100,000 ~300MB Hits string limit, fails"},{"location":"design/cache-scalability-brainstorm/#questions-for-discussion","title":"Questions for Discussion","text":""},{"location":"design/cache-scalability-brainstorm/#q1-what-filtering-patterns-does-peek-actually-need","title":"Q1: What filtering patterns does Peek actually need?","text":"<p>Current usage patterns I observed: - Carousel: Random scenes, filtered by user restrictions - Browse: Paginated lists with sorting - Search: Text search across titles/performers - Stats: Aggregations like \"top performers by watch time\"</p> <p>Question: Are there filtering patterns that require all data in memory? Or could most be satisfied with paginated queries to Stash?</p>"},{"location":"design/cache-scalability-brainstorm/#q2-whats-the-acceptable-trade-off-between-memory-and-features","title":"Q2: What's the acceptable trade-off between memory and features?","text":"<p>Options range from: - Current: Everything in memory (fast, feature-rich, doesn't scale) - Hybrid: Metadata in memory, paginated queries for large result sets - Pass-through: Cache only IDs, query Stash for everything (slow, scales infinitely)</p> <p>Question: Which features would you sacrifice for scalability? Or is there a budget for more complex caching?</p>"},{"location":"design/cache-scalability-brainstorm/#q3-should-peek-own-its-own-entity-database","title":"Q3: Should Peek own its own entity database?","text":"<p>Currently Peek stores: - User data (watch history, ratings, favorites) - Path mappings, settings</p> <p>It does NOT store Stash entities (scenes, performers, etc.) - only caches them.</p> <p>Question: Would you consider syncing Stash entities to SQLite? This enables: - Pagination at the database level - SQL filtering/sorting - Survives restarts without re-fetching - Incremental updates via Stash webhooks</p> <p>Trade-off: Adds complexity, data duplication, sync challenges</p>"},{"location":"design/cache-scalability-brainstorm/#q4-whats-the-deployment-model-priority","title":"Q4: What's the deployment model priority?","text":"<p>Current: Docker-only (FFmpeg dependency)</p> <p>Future goal mentioned: Native binaries for Windows/Unix</p> <p>Question: Does the caching solution need to support both? SQLite works everywhere. Redis would complicate native deployment.</p>"},{"location":"design/cache-scalability-brainstorm/#solution-space","title":"Solution Space","text":""},{"location":"design/cache-scalability-brainstorm/#approach-a-paginated-fetching-minimal-change","title":"Approach A: Paginated Fetching (Minimal Change)","text":"<p>Idea: Keep current architecture, but fetch in pages to avoid string limit.</p> <pre><code>async function fetchAllScenes(): Promise&lt;Scene[]&gt; {\n  const PAGE_SIZE = 5000;\n  const allScenes: Scene[] = [];\n  let page = 1;\n\n  while (true) {\n    const result = await stash.findScenesCompact({\n      filter: { page, per_page: PAGE_SIZE }\n    });\n    allScenes.push(...result.findScenes.scenes);\n    if (allScenes.length &gt;= result.findScenes.count) break;\n    page++;\n  }\n  return allScenes;\n}\n</code></pre> <p>Pros: - Minimal code changes - Fixes the immediate crash - No architecture change</p> <p>Cons: - Still loads everything into memory - Memory still grows linearly with library size - 104k scenes still needs ~300MB RAM for scenes alone</p> <p>Verdict: Quick fix, not a real solution</p>"},{"location":"design/cache-scalability-brainstorm/#approach-b-sqlite-entity-cache-full-sync","title":"Approach B: SQLite Entity Cache (Full Sync)","text":"<p>Idea: Sync Stash entities to local SQLite database. Query database instead of in-memory Maps.</p> <pre><code>Stash Server\n    \u2502\n    \u25bc Paginated sync\nSQLite Database (scenes, performers, studios, tags, galleries, groups)\n    \u2502\n    \u25bc Prisma queries\nControllers/Services\n</code></pre> <p>Schema additions: <pre><code>model CachedScene {\n  id          String @id\n  title       String?\n  date        String?\n  studioId    String?\n  rating100   Int?\n  duration    Int?\n  // ... minimal fields for filtering/sorting\n  rawData     String // JSON blob for full data\n  lastSynced  DateTime\n\n  @@index([studioId])\n  @@index([date])\n  @@index([rating100])\n}\n</code></pre></p> <p>Sync Strategy: - Initial: Paginated full sync (5000 at a time) - Refresh: Incremental via <code>updated_at &gt; lastSync</code> filter - Stash webhooks: Real-time updates (optional enhancement)</p> <p>Query Strategy: - Browse: SQL pagination with sorting - Filter: SQL WHERE clauses - Full data: Fetch <code>rawData</code> JSON and deserialize</p> <p>Pros: - Unlimited scalability (SQLite handles millions of rows) - Fast SQL queries with indexes - Survives restarts - Incremental sync possible - Works for native binaries</p> <p>Cons: - Significant refactor - Data duplication (Stash + Peek) - Sync complexity (what if entities deleted in Stash?) - Need to handle schema evolution</p>"},{"location":"design/cache-scalability-brainstorm/#approach-c-hybrid-cache-metadata-in-memory-full-data-lazy-loaded","title":"Approach C: Hybrid Cache (Metadata in Memory, Full Data Lazy-Loaded)","text":"<p>Idea: Store minimal metadata in memory, fetch full data on-demand.</p> <pre><code>interface SceneMetadata {\n  id: string;\n  title: string;\n  date: string;\n  studioId: string;\n  performerIds: string[];\n  tagIds: string[];\n  rating100: number;\n  // No nested objects, no files, no paths\n}\n\n// In-memory: ~500 bytes per scene instead of ~3KB\nconst sceneMetadata = new Map&lt;string, SceneMetadata&gt;();\n\n// On-demand fetch for full data\nasync function getFullScene(id: string): Promise&lt;NormalizedScene&gt; {\n  const meta = sceneMetadata.get(id);\n  if (!meta) return null;\n\n  // Fetch full data from Stash (or a local cache)\n  const full = await stash.findScenes({ ids: [id] });\n  return transformScene(full.findScenes.scenes[0]);\n}\n</code></pre> <p>Pros: - 80% memory reduction - Most filtering works on metadata - Preserves current architecture patterns</p> <p>Cons: - Increases latency for full scene views - Complex to implement correctly - Still linear memory growth (just slower)</p>"},{"location":"design/cache-scalability-brainstorm/#approach-d-pass-through-to-stash-no-cache","title":"Approach D: Pass-through to Stash (No Cache)","text":"<p>Idea: Remove the cache entirely. Proxy all queries to Stash.</p> <p>Pros: - Simplest architecture - No sync issues - Stash handles all scalability</p> <p>Cons: - Loses user restrictions (can't filter without seeing all data) - Every request hits Stash (slower) - Can't aggregate stats across scenes - URL transformation happens on every request</p> <p>Verdict: Not viable - loses too many features</p>"},{"location":"design/cache-scalability-brainstorm/#approach-e-external-cache-redismemcached","title":"Approach E: External Cache (Redis/Memcached)","text":"<p>Idea: Use Redis for distributed caching.</p> <p>Pros: - Battle-tested scalability - Shared across instances - LRU eviction built-in</p> <p>Cons: - New dependency (complicates native deployment) - Overkill for single-user instances - Still need to handle large data serialization</p> <p>Verdict: Only makes sense for multi-node deployment, not the typical use case</p>"},{"location":"design/cache-scalability-brainstorm/#what-large-enterprise-apps-do","title":"What Large Enterprise Apps Do","text":""},{"location":"design/cache-scalability-brainstorm/#pattern-1-database-as-cache","title":"Pattern 1: Database as Cache","text":"<ul> <li>Example: Elasticsearch for search, PostgreSQL for source of truth</li> <li>Relevance: SQLite could serve as Peek's \"search index\"</li> </ul>"},{"location":"design/cache-scalability-brainstorm/#pattern-2-materialized-views","title":"Pattern 2: Materialized Views","text":"<ul> <li>Example: Pre-computed aggregations stored separately</li> <li>Relevance: Peek's FilteredEntityCacheService is already doing this per-user</li> </ul>"},{"location":"design/cache-scalability-brainstorm/#pattern-3-incremental-sync","title":"Pattern 3: Incremental Sync","text":"<ul> <li>Example: CDC (Change Data Capture), webhooks</li> <li>Relevance: Stash has a GraphQL subscription API for real-time updates</li> </ul>"},{"location":"design/cache-scalability-brainstorm/#pattern-4-tiered-caching","title":"Pattern 4: Tiered Caching","text":"<ul> <li>Example: L1 (in-memory, small, hot), L2 (disk, large, warm), L3 (remote, cold)</li> <li>Relevance: Memory \u2192 SQLite \u2192 Stash API</li> </ul>"},{"location":"design/cache-scalability-brainstorm/#pattern-5-pagination-cursor-based-navigation","title":"Pattern 5: Pagination + Cursor-based Navigation","text":"<ul> <li>Example: GraphQL connections with <code>after</code> cursor</li> <li>Relevance: Stash supports this, Peek could adopt it</li> </ul>"},{"location":"design/cache-scalability-brainstorm/#recommendation-questions","title":"Recommendation Questions","text":"<p>Before I recommend a specific approach, I need clarity on:</p> <ol> <li>Scope of refactor acceptable?</li> <li> <p>Quick fix (paginated fetch) vs. medium (hybrid) vs. large (SQLite sync)</p> </li> <li> <p>Feature preservation priority?</p> </li> <li>User restrictions cascade filtering</li> <li>Cross-scene aggregations (stats)</li> <li> <p>Fast browsing/search</p> </li> <li> <p>Stash API capabilities?</p> </li> <li>Does Stash support filtering by <code>updated_at</code>? (for incremental sync)</li> <li> <p>Does Stash have webhook support? (for real-time sync)</p> </li> <li> <p>Testing strategy?</p> </li> <li>Do we have access to a 100k+ scene library for testing?</li> <li>Can we simulate with synthetic data?</li> </ol>"},{"location":"design/cache-scalability-brainstorm/#decision-sqlite-entity-cache","title":"Decision: SQLite Entity Cache","text":"<p>After discussion, we've decided on Approach B: SQLite Entity Cache for the following reasons:</p>"},{"location":"design/cache-scalability-brainstorm/#why-sqlite","title":"Why SQLite?","text":"<ol> <li> <p>The pagination + filtering problem: If we paginate from Stash then apply user restrictions, we get fewer results than requested (e.g., request 50, restrictions remove 10, return 40). This breaks pagination. We need the full dataset locally.</p> </li> <li> <p>Memory doesn't scale: Current in-memory approach fails at ~50-100k scenes due to Node.js string limits and memory pressure.</p> </li> <li> <p>Minimal duplication: ~50-100MB for 100k scenes (vs 500MB+ in Stash). We store only what Peek needs.</p> </li> <li> <p>Offline resilience: Peek can serve browse requests even if Stash is temporarily unavailable.</p> </li> <li> <p>Native binary compatible: SQLite works everywhere - no Redis/external dependencies.</p> </li> </ol>"},{"location":"design/cache-scalability-brainstorm/#sync-strategy","title":"Sync Strategy","text":"<p>Sync Triggers: | Trigger | Type | When | |---------|------|------| | Startup | Full/Incremental | Peek server starts (full if first run) | | Scan complete | Incremental | Stash finishes scan (via WebSocket subscription) | | Polling | Incremental | Every N minutes (configurable, default 60, range 5-120) | | Manual | Full/Incremental | Admin triggers via UI | | Plugin webhook | Incremental | Optional - if Stash plugin installed |</p> <p>Sync Types: - Incremental: Query entities where <code>updated_at &gt; lastSyncTime</code>, upsert changes - Full: Paginated fetch of everything, used on first run or recovery</p> <p>Optional Real-Time Enhancement: A simple Stash plugin can POST to Peek on entity changes, enabling near real-time sync. This is optional - polling works without it, plugin makes it faster.</p>"},{"location":"design/cache-scalability-brainstorm/#entity-handling","title":"Entity Handling","text":"<ul> <li>Soft delete: Mark entities as deleted rather than hard-deleting</li> <li>Preserves Peek-specific data (watch history, ratings) if entity is re-added</li> <li>Allows user to see \"X scenes were removed from Stash\"</li> <li>Orphan detection: Periodic check for entities in Peek but not in Stash</li> </ul>"},{"location":"design/cache-scalability-brainstorm/#key-features-to-preserve","title":"Key Features to Preserve","text":"<ul> <li>\u2705 User restrictions (cascade filtering)</li> <li>\u2705 Stats/aggregations (computed from local DB)</li> <li>\u2705 Fast browsing (SQL pagination with indexes)</li> <li>\u26a0\ufe0f Offline resilience (partial - can browse cached data)</li> </ul>"},{"location":"design/cache-scalability-brainstorm/#next-steps","title":"Next Steps","text":"<ol> <li>Design the SQLite schema for cached entities</li> <li>Create migration strategy from in-memory to SQLite</li> <li>Implement incremental sync logic</li> <li>Add scanCompleteSubscribe WebSocket listener</li> <li>Update all 18+ dependent files to query SQLite instead of Maps</li> <li>Test with synthetic 100k+ scene dataset</li> </ol>"},{"location":"design/cache-scalability-brainstorm/#appendix-memory-calculation-details","title":"Appendix: Memory Calculation Details","text":""},{"location":"design/cache-scalability-brainstorm/#current-scene-object-size","title":"Current Scene Object Size","text":"<pre><code>{\n  id: \"12345\",                    // 5 bytes\n  title: \"Example Scene Title\",   // ~30 bytes\n  date: \"2024-01-15\",            // 10 bytes\n  // ... base fields ~500 bytes\n\n  performers: [                   // ~200 bytes each\n    { id, name, image_path, gender, tags: [...] }\n  ],\n  tags: [                         // ~50 bytes each\n    { id, name, image_path, favorite }\n  ],\n  studio: { id, name, tags: [...] },  // ~150 bytes\n  files: [{                       // ~300 bytes each\n    path, basename, duration, video_codec, audio_codec, ...\n  }],\n  paths: {                        // ~400 bytes\n    preview, screenshot, sprite, vtt, webp, caption\n  },\n  sceneStreams: [...]            // ~150 bytes\n}\n\n// Total: ~2-4KB per scene depending on performers/tags\n</code></pre>"},{"location":"design/cache-scalability-brainstorm/#memory-projection-table","title":"Memory Projection Table","text":"Scenes Minimal (500B) Current (~3KB) With Galleries 10,000 5 MB 30 MB 40 MB 50,000 25 MB 150 MB 200 MB 100,000 50 MB 300 MB 400 MB 250,000 125 MB 750 MB 1 GB"},{"location":"design/cache-scalability-plan/","title":"SQLite Entity Cache Implementation Plan","text":"<p>Issue: #135, #160 - Cache fails on large libraries (24k-104k scenes) Design Docs: cache-scalability-brainstorm.md, sqlite-cache-schema.md Branch: <code>feature/cache-scalability-investigation</code></p>"},{"location":"design/cache-scalability-plan/#overview","title":"Overview","text":"<p>Replace the in-memory <code>StashCacheManager</code> with a SQLite-backed entity cache that: - Syncs Stash entities to local database using paginated fetches - Queries via Prisma instead of in-memory Maps - Supports incremental sync via <code>updated_at</code> timestamps - Scales to 100k+ scenes without memory issues</p>"},{"location":"design/cache-scalability-plan/#phase-1-database-schema","title":"Phase 1: Database Schema","text":""},{"location":"design/cache-scalability-plan/#task-11-add-cached-entity-tables-to-prisma-schema","title":"Task 1.1: Add Cached Entity Tables to Prisma Schema","text":"<p>File: <code>server/prisma/schema.prisma</code></p> <p>Add the following models after existing models:</p> <pre><code>// ============================================================================\n// CACHED STASH ENTITIES\n// These tables store synced data from Stash for scalable querying\n// ============================================================================\n\nmodel CachedScene {\n  id              String    @id                    // Stash scene ID\n  stashInstanceId String?                          // Which Stash server\n\n  // Indexed fields for filtering/sorting\n  title           String?\n  code            String?\n  date            String?                          // YYYY-MM-DD\n  studioId        String?\n  rating100       Int?\n  duration        Int?                             // seconds (from file)\n  organized       Boolean   @default(false)\n\n  // Full entity data as JSON (performers, tags, files, paths, streams, etc.)\n  data            String                           // JSON blob\n\n  // Sync metadata\n  stashCreatedAt  DateTime?\n  stashUpdatedAt  DateTime?\n  syncedAt        DateTime  @default(now())\n  deletedAt       DateTime?                        // Soft delete\n\n  // Junction table relations\n  performers      ScenePerformer[]\n  tags            SceneTag[]\n  groups          SceneGroup[]\n  galleries       SceneGallery[]\n\n  @@index([studioId])\n  @@index([date])\n  @@index([stashCreatedAt])\n  @@index([stashUpdatedAt])\n  @@index([rating100])\n  @@index([duration])\n  @@index([deletedAt])\n}\n\nmodel CachedPerformer {\n  id              String    @id\n  stashInstanceId String?\n\n  name            String\n  disambiguation  String?\n  gender          String?\n  birthdate       String?\n  favorite        Boolean   @default(false)\n  rating100       Int?\n  sceneCount      Int       @default(0)\n  imageCount      Int       @default(0)\n  galleryCount    Int       @default(0)\n\n  data            String\n\n  stashCreatedAt  DateTime?\n  stashUpdatedAt  DateTime?\n  syncedAt        DateTime  @default(now())\n  deletedAt       DateTime?\n\n  scenes          ScenePerformer[]\n  images          ImagePerformer[]\n\n  @@index([name])\n  @@index([gender])\n  @@index([favorite])\n  @@index([rating100])\n  @@index([sceneCount])\n  @@index([stashUpdatedAt])\n  @@index([deletedAt])\n}\n\nmodel CachedStudio {\n  id              String    @id\n  stashInstanceId String?\n\n  name            String\n  parentId        String?\n  favorite        Boolean   @default(false)\n  rating100       Int?\n  sceneCount      Int       @default(0)\n  imageCount      Int       @default(0)\n  galleryCount    Int       @default(0)\n\n  data            String\n\n  stashCreatedAt  DateTime?\n  stashUpdatedAt  DateTime?\n  syncedAt        DateTime  @default(now())\n  deletedAt       DateTime?\n\n  @@index([name])\n  @@index([parentId])\n  @@index([favorite])\n  @@index([rating100])\n  @@index([sceneCount])\n  @@index([stashUpdatedAt])\n  @@index([deletedAt])\n}\n\nmodel CachedTag {\n  id              String    @id\n  stashInstanceId String?\n\n  name            String\n  favorite        Boolean   @default(false)\n  sceneCount      Int       @default(0)\n  imageCount      Int       @default(0)\n\n  data            String\n\n  stashCreatedAt  DateTime?\n  stashUpdatedAt  DateTime?\n  syncedAt        DateTime  @default(now())\n  deletedAt       DateTime?\n\n  scenes          SceneTag[]\n  images          ImageTag[]\n\n  @@index([name])\n  @@index([favorite])\n  @@index([sceneCount])\n  @@index([stashUpdatedAt])\n  @@index([deletedAt])\n}\n\nmodel CachedGroup {\n  id              String    @id\n  stashInstanceId String?\n\n  name            String\n  date            String?\n  studioId        String?\n  rating100       Int?\n  duration        Int?\n  sceneCount      Int       @default(0)\n\n  data            String\n\n  stashCreatedAt  DateTime?\n  stashUpdatedAt  DateTime?\n  syncedAt        DateTime  @default(now())\n  deletedAt       DateTime?\n\n  scenes          SceneGroup[]\n\n  @@index([name])\n  @@index([date])\n  @@index([studioId])\n  @@index([rating100])\n  @@index([sceneCount])\n  @@index([stashUpdatedAt])\n  @@index([deletedAt])\n}\n\nmodel CachedGallery {\n  id              String    @id\n  stashInstanceId String?\n\n  title           String?\n  date            String?\n  studioId        String?\n  rating100       Int?\n  imageCount      Int       @default(0)\n\n  data            String\n\n  stashCreatedAt  DateTime?\n  stashUpdatedAt  DateTime?\n  syncedAt        DateTime  @default(now())\n  deletedAt       DateTime?\n\n  scenes          SceneGallery[]\n  images          ImageGallery[]\n\n  @@index([title])\n  @@index([date])\n  @@index([studioId])\n  @@index([rating100])\n  @@index([imageCount])\n  @@index([stashUpdatedAt])\n  @@index([deletedAt])\n}\n\nmodel CachedImage {\n  id              String    @id\n  stashInstanceId String?\n\n  title           String?\n  date            String?\n  studioId        String?\n  rating100       Int?\n  oCounter        Int       @default(0)\n  organized       Boolean   @default(false)\n  width           Int?\n  height          Int?\n  fileSize        Int?\n\n  data            String\n\n  stashCreatedAt  DateTime?\n  stashUpdatedAt  DateTime?\n  syncedAt        DateTime  @default(now())\n  deletedAt       DateTime?\n\n  performers      ImagePerformer[]\n  tags            ImageTag[]\n  galleries       ImageGallery[]\n\n  @@index([studioId])\n  @@index([date])\n  @@index([rating100])\n  @@index([stashUpdatedAt])\n  @@index([deletedAt])\n}\n\n// Junction tables for efficient many-to-many queries\n\nmodel ScenePerformer {\n  sceneId         String\n  performerId     String\n  scene           CachedScene     @relation(fields: [sceneId], references: [id], onDelete: Cascade)\n  performer       CachedPerformer @relation(fields: [performerId], references: [id], onDelete: Cascade)\n\n  @@id([sceneId, performerId])\n  @@index([performerId])\n}\n\nmodel SceneTag {\n  sceneId         String\n  tagId           String\n  scene           CachedScene     @relation(fields: [sceneId], references: [id], onDelete: Cascade)\n  tag             CachedTag       @relation(fields: [tagId], references: [id], onDelete: Cascade)\n\n  @@id([sceneId, tagId])\n  @@index([tagId])\n}\n\nmodel SceneGroup {\n  sceneId         String\n  groupId         String\n  sceneIndex      Int?\n  scene           CachedScene     @relation(fields: [sceneId], references: [id], onDelete: Cascade)\n  group           CachedGroup     @relation(fields: [groupId], references: [id], onDelete: Cascade)\n\n  @@id([sceneId, groupId])\n  @@index([groupId])\n}\n\nmodel SceneGallery {\n  sceneId         String\n  galleryId       String\n  scene           CachedScene     @relation(fields: [sceneId], references: [id], onDelete: Cascade)\n  gallery         CachedGallery   @relation(fields: [galleryId], references: [id], onDelete: Cascade)\n\n  @@id([sceneId, galleryId])\n  @@index([galleryId])\n}\n\nmodel ImagePerformer {\n  imageId         String\n  performerId     String\n  image           CachedImage     @relation(fields: [imageId], references: [id], onDelete: Cascade)\n  performer       CachedPerformer @relation(fields: [performerId], references: [id], onDelete: Cascade)\n\n  @@id([imageId, performerId])\n  @@index([performerId])\n}\n\nmodel ImageTag {\n  imageId         String\n  tagId           String\n  image           CachedImage     @relation(fields: [imageId], references: [id], onDelete: Cascade)\n  tag             CachedTag       @relation(fields: [tagId], references: [id], onDelete: Cascade)\n\n  @@id([imageId, tagId])\n  @@index([tagId])\n}\n\nmodel ImageGallery {\n  imageId         String\n  galleryId       String\n  image           CachedImage     @relation(fields: [imageId], references: [id], onDelete: Cascade)\n  gallery         CachedGallery   @relation(fields: [galleryId], references: [id], onDelete: Cascade)\n\n  @@id([imageId, galleryId])\n  @@index([galleryId])\n}\n\n// Sync state tracking per entity type\nmodel SyncState {\n  id                    Int       @id @default(autoincrement())\n  stashInstanceId       String?\n  entityType            String                     // 'scene', 'performer', etc.\n\n  lastFullSync          DateTime?\n  lastIncrementalSync   DateTime?\n  lastSyncCount         Int       @default(0)\n  lastSyncDurationMs    Int?\n  lastError             String?\n  totalEntities         Int       @default(0)\n\n  @@unique([stashInstanceId, entityType])\n}\n\n// Sync settings (admin configurable)\nmodel SyncSettings {\n  id                    Int       @id @default(1)  // Singleton\n  syncIntervalMinutes   Int       @default(60)     // Default 60 min (current behavior)\n  enableScanSubscription Boolean  @default(true)   // Subscribe to scanCompleteSubscribe\n  enablePluginWebhook   Boolean   @default(false)  // Accept webhook from Stash plugin\n\n  updatedAt             DateTime  @updatedAt\n}\n</code></pre> <p>Verification: Run <code>npx prisma validate</code> to ensure schema is valid.</p>"},{"location":"design/cache-scalability-plan/#task-12-create-prisma-migration","title":"Task 1.2: Create Prisma Migration","text":"<p>Commands: <pre><code>cd server\nnpx prisma migrate dev --name add_cached_entities\n</code></pre></p> <p>This creates the migration file and applies it to the development database.</p> <p>Verification: Check that <code>server/prisma/migrations/*_add_cached_entities/migration.sql</code> exists.</p>"},{"location":"design/cache-scalability-plan/#task-13-add-fts5-full-text-search-via-raw-sql-migration","title":"Task 1.3: Add FTS5 Full-Text Search via Raw SQL Migration","text":"<p>File: Create <code>server/prisma/migrations/YYYYMMDDHHMMSS_add_fts5_search/migration.sql</code> manually</p> <pre><code>-- Create FTS5 virtual tables for full-text search\n-- Note: These are created via raw SQL because Prisma doesn't support virtual tables\n\nCREATE VIRTUAL TABLE IF NOT EXISTS scene_fts USING fts5(\n  id UNINDEXED,\n  title,\n  details,\n  code\n);\n\nCREATE VIRTUAL TABLE IF NOT EXISTS performer_fts USING fts5(\n  id UNINDEXED,\n  name,\n  aliases\n);\n\nCREATE VIRTUAL TABLE IF NOT EXISTS studio_fts USING fts5(\n  id UNINDEXED,\n  name\n);\n\nCREATE VIRTUAL TABLE IF NOT EXISTS tag_fts USING fts5(\n  id UNINDEXED,\n  name\n);\n\n-- Triggers to keep FTS in sync with main tables\n\nCREATE TRIGGER IF NOT EXISTS scene_fts_insert AFTER INSERT ON CachedScene BEGIN\n  INSERT INTO scene_fts(id, title, details, code)\n  VALUES (new.id, new.title, json_extract(new.data, '$.details'), new.code);\nEND;\n\nCREATE TRIGGER IF NOT EXISTS scene_fts_update AFTER UPDATE ON CachedScene BEGIN\n  DELETE FROM scene_fts WHERE id = old.id;\n  INSERT INTO scene_fts(id, title, details, code)\n  VALUES (new.id, new.title, json_extract(new.data, '$.details'), new.code);\nEND;\n\nCREATE TRIGGER IF NOT EXISTS scene_fts_delete AFTER DELETE ON CachedScene BEGIN\n  DELETE FROM scene_fts WHERE id = old.id;\nEND;\n\nCREATE TRIGGER IF NOT EXISTS performer_fts_insert AFTER INSERT ON CachedPerformer BEGIN\n  INSERT INTO performer_fts(id, name, aliases)\n  VALUES (new.id, new.name, json_extract(new.data, '$.aliases'));\nEND;\n\nCREATE TRIGGER IF NOT EXISTS performer_fts_update AFTER UPDATE ON CachedPerformer BEGIN\n  DELETE FROM performer_fts WHERE id = old.id;\n  INSERT INTO performer_fts(id, name, aliases)\n  VALUES (new.id, new.name, json_extract(new.data, '$.aliases'));\nEND;\n\nCREATE TRIGGER IF NOT EXISTS performer_fts_delete AFTER DELETE ON CachedPerformer BEGIN\n  DELETE FROM performer_fts WHERE id = old.id;\nEND;\n\nCREATE TRIGGER IF NOT EXISTS studio_fts_insert AFTER INSERT ON CachedStudio BEGIN\n  INSERT INTO studio_fts(id, name) VALUES (new.id, new.name);\nEND;\n\nCREATE TRIGGER IF NOT EXISTS studio_fts_update AFTER UPDATE ON CachedStudio BEGIN\n  DELETE FROM studio_fts WHERE id = old.id;\n  INSERT INTO studio_fts(id, name) VALUES (new.id, new.name);\nEND;\n\nCREATE TRIGGER IF NOT EXISTS studio_fts_delete AFTER DELETE ON CachedStudio BEGIN\n  DELETE FROM studio_fts WHERE id = old.id;\nEND;\n\nCREATE TRIGGER IF NOT EXISTS tag_fts_insert AFTER INSERT ON CachedTag BEGIN\n  INSERT INTO tag_fts(id, name) VALUES (new.id, new.name);\nEND;\n\nCREATE TRIGGER IF NOT EXISTS tag_fts_update AFTER UPDATE ON CachedTag BEGIN\n  DELETE FROM tag_fts WHERE id = old.id;\n  INSERT INTO tag_fts(id, name) VALUES (new.id, new.name);\nEND;\n\nCREATE TRIGGER IF NOT EXISTS tag_fts_delete AFTER DELETE ON CachedTag BEGIN\n  DELETE FROM tag_fts WHERE id = old.id;\nEND;\n</code></pre> <p>Verification: Run <code>npx prisma migrate deploy</code> and verify FTS tables exist in database.</p>"},{"location":"design/cache-scalability-plan/#phase-2-sync-service","title":"Phase 2: Sync Service","text":""},{"location":"design/cache-scalability-plan/#task-21-create-stashsyncservice","title":"Task 2.1: Create StashSyncService","text":"<p>File: <code>server/services/StashSyncService.ts</code></p> <p>This service handles all sync operations between Stash and the local SQLite cache.</p> <p>Key responsibilities: 1. Full sync: Paginated fetch of all entities (5000 per batch) 2. Incremental sync: Fetch only entities where <code>updated_at &gt; lastSyncTime</code> 3. Deletion detection: Mark entities as deleted if not in Stash response 4. Junction table management: Keep scene\u2194performer, scene\u2194tag, etc. in sync 5. Progress reporting: Emit events for UI progress display</p> <p>Implementation outline:</p> <pre><code>// server/services/StashSyncService.ts\n\nimport { PrismaClient } from '@prisma/client';\nimport { stashInstanceManager } from './StashInstanceManager.js';\nimport { transformScene, transformPerformer, /* etc */ } from '../utils/pathMapping.js';\nimport { logger } from '../utils/logger.js';\nimport { EventEmitter } from 'events';\n\ninterface SyncProgress {\n  entityType: string;\n  phase: 'fetching' | 'processing' | 'complete' | 'error';\n  current: number;\n  total: number;\n  message?: string;\n}\n\nclass StashSyncService extends EventEmitter {\n  private prisma: PrismaClient;\n  private syncInProgress = false;\n  private readonly PAGE_SIZE = 5000;\n\n  constructor(prisma: PrismaClient) {\n    super();\n    this.prisma = prisma;\n  }\n\n  /**\n   * Full sync - fetches all entities from Stash\n   * Used on first run or when incremental sync fails\n   */\n  async fullSync(stashInstanceId?: string): Promise&lt;void&gt; {\n    if (this.syncInProgress) {\n      throw new Error('Sync already in progress');\n    }\n\n    this.syncInProgress = true;\n    const startTime = Date.now();\n\n    try {\n      // Sync each entity type in order (dependencies first)\n      await this.syncStudios(stashInstanceId, true);\n      await this.syncTags(stashInstanceId, true);\n      await this.syncPerformers(stashInstanceId, true);\n      await this.syncGroups(stashInstanceId, true);\n      await this.syncGalleries(stashInstanceId, true);\n      await this.syncScenes(stashInstanceId, true);\n      await this.syncImages(stashInstanceId, true);\n\n      // Update sync state\n      await this.updateSyncState(stashInstanceId, 'full', Date.now() - startTime);\n\n      logger.info('Full sync completed', { durationMs: Date.now() - startTime });\n    } finally {\n      this.syncInProgress = false;\n    }\n  }\n\n  /**\n   * Incremental sync - fetches only changed entities\n   */\n  async incrementalSync(stashInstanceId?: string): Promise&lt;void&gt; {\n    if (this.syncInProgress) {\n      logger.warn('Sync already in progress, skipping');\n      return;\n    }\n\n    this.syncInProgress = true;\n    const startTime = Date.now();\n\n    try {\n      const lastSync = await this.getLastSyncTime(stashInstanceId);\n\n      if (!lastSync) {\n        logger.info('No previous sync found, performing full sync');\n        await this.fullSync(stashInstanceId);\n        return;\n      }\n\n      // Sync each entity type (only changed)\n      await this.syncStudios(stashInstanceId, false, lastSync);\n      await this.syncTags(stashInstanceId, false, lastSync);\n      await this.syncPerformers(stashInstanceId, false, lastSync);\n      await this.syncGroups(stashInstanceId, false, lastSync);\n      await this.syncGalleries(stashInstanceId, false, lastSync);\n      await this.syncScenes(stashInstanceId, false, lastSync);\n      await this.syncImages(stashInstanceId, false, lastSync);\n\n      // Update sync state\n      await this.updateSyncState(stashInstanceId, 'incremental', Date.now() - startTime);\n\n      logger.info('Incremental sync completed', { durationMs: Date.now() - startTime });\n    } finally {\n      this.syncInProgress = false;\n    }\n  }\n\n  /**\n   * Sync scenes with pagination\n   */\n  private async syncScenes(\n    stashInstanceId: string | undefined,\n    isFullSync: boolean,\n    lastSyncTime?: Date\n  ): Promise&lt;void&gt; {\n    const stash = stashInstanceManager.getDefault();\n    let page = 1;\n    let totalSynced = 0;\n\n    this.emit('progress', {\n      entityType: 'scene',\n      phase: 'fetching',\n      current: 0,\n      total: 0,\n    } as SyncProgress);\n\n    while (true) {\n      // Build filter for incremental sync\n      const filter = lastSyncTime ? {\n        updated_at: { modifier: 'GREATER_THAN', value: lastSyncTime.toISOString() }\n      } : undefined;\n\n      const result = await stash.findScenesCompact({\n        filter: { page, per_page: this.PAGE_SIZE },\n        scene_filter: filter,\n      });\n\n      const scenes = result.findScenes.scenes;\n      const total = result.findScenes.count;\n\n      if (scenes.length === 0) break;\n\n      // Process batch\n      await this.processScenessBatch(scenes, stashInstanceId);\n\n      totalSynced += scenes.length;\n      this.emit('progress', {\n        entityType: 'scene',\n        phase: 'processing',\n        current: totalSynced,\n        total,\n      } as SyncProgress);\n\n      if (totalSynced &gt;= total) break;\n      page++;\n    }\n\n    this.emit('progress', {\n      entityType: 'scene',\n      phase: 'complete',\n      current: totalSynced,\n      total: totalSynced,\n    } as SyncProgress);\n  }\n\n  /**\n   * Process a batch of scenes - upsert to database\n   */\n  private async processScenessBatch(scenes: any[], stashInstanceId?: string): Promise&lt;void&gt; {\n    for (const scene of scenes) {\n      const transformed = transformScene(scene);\n      const duration = scene.files?.[0]?.duration || null;\n\n      // Upsert scene\n      await this.prisma.cachedScene.upsert({\n        where: { id: scene.id },\n        update: {\n          title: scene.title,\n          code: scene.code,\n          date: scene.date,\n          studioId: scene.studio?.id || null,\n          rating100: scene.rating100,\n          duration,\n          organized: scene.organized || false,\n          data: JSON.stringify(transformed),\n          stashCreatedAt: scene.created_at ? new Date(scene.created_at) : null,\n          stashUpdatedAt: scene.updated_at ? new Date(scene.updated_at) : null,\n          syncedAt: new Date(),\n          deletedAt: null, // Clear soft delete if re-synced\n        },\n        create: {\n          id: scene.id,\n          stashInstanceId,\n          title: scene.title,\n          code: scene.code,\n          date: scene.date,\n          studioId: scene.studio?.id || null,\n          rating100: scene.rating100,\n          duration,\n          organized: scene.organized || false,\n          data: JSON.stringify(transformed),\n          stashCreatedAt: scene.created_at ? new Date(scene.created_at) : null,\n          stashUpdatedAt: scene.updated_at ? new Date(scene.updated_at) : null,\n        },\n      });\n\n      // Sync junction tables\n      await this.syncScenePerformers(scene.id, scene.performers || []);\n      await this.syncSceneTags(scene.id, scene.tags || []);\n      await this.syncSceneGroups(scene.id, scene.groups || []);\n      await this.syncSceneGalleries(scene.id, scene.galleries || []);\n    }\n  }\n\n  // Similar methods for other entity types...\n  // syncPerformers, syncStudios, syncTags, syncGroups, syncGalleries, syncImages\n\n  /**\n   * Sync scene\u2194performer junction table\n   */\n  private async syncScenePerformers(sceneId: string, performers: any[]): Promise&lt;void&gt; {\n    // Delete existing relationships\n    await this.prisma.scenePerformer.deleteMany({ where: { sceneId } });\n\n    // Insert new relationships\n    if (performers.length &gt; 0) {\n      await this.prisma.scenePerformer.createMany({\n        data: performers.map(p =&gt; ({ sceneId, performerId: p.id })),\n        skipDuplicates: true,\n      });\n    }\n  }\n\n  // Helper methods...\n}\n\nexport const stashSyncService = new StashSyncService(prisma);\n</code></pre> <p>Verification: Write unit tests for sync logic. Test with mock data.</p>"},{"location":"design/cache-scalability-plan/#task-22-create-sync-scheduler","title":"Task 2.2: Create Sync Scheduler","text":"<p>File: <code>server/services/SyncScheduler.ts</code></p> <p>Handles automatic sync triggers: - Startup sync - Polling interval (configurable, default 60 min) - Stash scan completion (WebSocket subscription) - Manual trigger</p> <p>Implementation outline:</p> <pre><code>// server/services/SyncScheduler.ts\n\nimport { stashSyncService } from './StashSyncService.js';\nimport { stashInstanceManager } from './StashInstanceManager.js';\nimport { logger } from '../utils/logger.js';\nimport prisma from '../prisma/singleton.js';\n\nclass SyncScheduler {\n  private intervalId: NodeJS.Timeout | null = null;\n  private wsConnection: WebSocket | null = null;\n\n  async start(): Promise&lt;void&gt; {\n    // Load settings\n    const settings = await prisma.syncSettings.findFirst() || {\n      syncIntervalMinutes: 60,\n      enableScanSubscription: true,\n    };\n\n    // Start polling interval\n    this.startPollingInterval(settings.syncIntervalMinutes);\n\n    // Start WebSocket subscription for scan events\n    if (settings.enableScanSubscription) {\n      this.startScanSubscription();\n    }\n\n    // Perform initial sync\n    await this.performStartupSync();\n  }\n\n  private startPollingInterval(intervalMinutes: number): void {\n    if (this.intervalId) {\n      clearInterval(this.intervalId);\n    }\n\n    const intervalMs = intervalMinutes * 60 * 1000;\n\n    this.intervalId = setInterval(async () =&gt; {\n      logger.info('Scheduled sync triggered');\n      try {\n        await stashSyncService.incrementalSync();\n      } catch (error) {\n        logger.error('Scheduled sync failed', { error });\n      }\n    }, intervalMs);\n\n    logger.info(`Sync scheduler started (interval: ${intervalMinutes} min)`);\n  }\n\n  private startScanSubscription(): void {\n    // Connect to Stash GraphQL WebSocket for scanCompleteSubscribe\n    // Implementation depends on graphql-ws or similar library\n    // When scan completes, trigger incrementalSync()\n  }\n\n  private async performStartupSync(): Promise&lt;void&gt; {\n    const syncState = await prisma.syncState.findFirst({\n      where: { entityType: 'scene' },\n    });\n\n    if (!syncState?.lastFullSync) {\n      logger.info('No previous sync found, performing full sync on startup');\n      await stashSyncService.fullSync();\n    } else {\n      logger.info('Performing incremental sync on startup');\n      await stashSyncService.incrementalSync();\n    }\n  }\n\n  stop(): void {\n    if (this.intervalId) {\n      clearInterval(this.intervalId);\n      this.intervalId = null;\n    }\n    if (this.wsConnection) {\n      this.wsConnection.close();\n      this.wsConnection = null;\n    }\n  }\n}\n\nexport const syncScheduler = new SyncScheduler();\n</code></pre>"},{"location":"design/cache-scalability-plan/#task-23-add-webhook-endpoint-for-optional-stash-plugin","title":"Task 2.3: Add Webhook Endpoint for Optional Stash Plugin","text":"<p>File: <code>server/routes/sync.ts</code></p> <pre><code>// POST /api/sync/notify - Webhook from Stash plugin\nrouter.post('/notify', requireAdmin, async (req, res) =&gt; {\n  const { entity, id, action } = req.body;\n\n  // Validate request\n  if (!entity || !id || !action) {\n    return res.status(400).json({ error: 'Missing required fields' });\n  }\n\n  // Queue single entity sync\n  await stashSyncService.syncSingleEntity(entity, id, action);\n\n  res.json({ ok: true });\n});\n\n// POST /api/sync/trigger - Manual sync trigger\nrouter.post('/trigger', requireAdmin, async (req, res) =&gt; {\n  const { type = 'incremental' } = req.body;\n\n  if (type === 'full') {\n    await stashSyncService.fullSync();\n  } else {\n    await stashSyncService.incrementalSync();\n  }\n\n  res.json({ ok: true });\n});\n\n// GET /api/sync/status - Get sync status\nrouter.get('/status', requireAuth, async (req, res) =&gt; {\n  const states = await prisma.syncState.findMany();\n  const settings = await prisma.syncSettings.findFirst();\n\n  res.json({ states, settings });\n});\n</code></pre>"},{"location":"design/cache-scalability-plan/#phase-3-query-service","title":"Phase 3: Query Service","text":""},{"location":"design/cache-scalability-plan/#task-31-create-cachedentityqueryservice","title":"Task 3.1: Create CachedEntityQueryService","text":"<p>File: <code>server/services/CachedEntityQueryService.ts</code></p> <p>This service replaces direct <code>stashCacheManager</code> calls with Prisma queries.</p> <p>Key methods:</p> <pre><code>class CachedEntityQueryService {\n  /**\n   * Get all scenes with filtering, sorting, pagination\n   */\n  async getScenes(options: {\n    userId: number;\n    filters?: SceneFilters;\n    sort?: string;\n    direction?: 'asc' | 'desc';\n    limit?: number;\n    offset?: number;\n  }): Promise&lt;{ scenes: NormalizedScene[]; total: number }&gt; {\n    // Build Prisma where clause from filters\n    // Apply user restrictions (hidden entities, content restrictions)\n    // Execute query with pagination\n    // Parse JSON data field\n    // Merge with user ratings/watch history\n    // Return results\n  }\n\n  /**\n   * Get single scene by ID\n   */\n  async getScene(id: string, userId: number): Promise&lt;NormalizedScene | null&gt; {\n    const cached = await prisma.cachedScene.findFirst({\n      where: { id, deletedAt: null },\n    });\n\n    if (!cached) return null;\n\n    const data = JSON.parse(cached.data);\n    // Merge with user data\n    return this.mergeSceneWithUserData(data, userId);\n  }\n\n  /**\n   * Full-text search across scenes\n   */\n  async searchScenes(query: string, userId: number, limit = 50): Promise&lt;NormalizedScene[]&gt; {\n    // Use FTS5 for search\n    const results = await prisma.$queryRaw`\n      SELECT s.id, s.data\n      FROM scene_fts\n      INNER JOIN CachedScene s ON scene_fts.id = s.id\n      WHERE scene_fts MATCH ${query}\n        AND s.deletedAt IS NULL\n      ORDER BY rank\n      LIMIT ${limit}\n    `;\n\n    // Filter by user restrictions\n    // Merge with user data\n    return results;\n  }\n\n  // Similar methods for performers, studios, tags, groups, galleries, images\n}\n\nexport const cachedEntityQueryService = new CachedEntityQueryService();\n</code></pre>"},{"location":"design/cache-scalability-plan/#task-32-create-query-builders-for-complex-filters","title":"Task 3.2: Create Query Builders for Complex Filters","text":"<p>File: <code>server/utils/queryBuilders.ts</code></p> <p>Helper functions to build Prisma <code>where</code> clauses from UI filter objects:</p> <pre><code>/**\n * Build Prisma where clause for scene filters\n */\nexport function buildSceneWhereClause(\n  filters: PeekSceneFilter,\n  userId: number,\n  hiddenEntityIds: { scenes: string[]; performers: string[]; studios: string[]; tags: string[] }\n): Prisma.CachedSceneWhereInput {\n  const where: Prisma.CachedSceneWhereInput = {\n    deletedAt: null,\n    id: { notIn: hiddenEntityIds.scenes },\n  };\n\n  // Studio filter\n  if (filters.studioIds?.length) {\n    where.studioId = { in: filters.studioIds };\n  }\n\n  // Hidden studios\n  if (hiddenEntityIds.studios.length) {\n    where.studioId = {\n      ...where.studioId,\n      notIn: hiddenEntityIds.studios,\n    };\n  }\n\n  // Date range\n  if (filters.dateFrom || filters.dateTo) {\n    where.date = {};\n    if (filters.dateFrom) where.date.gte = filters.dateFrom;\n    if (filters.dateTo) where.date.lte = filters.dateTo;\n  }\n\n  // Rating filter\n  if (filters.minRating !== undefined) {\n    where.rating100 = { gte: filters.minRating };\n  }\n\n  // Performer filter (requires subquery)\n  if (filters.performerIds?.length) {\n    where.performers = {\n      some: { performerId: { in: filters.performerIds } },\n    };\n  }\n\n  // Tag filter\n  if (filters.tagIds?.length) {\n    where.tags = {\n      some: { tagId: { in: filters.tagIds } },\n    };\n  }\n\n  // Exclude hidden performers (cascade)\n  if (hiddenEntityIds.performers.length) {\n    where.performers = {\n      ...where.performers,\n      none: { performerId: { in: hiddenEntityIds.performers } },\n    };\n  }\n\n  return where;\n}\n</code></pre>"},{"location":"design/cache-scalability-plan/#phase-4-controller-migration","title":"Phase 4: Controller Migration","text":""},{"location":"design/cache-scalability-plan/#task-41-update-scene-controllers","title":"Task 4.1: Update Scene Controllers","text":"<p>Files to modify: - <code>server/controllers/library/scenes.ts</code> - <code>server/controllers/carousel.ts</code></p> <p>Replace <code>stashCacheManager.getAllScenes()</code> with <code>cachedEntityQueryService.getScenes()</code>.</p> <p>Before: <pre><code>const allScenes = stashCacheManager.getAllScenes();\nlet filtered = allScenes.filter(/* ... */);\nfiltered.sort(/* ... */);\nconst paginated = filtered.slice(offset, offset + limit);\n</code></pre></p> <p>After: <pre><code>const { scenes, total } = await cachedEntityQueryService.getScenes({\n  userId,\n  filters,\n  sort,\n  direction,\n  limit,\n  offset,\n});\n</code></pre></p>"},{"location":"design/cache-scalability-plan/#task-42-update-performer-controllers","title":"Task 4.2: Update Performer Controllers","text":"<p>File: <code>server/controllers/library/performers.ts</code></p> <p>Same pattern as scenes. Replace in-memory filtering with database queries.</p>"},{"location":"design/cache-scalability-plan/#task-43-update-studio-controllers","title":"Task 4.3: Update Studio Controllers","text":"<p>File: <code>server/controllers/library/studios.ts</code></p>"},{"location":"design/cache-scalability-plan/#task-44-update-tag-controllers","title":"Task 4.4: Update Tag Controllers","text":"<p>File: <code>server/controllers/library/tags.ts</code></p>"},{"location":"design/cache-scalability-plan/#task-45-update-group-controllers","title":"Task 4.5: Update Group Controllers","text":"<p>File: <code>server/controllers/library/groups.ts</code></p>"},{"location":"design/cache-scalability-plan/#task-46-update-gallery-controllers","title":"Task 4.6: Update Gallery Controllers","text":"<p>File: <code>server/controllers/library/galleries.ts</code></p>"},{"location":"design/cache-scalability-plan/#task-47-update-image-controllers","title":"Task 4.7: Update Image Controllers","text":"<p>File: <code>server/controllers/library/images.ts</code></p>"},{"location":"design/cache-scalability-plan/#task-48-update-stats-controller","title":"Task 4.8: Update Stats Controller","text":"<p>File: <code>server/controllers/stats.ts</code></p> <p>Aggregations like \"top performers\" use SQL GROUP BY instead of in-memory loops.</p>"},{"location":"design/cache-scalability-plan/#task-49-update-user-services","title":"Task 4.9: Update User Services","text":"<p>Files: - <code>server/services/UserHiddenEntityService.ts</code> - <code>server/services/UserStatsService.ts</code></p> <p>These now query SQLite instead of in-memory cache.</p>"},{"location":"design/cache-scalability-plan/#task-410-update-auth-middleware","title":"Task 4.10: Update Auth Middleware","text":"<p>File: <code>server/middleware/auth.ts</code></p> <p>Replace <code>requireCacheReady()</code> with sync status check:</p> <pre><code>export const requireSyncComplete = async (req, res, next) =&gt; {\n  const syncState = await prisma.syncState.findFirst({\n    where: { entityType: 'scene' },\n  });\n\n  if (!syncState?.lastFullSync &amp;&amp; !syncState?.lastIncrementalSync) {\n    return res.status(503).json({\n      error: 'Initial sync in progress',\n      message: 'Please wait for sync to complete',\n    });\n  }\n\n  next();\n};\n</code></pre>"},{"location":"design/cache-scalability-plan/#phase-5-cleanup","title":"Phase 5: Cleanup","text":""},{"location":"design/cache-scalability-plan/#task-51-remove-stashcachemanager","title":"Task 5.1: Remove StashCacheManager","text":"<p>Delete file: <code>server/services/StashCacheManager.ts</code></p> <p>Remove imports from all 17 files that currently import it.</p>"},{"location":"design/cache-scalability-plan/#task-52-remove-filteredentitycacheservice","title":"Task 5.2: Remove FilteredEntityCacheService","text":"<p>Delete file: <code>server/services/FilteredEntityCacheService.ts</code></p> <p>SQLite queries with user filtering replace this entirely.</p>"},{"location":"design/cache-scalability-plan/#task-53-update-cache-initializer","title":"Task 5.3: Update Cache Initializer","text":"<p>File: <code>server/initializers/cache.ts</code></p> <p>Replace with sync initialization:</p> <pre><code>export const initializeSync = async () =&gt; {\n  logger.info('Starting sync scheduler...');\n  await syncScheduler.start();\n  logger.info('Sync scheduler started');\n};\n</code></pre>"},{"location":"design/cache-scalability-plan/#task-54-update-server-entry-point","title":"Task 5.4: Update Server Entry Point","text":"<p>File: <code>server/index.ts</code></p> <p>Replace cache initialization with sync initialization.</p>"},{"location":"design/cache-scalability-plan/#phase-6-testing-validation","title":"Phase 6: Testing &amp; Validation","text":""},{"location":"design/cache-scalability-plan/#task-61-create-synthetic-test-data-generator","title":"Task 6.1: Create Synthetic Test Data Generator","text":"<p>File: <code>server/scripts/generateTestData.ts</code></p> <p>Generate 100k+ fake scenes for testing scalability.</p>"},{"location":"design/cache-scalability-plan/#task-62-write-integration-tests","title":"Task 6.2: Write Integration Tests","text":"<ul> <li>Test full sync with large dataset</li> <li>Test incremental sync</li> <li>Test query performance</li> <li>Test FTS search</li> <li>Test user restrictions</li> </ul>"},{"location":"design/cache-scalability-plan/#task-63-performance-benchmarks","title":"Task 6.3: Performance Benchmarks","text":"<p>Compare: - Memory usage (before vs after) - Startup time - Query response times - Sync duration for various library sizes</p>"},{"location":"design/cache-scalability-plan/#phase-7-ui-updates","title":"Phase 7: UI Updates","text":""},{"location":"design/cache-scalability-plan/#task-71-add-sync-status-to-server-settings","title":"Task 7.1: Add Sync Status to Server Settings","text":"<p>Show: - Last sync time per entity type - Total entities synced - Sync progress (when running) - Error messages</p>"},{"location":"design/cache-scalability-plan/#task-72-add-sync-interval-setting","title":"Task 7.2: Add Sync Interval Setting","text":"<p>Allow admin to configure polling interval (5-120 minutes).</p>"},{"location":"design/cache-scalability-plan/#task-73-add-manual-sync-buttons","title":"Task 7.3: Add Manual Sync Buttons","text":"<ul> <li>\"Incremental Sync\" - sync changes only</li> <li>\"Full Sync\" - re-sync everything</li> </ul>"},{"location":"design/cache-scalability-plan/#verification-checklist","title":"Verification Checklist","text":"<p>After implementation, verify:</p> <ul> <li> Fresh install works (full sync on first run)</li> <li> Existing install migrates cleanly</li> <li> 100k scene library loads without errors</li> <li> Memory usage stays under 200MB</li> <li> Scene browsing responds in &lt;100ms</li> <li> Search works with FTS5</li> <li> User restrictions apply correctly</li> <li> Stats/aggregations work</li> <li> Incremental sync detects changes</li> <li> Soft delete works (removed scenes hidden but recoverable)</li> <li> All 17 dependent files updated</li> <li> No references to old StashCacheManager</li> </ul>"},{"location":"design/cache-scalability-plan/#rollback-plan","title":"Rollback Plan","text":"<p>If issues arise: 1. Keep old StashCacheManager code on a branch 2. Add feature flag to switch between old/new 3. Can revert by setting flag and redeploying</p>"},{"location":"design/cache-scalability-plan/#estimated-scope","title":"Estimated Scope","text":"Phase Tasks Complexity Phase 1: Schema 3 Medium Phase 2: Sync Service 3 High Phase 3: Query Service 2 Medium Phase 4: Controller Migration 10 Medium (repetitive) Phase 5: Cleanup 4 Low Phase 6: Testing 3 Medium Phase 7: UI 3 Low Total 28 tasks <p>This is a significant refactor but follows a clear progression: schema \u2192 sync \u2192 query \u2192 migrate \u2192 cleanup \u2192 test \u2192 UI.</p>"},{"location":"design/json-blob-elimination-plan/","title":"JSON Blob Elimination Plan","text":"<p>Date: 2025-12-09 Status: Planning Branch: <code>feature/cache-scalability-investigation</code> Related: sqlite-cache-schema.md, cache-scalability-plan.md</p>"},{"location":"design/json-blob-elimination-plan/#problem-statement","title":"Problem Statement","text":"<p>The current SQLite cache implementation stores entity data in a JSON blob column (<code>data</code>), which causes severe performance issues:</p> <ol> <li>Sync Performance: ~100 scenes/minute = 3.6 hours for 22k scenes</li> <li>JSON Serialization: Every upsert requires <code>JSON.stringify()</code> of large objects</li> <li>Junction Tables: 4 DELETE + 4 INSERT operations per scene (performers, tags, groups, galleries)</li> <li>Query Overhead: Every read requires <code>JSON.parse()</code> to access data</li> </ol> <p>The JSON blob approach was chosen for simplicity but doesn't scale. We need a proper normalized schema.</p>"},{"location":"design/json-blob-elimination-plan/#additional-problem-sync-state-logic","title":"Additional Problem: Sync State Logic","text":"<p>The current startup sync logic only checks for scene sync state:</p> <pre><code>// SyncScheduler.ts - performStartupSync()\nconst syncState = await prisma.syncState.findFirst({\n  where: { entityType: \"scene\" },\n});\n\nconst hasCompletedSync = syncState?.lastFullSync || syncState?.lastIncrementalSync;\n\nif (!hasCompletedSync) {\n  // Full sync triggered even though Studios, Tags, Performers etc may be complete\n  await stashSyncService.fullSync();\n}\n</code></pre> <p>Issues: 1. Only checks scene sync state - ignores other entity types 2. If scene sync fails/never completes, full sync is triggered every restart 3. Already-synced entities (Studios, Tags, Performers) are re-synced unnecessarily 4. Full sync doesn't use per-entity incremental logic</p> <p>Required Fix: Each entity type should independently check its own sync state and skip if nothing changed since last sync.</p>"},{"location":"design/json-blob-elimination-plan/#solution-eliminate-json-blob","title":"Solution: Eliminate JSON Blob","text":"<p>Store all consumed fields as individual database columns. Transform URLs at read time instead of storing transformed values.</p>"},{"location":"design/json-blob-elimination-plan/#key-insight-url-transformation","title":"Key Insight: URL Transformation","text":"<p>Currently, <code>transformScene()</code> converts Stash URLs to proxy URLs at sync time and stores them in the JSON blob. This is wasteful because:</p> <ol> <li>URLs contain the Stash host which may change</li> <li>We're storing redundant data (full nested objects)</li> <li>Transformation is a simple prefix replacement that can happen at read time</li> </ol> <p>New approach: Store only Stash entity IDs. Transform URLs when constructing the response.</p>"},{"location":"design/json-blob-elimination-plan/#phase-1-schema-redesign","title":"Phase 1: Schema Redesign","text":""},{"location":"design/json-blob-elimination-plan/#cachedscene-expanded-columns","title":"CachedScene - Expanded Columns","text":"<p>Replace JSON blob with explicit columns for all consumed fields:</p> <pre><code>model CachedScene {\n  id              String    @id\n  stashInstanceId String?\n\n  // === Core fields (already indexed) ===\n  title           String?\n  code            String?\n  date            String?                   // YYYY-MM-DD\n  studioId        String?\n  rating100       Int?\n  duration        Int?                      // seconds (from primary file)\n  organized       Boolean   @default(false)\n\n  // === New fields from JSON blob ===\n  details         String?                   // Scene description (used in search)\n\n  // Primary file metadata\n  filePath        String?                   // Primary file path\n  fileBitRate     Int?                      // bits/second\n  fileFrameRate   Float?                    // fps\n  fileWidth       Int?                      // pixels\n  fileHeight      Int?                      // pixels\n  fileVideoCodec  String?                   // e.g., \"h264\", \"hevc\"\n  fileAudioCodec  String?                   // e.g., \"aac\", \"ac3\"\n  fileSize        BigInt?                   // bytes (can be &gt; 4GB)\n\n  // Stash paths (raw, transformed at read time)\n  pathScreenshot  String?                   // Screenshot URL path\n  pathPreview     String?                   // Preview video path\n  pathSprite      String?                   // Sprite sheet path\n  pathVtt         String?                   // VTT chapter path\n  pathChaptersVtt String?                   // Chapters VTT path\n  pathStream      String?                   // Primary stream path\n  pathCaption     String?                   // Caption path\n\n  // Scene streams (JSON array - small, rarely changes)\n  streams         String?                   // JSON: [{url, mime_type, label}]\n\n  // Sync metadata\n  stashCreatedAt  DateTime?\n  stashUpdatedAt  DateTime?\n  syncedAt        DateTime  @default(now())\n  deletedAt       DateTime?\n\n  // Junction table relations\n  performers      ScenePerformer[]\n  tags            SceneTag[]\n  groups          SceneGroup[]\n  galleries       SceneGallery[]\n\n  @@index([studioId])\n  @@index([date])\n  @@index([stashCreatedAt])\n  @@index([stashUpdatedAt])\n  @@index([rating100])\n  @@index([duration])\n  @@index([deletedAt])\n}\n</code></pre>"},{"location":"design/json-blob-elimination-plan/#cachedperformer-expanded-columns","title":"CachedPerformer - Expanded Columns","text":"<pre><code>model CachedPerformer {\n  id              String    @id\n  stashInstanceId String?\n\n  // === Core fields ===\n  name            String\n  disambiguation  String?\n  gender          String?\n  birthdate       String?\n  favorite        Boolean   @default(false)\n  rating100       Int?\n  sceneCount      Int       @default(0)\n  imageCount      Int       @default(0)\n  galleryCount    Int       @default(0)\n\n  // === New fields from JSON blob ===\n  aliasList       String?                   // JSON array of aliases\n  imagePath       String?                   // Raw image URL path\n  details         String?                   // Biography\n\n  // Additional performer metadata\n  country         String?\n  ethnicity       String?\n  hairColor       String?\n  eyeColor        String?\n  height          Int?                      // cm\n  weight          Int?                      // kg\n  measurements    String?                   // e.g., \"34D-24-34\"\n  tattoos         String?\n  piercings       String?\n  careerLength    String?\n  deathDate       String?\n  url             String?                   // Homepage\n\n  // Sync metadata\n  stashCreatedAt  DateTime?\n  stashUpdatedAt  DateTime?\n  syncedAt        DateTime  @default(now())\n  deletedAt       DateTime?\n\n  // Relations\n  scenes          ScenePerformer[]\n  images          ImagePerformer[]\n  tags            PerformerTag[]            // NEW: performers can have tags\n\n  @@index([name])\n  @@index([gender])\n  @@index([favorite])\n  @@index([rating100])\n  @@index([sceneCount])\n  @@index([stashUpdatedAt])\n  @@index([deletedAt])\n}\n</code></pre>"},{"location":"design/json-blob-elimination-plan/#cachedstudio-expanded-columns","title":"CachedStudio - Expanded Columns","text":"<pre><code>model CachedStudio {\n  id              String    @id\n  stashInstanceId String?\n\n  // === Core fields ===\n  name            String\n  parentId        String?\n  favorite        Boolean   @default(false)\n  rating100       Int?\n  sceneCount      Int       @default(0)\n  imageCount      Int       @default(0)\n  galleryCount    Int       @default(0)\n\n  // === New fields ===\n  details         String?                   // Studio description\n  imagePath       String?                   // Raw logo URL path\n  url             String?                   // Studio website\n\n  // Sync metadata\n  stashCreatedAt  DateTime?\n  stashUpdatedAt  DateTime?\n  syncedAt        DateTime  @default(now())\n  deletedAt       DateTime?\n\n  // Relations\n  tags            StudioTag[]               // NEW: studios can have tags\n\n  @@index([name])\n  @@index([parentId])\n  @@index([favorite])\n  @@index([rating100])\n  @@index([sceneCount])\n  @@index([stashUpdatedAt])\n  @@index([deletedAt])\n}\n</code></pre>"},{"location":"design/json-blob-elimination-plan/#cachedtag-expanded-columns","title":"CachedTag - Expanded Columns","text":"<pre><code>model CachedTag {\n  id              String    @id\n  stashInstanceId String?\n\n  // === Core fields ===\n  name            String\n  favorite        Boolean   @default(false)\n  sceneCount      Int       @default(0)\n  imageCount      Int       @default(0)\n\n  // === New fields ===\n  description     String?                   // Tag description\n  imagePath       String?                   // Tag image URL path\n  parentId        String?                   // Parent tag for hierarchy\n\n  // Sync metadata\n  stashCreatedAt  DateTime?\n  stashUpdatedAt  DateTime?\n  syncedAt        DateTime  @default(now())\n  deletedAt       DateTime?\n\n  // Relations\n  scenes          SceneTag[]\n  images          ImageTag[]\n  performers      PerformerTag[]\n  studios         StudioTag[]\n\n  @@index([name])\n  @@index([favorite])\n  @@index([sceneCount])\n  @@index([parentId])\n  @@index([stashUpdatedAt])\n  @@index([deletedAt])\n}\n</code></pre>"},{"location":"design/json-blob-elimination-plan/#new-junction-tables","title":"New Junction Tables","text":"<pre><code>// Performer tags (for tag filtering that includes performer tags)\nmodel PerformerTag {\n  performerId     String\n  tagId           String\n  performer       CachedPerformer @relation(fields: [performerId], references: [id], onDelete: Cascade)\n  tag             CachedTag       @relation(fields: [tagId], references: [id], onDelete: Cascade)\n\n  @@id([performerId, tagId])\n  @@index([tagId])\n}\n\n// Studio tags\nmodel StudioTag {\n  studioId        String\n  tagId           String\n  studio          CachedStudio    @relation(fields: [studioId], references: [id], onDelete: Cascade)\n  tag             CachedTag       @relation(fields: [tagId], references: [id], onDelete: Cascade)\n\n  @@id([studioId, tagId])\n  @@index([tagId])\n}\n</code></pre>"},{"location":"design/json-blob-elimination-plan/#phase-2-sync-optimization","title":"Phase 2: Sync Optimization","text":""},{"location":"design/json-blob-elimination-plan/#strategy-1-batch-upserts-with-raw-sql","title":"Strategy 1: Batch Upserts with Raw SQL","text":"<p>Replace Prisma individual upserts with bulk raw SQL:</p> <pre><code>private async processScenesBatchOptimized(\n  scenes: Scene[],\n  stashInstanceId: string | undefined\n): Promise&lt;void&gt; {\n  // Build batch INSERT...ON CONFLICT statement\n  const values = scenes.map(scene =&gt; {\n    const file = scene.files?.[0];\n    const paths = scene.paths;\n\n    return `(\n      '${scene.id}',\n      ${stashInstanceId ? `'${stashInstanceId}'` : 'NULL'},\n      ${escape(scene.title)},\n      ${escape(scene.code)},\n      ${escape(scene.date)},\n      ${scene.studio?.id ? `'${scene.studio.id}'` : 'NULL'},\n      ${scene.rating100 ?? 'NULL'},\n      ${file?.duration ? Math.round(file.duration) : 'NULL'},\n      ${scene.organized ? 1 : 0},\n      ${escape(scene.details)},\n      ${escape(file?.path)},\n      ${file?.bit_rate ?? 'NULL'},\n      ${file?.frame_rate ?? 'NULL'},\n      ${file?.width ?? 'NULL'},\n      ${file?.height ?? 'NULL'},\n      ${escape(file?.video_codec)},\n      ${escape(file?.audio_codec)},\n      ${file?.size ?? 'NULL'},\n      ${escape(paths?.screenshot)},\n      ${escape(paths?.preview)},\n      ${escape(paths?.sprite)},\n      ${escape(paths?.vtt)},\n      ${escape(paths?.chapters_vtt)},\n      ${escape(paths?.stream)},\n      ${escape(paths?.caption)},\n      ${escape(JSON.stringify(scene.sceneStreams || []))},\n      ${scene.created_at ? `'${scene.created_at}'` : 'NULL'},\n      ${scene.updated_at ? `'${scene.updated_at}'` : 'NULL'},\n      datetime('now'),\n      NULL\n    )`;\n  }).join(',\\n');\n\n  await prisma.$executeRawUnsafe(`\n    INSERT INTO CachedScene (\n      id, stashInstanceId, title, code, date, studioId, rating100, duration,\n      organized, details, filePath, fileBitRate, fileFrameRate, fileWidth,\n      fileHeight, fileVideoCodec, fileAudioCodec, fileSize, pathScreenshot,\n      pathPreview, pathSprite, pathVtt, pathChaptersVtt, pathStream, pathCaption,\n      streams, stashCreatedAt, stashUpdatedAt, syncedAt, deletedAt\n    ) VALUES ${values}\n    ON CONFLICT(id) DO UPDATE SET\n      title = excluded.title,\n      code = excluded.code,\n      date = excluded.date,\n      studioId = excluded.studioId,\n      rating100 = excluded.rating100,\n      duration = excluded.duration,\n      organized = excluded.organized,\n      details = excluded.details,\n      filePath = excluded.filePath,\n      fileBitRate = excluded.fileBitRate,\n      fileFrameRate = excluded.fileFrameRate,\n      fileWidth = excluded.fileWidth,\n      fileHeight = excluded.fileHeight,\n      fileVideoCodec = excluded.fileVideoCodec,\n      fileAudioCodec = excluded.fileAudioCodec,\n      fileSize = excluded.fileSize,\n      pathScreenshot = excluded.pathScreenshot,\n      pathPreview = excluded.pathPreview,\n      pathSprite = excluded.pathSprite,\n      pathVtt = excluded.pathVtt,\n      pathChaptersVtt = excluded.pathChaptersVtt,\n      pathStream = excluded.pathStream,\n      pathCaption = excluded.pathCaption,\n      streams = excluded.streams,\n      stashCreatedAt = excluded.stashCreatedAt,\n      stashUpdatedAt = excluded.stashUpdatedAt,\n      syncedAt = excluded.syncedAt,\n      deletedAt = NULL\n  `);\n}\n</code></pre>"},{"location":"design/json-blob-elimination-plan/#strategy-2-batch-junction-table-operations","title":"Strategy 2: Batch Junction Table Operations","text":"<p>Instead of per-scene DELETE + INSERT, batch by page:</p> <pre><code>private async syncSceneJunctionTablesOptimized(\n  scenes: Scene[]\n): Promise&lt;void&gt; {\n  const sceneIds = scenes.map(s =&gt; s.id);\n\n  // Single DELETE per junction table for entire batch\n  await Promise.all([\n    prisma.$executeRawUnsafe(\n      `DELETE FROM ScenePerformer WHERE sceneId IN (${sceneIds.map(id =&gt; `'${id}'`).join(',')})`\n    ),\n    prisma.$executeRawUnsafe(\n      `DELETE FROM SceneTag WHERE sceneId IN (${sceneIds.map(id =&gt; `'${id}'`).join(',')})`\n    ),\n    prisma.$executeRawUnsafe(\n      `DELETE FROM SceneGroup WHERE sceneId IN (${sceneIds.map(id =&gt; `'${id}'`).join(',')})`\n    ),\n    prisma.$executeRawUnsafe(\n      `DELETE FROM SceneGallery WHERE sceneId IN (${sceneIds.map(id =&gt; `'${id}'`).join(',')})`\n    ),\n  ]);\n\n  // Collect all junction records\n  const performerRecords: string[] = [];\n  const tagRecords: string[] = [];\n  const groupRecords: string[] = [];\n  const galleryRecords: string[] = [];\n\n  for (const scene of scenes) {\n    for (const p of scene.performers || []) {\n      performerRecords.push(`('${scene.id}', '${p.id}')`);\n    }\n    for (const t of scene.tags || []) {\n      tagRecords.push(`('${scene.id}', '${t.id}')`);\n    }\n    for (const g of scene.groups || []) {\n      const index = g.scene_index ?? 'NULL';\n      groupRecords.push(`('${scene.id}', '${g.id}', ${index})`);\n    }\n    for (const g of scene.galleries || []) {\n      galleryRecords.push(`('${scene.id}', '${g.id}')`);\n    }\n  }\n\n  // Single INSERT per junction table\n  const inserts = [];\n\n  if (performerRecords.length &gt; 0) {\n    inserts.push(prisma.$executeRawUnsafe(\n      `INSERT OR IGNORE INTO ScenePerformer (sceneId, performerId) VALUES ${performerRecords.join(',')}`\n    ));\n  }\n  if (tagRecords.length &gt; 0) {\n    inserts.push(prisma.$executeRawUnsafe(\n      `INSERT OR IGNORE INTO SceneTag (sceneId, tagId) VALUES ${tagRecords.join(',')}`\n    ));\n  }\n  if (groupRecords.length &gt; 0) {\n    inserts.push(prisma.$executeRawUnsafe(\n      `INSERT OR IGNORE INTO SceneGroup (sceneId, groupId, sceneIndex) VALUES ${groupRecords.join(',')}`\n    ));\n  }\n  if (galleryRecords.length &gt; 0) {\n    inserts.push(prisma.$executeRawUnsafe(\n      `INSERT OR IGNORE INTO SceneGallery (sceneId, galleryId) VALUES ${galleryRecords.join(',')}`\n    ));\n  }\n\n  await Promise.all(inserts);\n}\n</code></pre>"},{"location":"design/json-blob-elimination-plan/#expected-performance-improvement","title":"Expected Performance Improvement","text":"Operation Before After Improvement Scene upsert 1 Prisma call/scene 1 SQL/batch 100x fewer calls JSON.stringify Every scene None Eliminated Junction deletes 4 calls/scene 4 calls/batch 100x fewer calls Junction inserts 4 calls/scene 4 calls/batch 100x fewer calls Total per batch ~500 DB calls ~9 DB calls 55x reduction <p>With 100 scenes per batch: - Before: 500+ Prisma operations - After: 9 raw SQL operations</p> <p>Projected sync time for 22k scenes: ~4-6 minutes instead of 3.6 hours</p>"},{"location":"design/json-blob-elimination-plan/#phase-25-fix-sync-state-logic-priority","title":"Phase 2.5: Fix Sync State Logic (PRIORITY)","text":"<p>This should be implemented before the JSON blob elimination to prevent unnecessary re-syncing.</p>"},{"location":"design/json-blob-elimination-plan/#problem","title":"Problem","text":"<p>Current <code>performStartupSync()</code> only checks scene sync state: - If scenes never completed, ALL entity types are re-synced from scratch - Studios, Tags, Performers that already synced are re-fetched needlessly</p>"},{"location":"design/json-blob-elimination-plan/#solution-smart-per-entity-sync","title":"Solution: Smart Per-Entity Sync","text":"<p>Each entity type should: 1. Check its own SyncState record 2. Query Stash for count of entities updated since last sync 3. Skip if nothing changed (count = 0) 4. Only fetch changed entities if count &gt; 0</p>"},{"location":"design/json-blob-elimination-plan/#implementation","title":"Implementation","text":"<pre><code>// SyncScheduler.ts\nprivate async performStartupSync(): Promise&lt;void&gt; {\n  // Check sync state for ALL entity types, not just scenes\n  const syncStates = await prisma.syncState.findMany();\n  const syncStateMap = new Map(syncStates.map(s =&gt; [s.entityType, s]));\n\n  // If ANY entity type has a completed sync, use incremental for all\n  const hasAnySync = syncStates.some(s =&gt; s.lastFullSync || s.lastIncrementalSync);\n\n  if (!hasAnySync) {\n    logger.info(\"No previous sync found for any entity, performing full sync\");\n    await stashSyncService.fullSync();\n    return;\n  }\n\n  // Smart incremental sync - checks each entity independently\n  logger.info(\"Performing smart incremental sync on startup\");\n  await stashSyncService.smartIncrementalSync();\n}\n\n// StashSyncService.ts\nasync smartIncrementalSync(stashInstanceId?: string): Promise&lt;SyncResult[]&gt; {\n  const results: SyncResult[] = [];\n\n  // Each entity type checks independently\n  for (const entityType of ['studio', 'tag', 'performer', 'group', 'gallery', 'scene', 'image']) {\n    const syncState = await this.getSyncState(stashInstanceId, entityType);\n    const lastSync = syncState?.lastFullSync || syncState?.lastIncrementalSync;\n\n    if (!lastSync) {\n      // Never synced this entity type - do full sync for just this type\n      logger.info(`No sync state for ${entityType}, performing full sync`);\n      const result = await this.syncEntityType(entityType, stashInstanceId, true);\n      results.push(result);\n    } else {\n      // Check if anything changed since last sync\n      const changeCount = await this.getChangeCount(entityType, lastSync);\n\n      if (changeCount === 0) {\n        logger.info(`${entityType}: No changes since ${lastSync.toISOString()}, skipping`);\n        results.push({\n          entityType,\n          synced: 0,\n          deleted: 0,\n          durationMs: 0,\n        });\n      } else {\n        logger.info(`${entityType}: ${changeCount} changes since ${lastSync.toISOString()}`);\n        const result = await this.syncEntityType(entityType, stashInstanceId, false, lastSync);\n        results.push(result);\n      }\n    }\n  }\n\n  return results;\n}\n\nprivate async getChangeCount(entityType: string, since: Date): Promise&lt;number&gt; {\n  const stash = stashInstanceManager.getDefault();\n  const filter = {\n    updated_at: { modifier: \"GREATER_THAN\", value: since.toISOString() }\n  };\n\n  switch (entityType) {\n    case 'scene':\n      const sceneResult = await stash.findScenesCompact({\n        filter: { page: 1, per_page: 0 }, // Only get count, no data\n        scene_filter: filter,\n      });\n      return sceneResult.findScenes.count;\n\n    case 'performer':\n      const performerResult = await stash.findPerformersCompact({\n        filter: { page: 1, per_page: 0 },\n        performer_filter: filter,\n      });\n      return performerResult.findPerformers.count;\n\n    // Similar for other entity types...\n  }\n}\n</code></pre>"},{"location":"design/json-blob-elimination-plan/#benefits","title":"Benefits","text":"<ol> <li>Restart resilience: If scene sync fails, other entities don't re-sync</li> <li>Fast startup: Entities with no changes skip API calls entirely</li> <li>Incremental always: Even \"full sync\" uses per-entity incremental when possible</li> <li>Progress visibility: Each entity type reports its own status</li> </ol>"},{"location":"design/json-blob-elimination-plan/#test-scenario","title":"Test Scenario","text":"<p>After implementing: 1. Run full sync to completion (or partial - doesn't matter) 2. Restart server 3. Expected: \"Studios: No changes since X, skipping\" for already-synced types 4. Only entities that never completed or have changes get synced</p>"},{"location":"design/json-blob-elimination-plan/#phase-3-query-layer-updates","title":"Phase 3: Query Layer Updates","text":""},{"location":"design/json-blob-elimination-plan/#cachedentityqueryservice-changes","title":"CachedEntityQueryService Changes","text":"<p>Replace JSON parsing with direct column access and URL transformation:</p> <pre><code>class CachedEntityQueryService {\n  private transformSceneUrls(scene: CachedScene): NormalizedScene {\n    const baseUrl = this.getStashProxyBaseUrl();\n\n    return {\n      id: scene.id,\n      title: scene.title,\n      code: scene.code,\n      date: scene.date,\n      details: scene.details,\n      rating100: scene.rating100,\n      organized: scene.organized,\n\n      // File metadata\n      files: scene.filePath ? [{\n        path: scene.filePath,\n        duration: scene.duration,\n        bit_rate: scene.fileBitRate,\n        frame_rate: scene.fileFrameRate,\n        width: scene.fileWidth,\n        height: scene.fileHeight,\n        video_codec: scene.fileVideoCodec,\n        audio_codec: scene.fileAudioCodec,\n        size: scene.fileSize,\n      }] : [],\n\n      // Transformed URLs\n      paths: {\n        screenshot: this.transformUrl(scene.pathScreenshot),\n        preview: this.transformUrl(scene.pathPreview),\n        sprite: this.transformUrl(scene.pathSprite),\n        vtt: this.transformUrl(scene.pathVtt),\n        chapters_vtt: this.transformUrl(scene.pathChaptersVtt),\n        stream: this.transformUrl(scene.pathStream),\n        caption: this.transformUrl(scene.pathCaption),\n      },\n\n      // Parse streams JSON (small, rarely changes)\n      sceneStreams: scene.streams\n        ? JSON.parse(scene.streams).map(s =&gt; ({\n            ...s,\n            url: this.transformUrl(s.url),\n          }))\n        : [],\n\n      // Nested entities loaded separately\n      studio: null,      // Loaded via JOIN or separate query\n      performers: [],    // Loaded via junction table\n      tags: [],          // Loaded via junction table\n      groups: [],        // Loaded via junction table\n      galleries: [],     // Loaded via junction table\n\n      // Timestamps\n      created_at: scene.stashCreatedAt?.toISOString(),\n      updated_at: scene.stashUpdatedAt?.toISOString(),\n    };\n  }\n\n  private transformUrl(path: string | null): string | null {\n    if (!path) return null;\n    // Replace Stash host with proxy prefix\n    return `/api/proxy/stash${path}`;\n  }\n}\n</code></pre>"},{"location":"design/json-blob-elimination-plan/#loading-nested-entities","title":"Loading Nested Entities","text":"<p>For detail views that need performers/tags, use efficient batch loading:</p> <pre><code>async getSceneWithRelations(id: string): Promise&lt;NormalizedScene | null&gt; {\n  const scene = await prisma.cachedScene.findFirst({\n    where: { id, deletedAt: null },\n    include: {\n      performers: {\n        include: { performer: true }\n      },\n      tags: {\n        include: { tag: true }\n      },\n      groups: {\n        include: { group: true }\n      },\n      galleries: {\n        include: { gallery: true }\n      },\n    },\n  });\n\n  if (!scene) return null;\n\n  const transformed = this.transformSceneUrls(scene);\n\n  // Add nested entities\n  transformed.performers = scene.performers.map(sp =&gt;\n    this.transformPerformerUrls(sp.performer)\n  );\n  transformed.tags = scene.tags.map(st =&gt;\n    this.transformTagUrls(st.tag)\n  );\n  transformed.groups = scene.groups.map(sg =&gt; ({\n    ...this.transformGroupUrls(sg.group),\n    scene_index: sg.sceneIndex,\n  }));\n  transformed.studio = scene.studioId\n    ? await this.getStudio(scene.studioId)\n    : null;\n\n  return transformed;\n}\n</code></pre>"},{"location":"design/json-blob-elimination-plan/#phase-4-migration-path","title":"Phase 4: Migration Path","text":""},{"location":"design/json-blob-elimination-plan/#step-1-add-new-columns-non-breaking","title":"Step 1: Add New Columns (Non-Breaking)","text":"<p>Add new columns to existing schema without removing <code>data</code> column yet.</p>"},{"location":"design/json-blob-elimination-plan/#step-2-dual-write-during-sync","title":"Step 2: Dual-Write During Sync","text":"<p>Update sync to write both JSON blob AND individual columns. This allows rollback.</p>"},{"location":"design/json-blob-elimination-plan/#step-3-update-query-service","title":"Step 3: Update Query Service","text":"<p>Switch CachedEntityQueryService to read from columns instead of JSON.</p>"},{"location":"design/json-blob-elimination-plan/#step-4-remove-json-blob","title":"Step 4: Remove JSON Blob","text":"<p>After validation, remove <code>data</code> column from schema.</p>"},{"location":"design/json-blob-elimination-plan/#step-5-optimize-sync","title":"Step 5: Optimize Sync","text":"<p>Remove JSON.stringify, implement batch operations.</p>"},{"location":"design/json-blob-elimination-plan/#testing-plan","title":"Testing Plan","text":"<ol> <li>Sync Performance Test: Time full sync with 22k scenes</li> <li> <p>Target: &lt; 10 minutes (vs current 3.6 hours)</p> </li> <li> <p>Query Performance Test: Measure browse page response time</p> </li> <li> <p>Target: &lt; 100ms for paginated results</p> </li> <li> <p>Memory Test: Monitor memory during sync</p> </li> <li> <p>Target: &lt; 500MB peak usage</p> </li> <li> <p>Data Integrity Test: Compare output before/after migration</p> </li> <li>All scenes should have same field values</li> </ol>"},{"location":"design/json-blob-elimination-plan/#rollback-plan","title":"Rollback Plan","text":"<p>If issues arise: 1. Re-enable JSON blob writing 2. Switch query service back to JSON parsing 3. Performance will degrade but functionality preserved</p>"},{"location":"design/json-blob-elimination-plan/#files-to-modify","title":"Files to Modify","text":""},{"location":"design/json-blob-elimination-plan/#schema","title":"Schema","text":"<ul> <li><code>server/prisma/schema.prisma</code> - Add new columns</li> </ul>"},{"location":"design/json-blob-elimination-plan/#sync-service","title":"Sync Service","text":"<ul> <li><code>server/services/StashSyncService.ts</code> - Batch operations, remove JSON</li> </ul>"},{"location":"design/json-blob-elimination-plan/#query-service","title":"Query Service","text":"<ul> <li><code>server/services/CachedEntityQueryService.ts</code> - Direct column access</li> </ul>"},{"location":"design/json-blob-elimination-plan/#transformation","title":"Transformation","text":"<ul> <li><code>server/utils/pathMapping.ts</code> - Move URL transformation to query time</li> </ul>"},{"location":"design/json-blob-elimination-plan/#types","title":"Types","text":"<ul> <li><code>server/types/index.ts</code> - Update NormalizedScene type if needed</li> </ul>"},{"location":"design/json-blob-elimination-plan/#summary","title":"Summary","text":"<p>Root Cause: JSON blob storage creates O(n) serialization overhead and prevents SQL query optimization.</p> <p>Solution: 1. Store all fields as individual columns 2. Transform URLs at read time (not sync time) 3. Use batch SQL operations for sync 4. Reduce DB operations from ~500/batch to ~9/batch</p> <p>Expected Result: Sync time reduced from 3.6 hours to ~5 minutes for 22k scenes.</p>"},{"location":"design/sqlite-cache-schema/","title":"SQLite Entity Cache Schema Design","text":"<p>Related: cache-scalability-brainstorm.md Date: 2025-12-08</p>"},{"location":"design/sqlite-cache-schema/#design-goals","title":"Design Goals","text":"<ol> <li>Scalability: Support 100k+ scenes without memory issues</li> <li>Query Performance: Fast filtering, sorting, pagination via SQL indexes</li> <li>Minimal Storage: Store only what Peek needs for filtering/display</li> <li>Relationships: Maintain scene\u2194performer, scene\u2194tag, etc. for filtering</li> <li>Sync Tracking: Track what's synced, detect deletions, enable incremental updates</li> </ol>"},{"location":"design/sqlite-cache-schema/#schema-design-decisions","title":"Schema Design Decisions","text":""},{"location":"design/sqlite-cache-schema/#decision-1-normalized-vs-denormalized","title":"Decision 1: Normalized vs Denormalized","text":"<p>Option A: Fully Normalized (separate tables with junction tables) <pre><code>CachedScene, CachedPerformer, ScenePerformer (junction), etc.\n</code></pre> - Pros: Clean relationships, no data duplication - Cons: Complex JOINs for every query, harder to paginate</p> <p>Option B: Denormalized with JSON (store relationships as JSON) <pre><code>CachedScene { performerIds: \"[1,2,3]\", tagIds: \"[4,5,6]\" }\n</code></pre> - Pros: Simple queries, fast reads - Cons: Can't filter by \"scenes with performer X\" efficiently</p> <p>Option C: Hybrid (normalized + JSON for full data) <pre><code>CachedScene { studioId, performerIds JSON, tagIds JSON, fullData JSON }\n+ Junction tables for efficient filtering\n</code></pre> - Pros: Best of both - efficient filtering AND full data access - Cons: More storage, need to keep junction tables in sync</p> <p>Decision: Option C (Hybrid) - We need both efficient filtering AND full entity data.</p>"},{"location":"design/sqlite-cache-schema/#decision-2-what-to-index","title":"Decision 2: What to Index","text":"<p>For scene filtering, we need to support: - Filter by studio, performers, tags, groups - Sort by date, rating, title, created_at, play_count, random - Text search on title - Date range queries</p> <p>Indexes needed: - <code>studioId</code> - Filter by studio - <code>date</code> - Sort/filter by scene date - <code>createdAt</code> - Sort by when added to Stash - <code>rating100</code> - Sort by rating - <code>title</code> - Text search (use SQLite FTS5 for full-text search) - Junction table indexes for performer/tag/group filtering</p>"},{"location":"design/sqlite-cache-schema/#decision-3-soft-delete-strategy","title":"Decision 3: Soft Delete Strategy","text":"<p>When an entity is deleted from Stash: 1. Mark <code>deletedAt</code> timestamp in Peek 2. Don't show in browse results 3. Keep for 30 days (allows Peek data recovery if re-added) 4. Periodic cleanup job removes old deleted entities</p>"},{"location":"design/sqlite-cache-schema/#proposed-schema","title":"Proposed Schema","text":""},{"location":"design/sqlite-cache-schema/#core-entity-tables","title":"Core Entity Tables","text":"<pre><code>// Cached scene from Stash\n// Contains indexed fields for filtering + JSON blob for full data\nmodel CachedScene {\n  id            String    @id                    // Stash scene ID\n  stashInstanceId String?                        // Which Stash server (for multi-instance)\n\n  // === Indexed fields for filtering/sorting ===\n  title         String?\n  date          String?                          // YYYY-MM-DD format\n  studioId      String?\n  rating100     Int?\n  duration      Int?                             // seconds\n  organized     Boolean   @default(false)\n  oCounter      Int       @default(0)\n  playCount     Int       @default(0)\n\n  // === Full entity data (JSON) ===\n  // Contains: performers, tags, files, paths, streams, etc.\n  // Transformed with proxy URLs at sync time\n  data          String                           // JSON blob\n\n  // === Sync metadata ===\n  stashCreatedAt  DateTime?                      // created_at from Stash\n  stashUpdatedAt  DateTime?                      // updated_at from Stash\n  syncedAt        DateTime  @default(now())      // When Peek last synced this entity\n  deletedAt       DateTime?                      // Soft delete timestamp\n\n  // Relationships (for efficient filtering)\n  performers    ScenePerformer[]\n  tags          SceneTag[]\n  groups        SceneGroup[]\n  galleries     SceneGallery[]\n\n  @@index([studioId])\n  @@index([date])\n  @@index([stashCreatedAt])\n  @@index([rating100])\n  @@index([duration])\n  @@index([deletedAt])\n  @@index([stashUpdatedAt])                      // For incremental sync\n}\n\nmodel CachedPerformer {\n  id            String    @id                    // Stash performer ID\n  stashInstanceId String?\n\n  // === Indexed fields ===\n  name          String\n  gender        String?\n  favorite      Boolean   @default(false)\n  rating100     Int?\n  sceneCount    Int       @default(0)\n  imageCount    Int       @default(0)\n  galleryCount  Int       @default(0)\n\n  // === Full entity data ===\n  data          String                           // JSON blob\n\n  // === Sync metadata ===\n  stashCreatedAt  DateTime?\n  stashUpdatedAt  DateTime?\n  syncedAt        DateTime  @default(now())\n  deletedAt       DateTime?\n\n  scenes        ScenePerformer[]\n\n  @@index([name])\n  @@index([gender])\n  @@index([favorite])\n  @@index([rating100])\n  @@index([sceneCount])\n  @@index([deletedAt])\n  @@index([stashUpdatedAt])\n}\n\nmodel CachedStudio {\n  id            String    @id                    // Stash studio ID\n  stashInstanceId String?\n\n  // === Indexed fields ===\n  name          String\n  parentId      String?                          // Parent studio ID\n  favorite      Boolean   @default(false)\n  rating100     Int?\n  sceneCount    Int       @default(0)\n  imageCount    Int       @default(0)\n  galleryCount  Int       @default(0)\n\n  // === Full entity data ===\n  data          String                           // JSON blob\n\n  // === Sync metadata ===\n  stashCreatedAt  DateTime?\n  stashUpdatedAt  DateTime?\n  syncedAt        DateTime  @default(now())\n  deletedAt       DateTime?\n\n  scenes        CachedScene[]                    // Direct relation (not junction)\n\n  @@index([name])\n  @@index([parentId])\n  @@index([favorite])\n  @@index([rating100])\n  @@index([sceneCount])\n  @@index([deletedAt])\n  @@index([stashUpdatedAt])\n}\n\nmodel CachedTag {\n  id            String    @id                    // Stash tag ID\n  stashInstanceId String?\n\n  // === Indexed fields ===\n  name          String\n  favorite      Boolean   @default(false)\n  sceneCount    Int       @default(0)\n\n  // === Full entity data ===\n  data          String                           // JSON blob\n\n  // === Sync metadata ===\n  stashCreatedAt  DateTime?\n  stashUpdatedAt  DateTime?\n  syncedAt        DateTime  @default(now())\n  deletedAt       DateTime?\n\n  scenes        SceneTag[]\n\n  @@index([name])\n  @@index([favorite])\n  @@index([sceneCount])\n  @@index([deletedAt])\n  @@index([stashUpdatedAt])\n}\n\nmodel CachedGroup {\n  id            String    @id                    // Stash group ID\n  stashInstanceId String?\n\n  // === Indexed fields ===\n  name          String\n  date          String?\n  studioId      String?\n  rating100     Int?\n  duration      Int?\n  sceneCount    Int       @default(0)\n\n  // === Full entity data ===\n  data          String                           // JSON blob\n\n  // === Sync metadata ===\n  stashCreatedAt  DateTime?\n  stashUpdatedAt  DateTime?\n  syncedAt        DateTime  @default(now())\n  deletedAt       DateTime?\n\n  scenes        SceneGroup[]\n\n  @@index([name])\n  @@index([date])\n  @@index([studioId])\n  @@index([rating100])\n  @@index([sceneCount])\n  @@index([deletedAt])\n  @@index([stashUpdatedAt])\n}\n\nmodel CachedGallery {\n  id            String    @id                    // Stash gallery ID\n  stashInstanceId String?\n\n  // === Indexed fields ===\n  title         String?\n  date          String?\n  studioId      String?\n  rating100     Int?\n  imageCount    Int       @default(0)\n\n  // === Full entity data ===\n  data          String                           // JSON blob\n\n  // === Sync metadata ===\n  stashCreatedAt  DateTime?\n  stashUpdatedAt  DateTime?\n  syncedAt        DateTime  @default(now())\n  deletedAt       DateTime?\n\n  scenes        SceneGallery[]\n\n  @@index([title])\n  @@index([date])\n  @@index([studioId])\n  @@index([rating100])\n  @@index([imageCount])\n  @@index([deletedAt])\n  @@index([stashUpdatedAt])\n}\n</code></pre>"},{"location":"design/sqlite-cache-schema/#junction-tables-for-efficient-many-to-many-filtering","title":"Junction Tables (for efficient many-to-many filtering)","text":"<pre><code>model ScenePerformer {\n  sceneId       String\n  performerId   String\n\n  scene         CachedScene     @relation(fields: [sceneId], references: [id], onDelete: Cascade)\n  performer     CachedPerformer @relation(fields: [performerId], references: [id], onDelete: Cascade)\n\n  @@id([sceneId, performerId])\n  @@index([performerId])                         // For \"scenes with performer X\" queries\n}\n\nmodel SceneTag {\n  sceneId       String\n  tagId         String\n\n  scene         CachedScene     @relation(fields: [sceneId], references: [id], onDelete: Cascade)\n  tag           CachedTag       @relation(fields: [tagId], references: [id], onDelete: Cascade)\n\n  @@id([sceneId, tagId])\n  @@index([tagId])                               // For \"scenes with tag X\" queries\n}\n\nmodel SceneGroup {\n  sceneId       String\n  groupId       String\n  sceneIndex    Int?                             // Position in group\n\n  scene         CachedScene     @relation(fields: [sceneId], references: [id], onDelete: Cascade)\n  group         CachedGroup     @relation(fields: [groupId], references: [id], onDelete: Cascade)\n\n  @@id([sceneId, groupId])\n  @@index([groupId])\n}\n\nmodel SceneGallery {\n  sceneId       String\n  galleryId     String\n\n  scene         CachedScene     @relation(fields: [sceneId], references: [id], onDelete: Cascade)\n  gallery       CachedGallery   @relation(fields: [galleryId], references: [id], onDelete: Cascade)\n\n  @@id([sceneId, galleryId])\n  @@index([galleryId])\n}\n</code></pre>"},{"location":"design/sqlite-cache-schema/#sync-metadata-table","title":"Sync Metadata Table","text":"<pre><code>// Tracks sync state per entity type\nmodel SyncState {\n  id              Int       @id @default(autoincrement())\n  stashInstanceId String?\n  entityType      String                         // 'scene', 'performer', etc.\n\n  lastFullSync    DateTime?                      // Last complete sync\n  lastIncrementalSync DateTime?                  // Last incremental sync\n  lastSyncCount   Int       @default(0)          // Entities synced in last run\n  lastSyncDuration Int?                          // Milliseconds\n  lastError       String?                        // Error message if last sync failed\n\n  @@unique([stashInstanceId, entityType])\n}\n</code></pre>"},{"location":"design/sqlite-cache-schema/#query-patterns","title":"Query Patterns","text":""},{"location":"design/sqlite-cache-schema/#pattern-1-paginated-scene-browse","title":"Pattern 1: Paginated Scene Browse","text":"<pre><code>-- Get page 2 of scenes (50 per page), sorted by date DESC\n-- With user restrictions applied (exclude hidden, apply tag restrictions)\n\nSELECT s.id, s.data\nFROM CachedScene s\nWHERE s.deletedAt IS NULL\n  AND s.id NOT IN (SELECT entityId FROM UserHiddenEntity WHERE userId = ? AND entityType = 'scene')\n  AND s.studioId NOT IN (SELECT entityId FROM UserHiddenEntity WHERE userId = ? AND entityType = 'studio')\n  -- User restriction: only scenes with tag \"Favorite\"\n  AND EXISTS (SELECT 1 FROM SceneTag st WHERE st.sceneId = s.id AND st.tagId IN (?))\nORDER BY s.date DESC\nLIMIT 50 OFFSET 50;\n</code></pre>"},{"location":"design/sqlite-cache-schema/#pattern-2-filter-by-performer","title":"Pattern 2: Filter by Performer","text":"<pre><code>-- Get all scenes featuring performer \"123\"\nSELECT s.id, s.data\nFROM CachedScene s\nINNER JOIN ScenePerformer sp ON sp.sceneId = s.id\nWHERE sp.performerId = '123'\n  AND s.deletedAt IS NULL\nORDER BY s.date DESC;\n</code></pre>"},{"location":"design/sqlite-cache-schema/#pattern-3-aggregation-top-performers-by-play-count","title":"Pattern 3: Aggregation (Top Performers by Play Count)","text":"<pre><code>-- Top 10 performers by user's play count\nSELECT p.id, p.name, SUM(ups.playCount) as totalPlays\nFROM CachedPerformer p\nINNER JOIN UserPerformerStats ups ON ups.performerId = p.id\nWHERE ups.userId = ?\n  AND p.deletedAt IS NULL\nGROUP BY p.id\nORDER BY totalPlays DESC\nLIMIT 10;\n</code></pre>"},{"location":"design/sqlite-cache-schema/#storage-estimates","title":"Storage Estimates","text":"Entity Count JSON Size Indexed Fields Total Scene 100,000 ~2KB ~200B ~220MB Performer 10,000 ~500B ~100B ~6MB Studio 1,000 ~300B ~50B ~350KB Tag 10,000 ~200B ~50B ~2.5MB Group 5,000 ~400B ~100B ~2.5MB Gallery 20,000 ~400B ~100B ~10MB Total ~240MB <p>Junction tables add ~10-20% overhead for relationships.</p> <p>Total estimated storage for 100k scene library: ~300MB</p>"},{"location":"design/sqlite-cache-schema/#migration-strategy","title":"Migration Strategy","text":""},{"location":"design/sqlite-cache-schema/#phase-1-add-schema-non-breaking","title":"Phase 1: Add Schema (Non-Breaking)","text":"<ol> <li>Add new Cached* tables via Prisma migration</li> <li>Keep existing StashCacheManager working</li> <li>Add new StashSyncService that populates SQLite</li> </ol>"},{"location":"design/sqlite-cache-schema/#phase-2-parallel-operation","title":"Phase 2: Parallel Operation","text":"<ol> <li>Both in-memory cache and SQLite populated</li> <li>Add feature flag to switch query source</li> <li>Test performance and correctness</li> </ol>"},{"location":"design/sqlite-cache-schema/#phase-3-switch-to-sqlite","title":"Phase 3: Switch to SQLite","text":"<ol> <li>Update all 18+ dependent files to use SQLite queries</li> <li>Remove in-memory cache</li> <li>Delete StashCacheManager</li> </ol>"},{"location":"design/sqlite-cache-schema/#phase-4-cleanup","title":"Phase 4: Cleanup","text":"<ol> <li>Remove FilteredEntityCacheService (SQLite replaces it)</li> <li>Clean up old code paths</li> <li>Performance tuning</li> </ol>"},{"location":"design/sqlite-cache-schema/#resolved-questions","title":"Resolved Questions","text":"<ol> <li>Full-text search: \u2705 Use SQLite FTS5 for title/name search (see FTS5 section below)</li> <li>Performer tags: TBD - defer until needed</li> <li>Image caching: \u2705 Yes, cache Images as separate entity (see CachedImage below)</li> <li>Multi-instance: TBD - current design supports it via stashInstanceId</li> </ol>"},{"location":"design/sqlite-cache-schema/#fts5-full-text-search","title":"FTS5 Full-Text Search","text":"<p>SQLite FTS5 provides fast, sophisticated text search with: - Word stemming (searching \"running\" matches \"run\") - Relevance ranking - Prefix matching (\"test*\" matches \"testing\") - Boolean operators (AND, OR, NOT)</p>"},{"location":"design/sqlite-cache-schema/#fts5-virtual-tables","title":"FTS5 Virtual Tables","text":"<pre><code>-- Create FTS5 virtual table for scene search\nCREATE VIRTUAL TABLE scene_fts USING fts5(\n  id,\n  title,\n  details,\n  content='CachedScene',\n  content_rowid='rowid'\n);\n\n-- Create FTS5 virtual table for performer search\nCREATE VIRTUAL TABLE performer_fts USING fts5(\n  id,\n  name,\n  aliases,\n  content='CachedPerformer',\n  content_rowid='rowid'\n);\n\n-- Triggers to keep FTS index in sync\nCREATE TRIGGER scene_fts_insert AFTER INSERT ON CachedScene BEGIN\n  INSERT INTO scene_fts(rowid, id, title, details)\n  VALUES (new.rowid, new.id, new.title, json_extract(new.data, '$.details'));\nEND;\n\nCREATE TRIGGER scene_fts_delete AFTER DELETE ON CachedScene BEGIN\n  INSERT INTO scene_fts(scene_fts, rowid, id, title, details)\n  VALUES ('delete', old.rowid, old.id, old.title, json_extract(old.data, '$.details'));\nEND;\n\nCREATE TRIGGER scene_fts_update AFTER UPDATE ON CachedScene BEGIN\n  INSERT INTO scene_fts(scene_fts, rowid, id, title, details)\n  VALUES ('delete', old.rowid, old.id, old.title, json_extract(old.data, '$.details'));\n  INSERT INTO scene_fts(rowid, id, title, details)\n  VALUES (new.rowid, new.id, new.title, json_extract(new.data, '$.details'));\nEND;\n</code></pre>"},{"location":"design/sqlite-cache-schema/#fts5-query-example","title":"FTS5 Query Example","text":"<pre><code>-- Search for scenes matching \"blonde teacher\"\nSELECT s.id, s.data, rank\nFROM scene_fts\nINNER JOIN CachedScene s ON scene_fts.id = s.id\nWHERE scene_fts MATCH 'blonde teacher'\n  AND s.deletedAt IS NULL\nORDER BY rank\nLIMIT 50;\n</code></pre> <p>Note: Prisma doesn't support FTS5 virtual tables directly. We'll create these via raw SQL migrations.</p>"},{"location":"design/sqlite-cache-schema/#cachedimage-entity","title":"CachedImage Entity","text":"<pre><code>model CachedImage {\n  id            String    @id                    // Stash image ID\n  stashInstanceId String?\n\n  // === Indexed fields ===\n  title         String?\n  date          String?\n  studioId      String?\n  rating100     Int?\n  oCounter      Int       @default(0)\n  organized     Boolean   @default(false)\n\n  // File info (for display)\n  width         Int?\n  height        Int?\n  fileSize      Int?                             // bytes\n\n  // === Full entity data ===\n  data          String                           // JSON blob\n\n  // === Sync metadata ===\n  stashCreatedAt  DateTime?\n  stashUpdatedAt  DateTime?\n  syncedAt        DateTime  @default(now())\n  deletedAt       DateTime?\n\n  // Relationships\n  performers    ImagePerformer[]\n  tags          ImageTag[]\n  galleries     ImageGallery[]\n\n  @@index([studioId])\n  @@index([date])\n  @@index([rating100])\n  @@index([deletedAt])\n  @@index([stashUpdatedAt])\n}\n\nmodel ImagePerformer {\n  imageId       String\n  performerId   String\n\n  image         CachedImage     @relation(fields: [imageId], references: [id], onDelete: Cascade)\n  performer     CachedPerformer @relation(fields: [performerId], references: [id], onDelete: Cascade)\n\n  @@id([imageId, performerId])\n  @@index([performerId])\n}\n\nmodel ImageTag {\n  imageId       String\n  tagId         String\n\n  image         CachedImage     @relation(fields: [imageId], references: [id], onDelete: Cascade)\n  tag           CachedTag       @relation(fields: [tagId], references: [id], onDelete: Cascade)\n\n  @@id([imageId, tagId])\n  @@index([tagId])\n}\n\nmodel ImageGallery {\n  imageId       String\n  galleryId     String\n\n  image         CachedImage     @relation(fields: [imageId], references: [id], onDelete: Cascade)\n  gallery       CachedGallery   @relation(fields: [galleryId], references: [id], onDelete: Cascade)\n\n  @@id([imageId, galleryId])\n  @@index([galleryId])\n}\n</code></pre> <p>Note: CachedPerformer and CachedTag need updated to include the new Image relations.</p>"},{"location":"design/sqlite-cache-schema/#next-steps","title":"Next Steps","text":"<ol> <li>Review this schema with stakeholder</li> <li>Create Prisma migration</li> <li>Implement StashSyncService</li> <li>Create SQL query builders for each access pattern</li> <li>Update controllers one by one</li> </ol>"},{"location":"development/content-restrictions/","title":"Content Restrictions System","text":""},{"location":"development/content-restrictions/#overview","title":"Overview","text":"<p>The Content Restrictions system allows administrators to control what content each user can see in Peek. This is a critical privacy/safety feature that enables hiding sensitive content (e.g., scenes with certain tags, studios, or groups) on a per-user basis.</p> <p>Current Version: 1.5.3+ Status: Fixed - Critical cascading bugs resolved (January 2025)</p>"},{"location":"development/content-restrictions/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Architecture</li> <li>Database Schema</li> <li>How It Works</li> <li>Cascading Logic</li> <li>Empty Entity Filtering</li> <li>Caching Strategy</li> <li>API Endpoints</li> <li>Code Flow</li> <li>Known Issues &amp; Edge Cases</li> <li>Testing Strategy</li> </ol>"},{"location":"development/content-restrictions/#architecture","title":"Architecture","text":"<p>The system consists of several cooperating services:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                     User Request                            \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                         \u2502\n         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n         \u2502   Library Controller          \u2502\n         \u2502   (scenes, performers, etc.)  \u2502\n         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                         \u2502\n         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n         \u2502                                                     \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 StashCacheManager \u2502    \u2502 UserRestriction    \u2502    \u2502 FilteredEntity  \u2502\n\u2502                   \u2502\u2500\u2500\u2500\u2500\u25b6\u2502 Service            \u2502\u2500\u2500\u2500\u2500\u25b6\u2502 CacheService    \u2502\n\u2502 (Server-wide data)\u2502    \u2502 (Apply restrictions)\u2502    \u2502 (Per-user cache)\u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                    \u2502\n                         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                         \u2502 EmptyEntityFilter   \u2502\n                         \u2502 Service             \u2502\n                         \u2502 (Remove orphans)    \u2502\n                         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"development/content-restrictions/#key-services","title":"Key Services","text":"<ol> <li>StashCacheManager (<code>server/services/StashCacheManager.ts</code>)</li> <li>Manages server-wide cache of all Stash entities</li> <li>Refreshes hourly from Stash GraphQL API</li> <li> <p>Provides fast Map-based lookups</p> </li> <li> <p>UserRestrictionService (<code>server/services/UserRestrictionService.ts</code>)</p> </li> <li>Applies per-user INCLUDE/EXCLUDE rules</li> <li>Filters Scenes based on Groups, Tags, Studios, Galleries</li> <li> <p>Filters organizational entities (Groups, Tags, Studios, Galleries)</p> </li> <li> <p>EmptyEntityFilterService (<code>server/services/EmptyEntityFilterService.ts</code>)</p> </li> <li>Removes \"orphaned\" entities with no visible content</li> <li>Handles complex dependency chains (Tags \u2192 Studios \u2192 Scenes)</li> <li> <p>Prevents showing empty organizational entities</p> </li> <li> <p>FilteredEntityCacheService (<code>server/services/FilteredEntityCacheService.ts</code>)</p> </li> <li>In-memory per-user cache of filtered results</li> <li>Avoids re-computing expensive filters on every request</li> <li>Invalidates on Stash cache updates or user restriction changes</li> </ol>"},{"location":"development/content-restrictions/#database-schema","title":"Database Schema","text":""},{"location":"development/content-restrictions/#usercontentrestriction-table","title":"UserContentRestriction Table","text":"<pre><code>model UserContentRestriction {\n  id            Int      @id @default(autoincrement())\n  userId        Int\n  entityType    String   // 'groups' | 'tags' | 'studios' | 'galleries'\n  mode          String   // 'INCLUDE' | 'EXCLUDE'\n  entityIds     String   // JSON array of entity IDs (stringified)\n  restrictEmpty Boolean  @default(false)  // If true, restrict items with no entities of this type\n  createdAt     DateTime @default(now())\n  updatedAt     DateTime @updatedAt\n\n  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)\n\n  @@unique([userId, entityType])\n  @@index([userId])\n}\n</code></pre> <p>Important Notes: - One restriction per <code>(userId, entityType)</code> pair - <code>entityIds</code> is a JSON-stringified array of strings - <code>restrictEmpty</code> flag: if <code>true</code>, items with NO entities of this type are also excluded</p> <p>Example Records:</p> <pre><code>// User 5: Exclude Tag \"Extreme\" (ID: \"123\")\n{\n  \"userId\": 5,\n  \"entityType\": \"tags\",\n  \"mode\": \"EXCLUDE\",\n  \"entityIds\": \"[\\\"123\\\"]\",\n  \"restrictEmpty\": false\n}\n\n// User 6: INCLUDE only Studio \"Safe Studio\" (ID: \"456\")\n{\n  \"userId\": 6,\n  \"entityType\": \"studios\",\n  \"mode\": \"INCLUDE\",\n  \"entityIds\": \"[\\\"456\\\"]\",\n  \"restrictEmpty\": false\n}\n</code></pre>"},{"location":"development/content-restrictions/#how-it-works","title":"How It Works","text":""},{"location":"development/content-restrictions/#processing-order","title":"Processing Order","text":"<ol> <li>Apply INCLUDE filters (whitelist)</li> <li>If set, ONLY show entities matching ALL include filters</li> <li> <p>Acts as intersection across multiple entity types</p> </li> <li> <p>Apply EXCLUDE filters (blacklist)</p> </li> <li>Remove entities matching ANY exclude filter</li> <li> <p>Acts as difference/subtraction</p> </li> <li> <p>Apply restrictEmpty rules</p> </li> <li>Remove entities that have NO values for restricted entity type</li> </ol>"},{"location":"development/content-restrictions/#scene-filtering-example","title":"Scene Filtering Example","text":"<p>Scenario: User excludes Tag \"Extreme\" (ID: \"123\")</p> <pre><code>// UserContentRestriction record\n{\n  userId: 5,\n  entityType: \"tags\",\n  mode: \"EXCLUDE\",\n  entityIds: [\"123\"],\n  restrictEmpty: false\n}\n\n// Filtering logic\nscenes = scenes.filter(scene =&gt; {\n  const sceneTagIds = scene.tags.map(t =&gt; t.id); // [\"100\", \"123\", \"200\"]\n  const excludedIds = [\"123\"];\n  return !sceneTagIds.some(id =&gt; excludedIds.includes(id)); // FALSE - REMOVED\n});\n</code></pre> <p>Result: Any Scene with Tag \"123\" is hidden from User 5.</p>"},{"location":"development/content-restrictions/#include-vs-exclude-interaction","title":"Include vs Exclude Interaction","text":"<p>When a user has BOTH include and exclude restrictions:</p> <pre><code>// Step 1: Apply INCLUDE filters (intersection)\nfor (const includeRestriction of includeRestrictions) {\n  scenes = scenes.filter(scene =&gt; {\n    const sceneEntityIds = getSceneEntityIds(scene, includeRestriction.entityType);\n    const allowedIds = JSON.parse(includeRestriction.entityIds);\n    return sceneEntityIds.some(id =&gt; allowedIds.includes(id));\n  });\n}\n\n// Step 2: Apply EXCLUDE filters (difference)\nfor (const excludeRestriction of excludeRestrictions) {\n  scenes = scenes.filter(scene =&gt; {\n    const sceneEntityIds = getSceneEntityIds(scene, excludeRestriction.entityType);\n    const excludedIds = JSON.parse(excludeRestriction.entityIds);\n    return !sceneEntityIds.some(id =&gt; excludedIds.includes(id));\n  });\n}\n</code></pre> <p>Recommended Practice: Don't use INCLUDE mode (we warn users in GUI), as it's easy to accidentally hide everything.</p>"},{"location":"development/content-restrictions/#cascading-logic","title":"Cascading Logic","text":""},{"location":"development/content-restrictions/#current-implementation-direct-only","title":"Current Implementation (Direct Only)","text":"<p>What Works: - \u2705 Scene has excluded Tag \u2192 Scene hidden - \u2705 Scene belongs to excluded Studio \u2192 Scene hidden - \u2705 Scene in excluded Group \u2192 Scene hidden - \u2705 Gallery has excluded Tag \u2192 Gallery hidden</p> <p>What's Missing (Likely Bug Source): - \u274c Studio has excluded Tag \u2192 Studio NOT hidden (direct restriction only) - \u274c Studio has excluded Tag \u2192 Scenes from that Studio NOT hidden - \u274c Performer only in excluded Studio \u2192 Performer NOT hidden - \u274c Scene's Studio has excluded Tag \u2192 Scene NOT hidden</p>"},{"location":"development/content-restrictions/#expected-cascading-behavior","title":"Expected Cascading Behavior","text":"<p>According to user requirements, exclusions should cascade:</p> <pre><code>Tag \"Extreme\" (excluded)\n  \u2193 applied to Studio\nStudio \"Hardcore Productions\"\n  \u2193 produces\nScenes [Scene A, Scene B, Scene C]\n  \u2193 starring\nPerformers [Performer X, Performer Y]\n\nExpected Result:\n- Tag \"Extreme\" \u2192 Hidden\n- Studio \"Hardcore Productions\" \u2192 Hidden (has excluded tag)\n- Scene A, B, C \u2192 Hidden (belong to excluded studio)\n- Performer X, Y \u2192 Hidden (only appear in excluded scenes)\n</code></pre>"},{"location":"development/content-restrictions/#current-code-analysis","title":"Current Code Analysis","text":""},{"location":"development/content-restrictions/#scene-filtering-userrestrictionservicefilterscenesforuser","title":"Scene Filtering (<code>UserRestrictionService.filterScenesForUser</code>)","text":"<pre><code>private getSceneEntityIds(scene: NormalizedScene, entityType: string): string[] {\n  switch (entityType) {\n    case \"groups\":\n      return scene.groups?.map(g =&gt; String(g.id)) || [];\n    case \"tags\":\n      return scene.tags?.map(t =&gt; String(t.id)) || [];  // \u26a0\ufe0f ONLY scene.tags\n    case \"studios\":\n      return scene.studio ? [String(scene.studio.id)] : [];\n    case \"galleries\":\n      return scene.galleries?.map(g =&gt; String(g.id)) || [];\n    default:\n      return [];\n  }\n}\n</code></pre> <p>Bug #1: Scene tag filtering only checks <code>scene.tags</code>, NOT <code>scene.studio.tags</code> or <code>scene.performers[].tags</code></p> <p>Expected: <pre><code>case \"tags\":\n  const tagIds = new Set&lt;string&gt;();\n\n  // Direct scene tags\n  (scene.tags || []).forEach(t =&gt; tagIds.add(String(t.id)));\n\n  // Performer tags (cascading)\n  (scene.performers || []).forEach(p =&gt; {\n    (p.tags || []).forEach(t =&gt; tagIds.add(String(t.id)));\n  });\n\n  // Studio tags (cascading)\n  if (scene.studio?.tags) {\n    scene.studio.tags.forEach(t =&gt; tagIds.add(String(t.id)));\n  }\n\n  return Array.from(tagIds);\n</code></pre></p>"},{"location":"development/content-restrictions/#studioperformer-filtering","title":"Studio/Performer Filtering","text":"<pre><code>// Studios: Only checks if studio ID is in restricted list\nasync filterStudiosForUser(studios, userId) {\n  const studioRestriction = restrictions.find(r =&gt; r.entityType === \"studios\");\n  const restrictedIds = JSON.parse(studioRestriction.entityIds);\n\n  if (studioRestriction.mode === \"EXCLUDE\") {\n    return studios.filter(studio =&gt; !restrictedIds.includes(studio.id)); // \u26a0\ufe0f Direct only\n  }\n}\n</code></pre> <p>Bug #2: Studios are not checked for excluded Tags/Groups</p> <p>Expected: If Studio has an excluded Tag, the Studio itself should be hidden</p>"},{"location":"development/content-restrictions/#performers","title":"Performers","text":"<pre><code>async filterPerformersForUser(performers, _userId) {\n  // For now, return all performers\n  return performers;  // \u26a0\ufe0f NO FILTERING AT ALL\n}\n</code></pre> <p>Bug #3: Performers are NEVER filtered by user restrictions</p> <p>Expected: Performers should be filtered if they have excluded Tags</p>"},{"location":"development/content-restrictions/#empty-entity-filtering","title":"Empty Entity Filtering","text":"<p>After applying user restrictions, entities with no visible content are removed to prevent \"orphaned\" listings.</p>"},{"location":"development/content-restrictions/#filtering-order-dependencies","title":"Filtering Order (Dependencies)","text":"<pre><code>1. Galleries (no dependencies)\n   \u2514\u2500&gt; Keep if: image_count &gt; 0\n\n2. Groups (no dependencies, but tree traversal)\n   \u2514\u2500&gt; Keep if: scene_count &gt; 0 OR has child groups with content\n\n3. Studios (depends on: Groups, Galleries)\n   \u2514\u2500&gt; Keep if: scene_count &gt; 0 OR has visible groups OR has images OR has visible galleries\n\n4. Performers (depends on: Groups, Galleries)\n   \u2514\u2500&gt; Keep if: scene_count &gt; 0 OR image_count &gt; 0 OR in visible group OR has visible gallery\n\n5. Tags (depends on: ALL entities)\n   \u2514\u2500&gt; Keep if: attached to any visible entity OR has children with content\n</code></pre>"},{"location":"development/content-restrictions/#example-studio-empty-filtering","title":"Example: Studio Empty Filtering","text":"<pre><code>filterEmptyStudios(studios, visibleGroups, visibleGalleries) {\n  const visibleGroupIds = new Set(visibleGroups.map(g =&gt; g.id));\n  const visibleGalleryIds = new Set(visibleGalleries.map(g =&gt; g.id));\n\n  return studios.filter(studio =&gt; {\n    // Has scenes? Keep\n    if (studio.scene_count &amp;&amp; studio.scene_count &gt; 0) return true;\n\n    // Has images? Keep\n    if (studio.image_count &amp;&amp; studio.image_count &gt; 0) return true;\n\n    // Has visible groups? Keep\n    if (studio.groups?.some(g =&gt; visibleGroupIds.has(g.id))) return true;\n\n    // Has visible galleries? Keep\n    if (studio.galleries?.some(g =&gt; visibleGalleryIds.has(g.id))) return true;\n\n    // No content found\n    return false;\n  });\n}\n</code></pre> <p>Important: Empty entity filtering uses Stash's metadata counts (scene_count, image_count, etc.), which: - \u2705 Reflect Stash's view of the world - \u274c May NOT reflect user-restricted counts (if 100 scenes are all restricted, studio still shows scene_count=100)</p> <p>Potential Bug #4: Empty filtering may fail to remove entities because counts don't account for restrictions.</p> <p>Example: 1. Studio has 100 scenes 2. All 100 scenes have excluded Tag 3. Studio.scene_count = 100 (from Stash metadata) 4. Empty filter: <code>if (studio.scene_count &gt; 0)</code> \u2192 <code>true</code> \u2192 Studio NOT removed 5. User sees empty Studio in list</p>"},{"location":"development/content-restrictions/#caching-strategy","title":"Caching Strategy","text":""},{"location":"development/content-restrictions/#server-wide-cache-stashcachemanager","title":"Server-Wide Cache (StashCacheManager)","text":"<ul> <li>Scope: All entities for all users</li> <li>Storage: In-memory Map</li> <li>Refresh: Hourly + on-demand</li> <li>Invalidation: On cache refresh (version increment)</li> </ul>"},{"location":"development/content-restrictions/#per-user-filtered-cache-filteredentitycacheservice","title":"Per-User Filtered Cache (FilteredEntityCacheService)","text":"<ul> <li>Scope: Filtered entities per user</li> <li>Storage: In-memory Map with key <code>user:{userId}:{entityType}:v{cacheVersion}</code></li> <li>TTL: 1 hour</li> <li>Size Limit: 100MB total, 10MB per user</li> <li>Invalidation:</li> <li>User restrictions change \u2192 <code>invalidateUser(userId)</code></li> <li>Stash cache refresh \u2192 <code>invalidateAll()</code></li> </ul>"},{"location":"development/content-restrictions/#cache-flow","title":"Cache Flow","text":"<pre><code>Request: GET /api/library/scenes (User 5)\n  \u2193\n1. Get all scenes from StashCacheManager\n  \u2193\n2. Check FilteredEntityCacheService for user 5's filtered scenes\n  \u2193\n  \u251c\u2500 Cache HIT: Return cached filtered scenes\n  \u2502               \u2193\n  \u2502            4. Merge with fresh user data (ratings, watch history)\n  \u2502               \u2193\n  \u2502            5. Apply pagination, search, sort\n  \u2502\n  \u2514\u2500 Cache MISS:\n       \u2193\n     3a. Apply UserRestrictionService filters\n       \u2193\n     3b. Apply EmptyEntityFilterService\n       \u2193\n     3c. Store in FilteredEntityCacheService\n       \u2193\n     4. Merge with fresh user data...\n</code></pre> <p>Performance: - First request: ~500ms (compute filters) - Subsequent requests: ~50ms (cache hit) - Cache hit rate: 95%+</p>"},{"location":"development/content-restrictions/#api-endpoints","title":"API Endpoints","text":""},{"location":"development/content-restrictions/#admin-manage-user-restrictions","title":"Admin: Manage User Restrictions","text":""},{"location":"development/content-restrictions/#get-apiuseruseridrestrictions","title":"GET /api/user/:userId/restrictions","text":"<p>Auth: Admin only Response: <pre><code>{\n  \"restrictions\": [\n    {\n      \"id\": 1,\n      \"userId\": 5,\n      \"entityType\": \"tags\",\n      \"mode\": \"EXCLUDE\",\n      \"entityIds\": \"[\\\"123\\\",\\\"456\\\"]\",\n      \"restrictEmpty\": false\n    }\n  ]\n}\n</code></pre></p>"},{"location":"development/content-restrictions/#put-apiuseruseridrestrictions","title":"PUT /api/user/:userId/restrictions","text":"<p>Auth: Admin only Body: <pre><code>{\n  \"restrictions\": [\n    {\n      \"entityType\": \"tags\",\n      \"mode\": \"EXCLUDE\",\n      \"entityIds\": [\"123\", \"456\"],\n      \"restrictEmpty\": false\n    },\n    {\n      \"entityType\": \"studios\",\n      \"mode\": \"INCLUDE\",\n      \"entityIds\": [\"789\"],\n      \"restrictEmpty\": false\n    }\n  ]\n}\n</code></pre> Behavior: Replaces ALL existing restrictions for user</p>"},{"location":"development/content-restrictions/#delete-apiuseruseridrestrictions","title":"DELETE /api/user/:userId/restrictions","text":"<p>Auth: Admin only Response: <pre><code>{\n  \"success\": true,\n  \"message\": \"All content restrictions removed successfully\"\n}\n</code></pre></p>"},{"location":"development/content-restrictions/#client-library-queries","title":"Client: Library Queries","text":"<p>All library endpoints (<code>/api/library/scenes</code>, <code>/api/library/performers</code>, etc.) automatically apply: 1. User restrictions (if user is not ADMIN) 2. Empty entity filtering (if user is not ADMIN) 3. Caching (all users)</p> <p>Admins bypass restrictions and see all content.</p>"},{"location":"development/content-restrictions/#code-flow","title":"Code Flow","text":""},{"location":"development/content-restrictions/#scene-request-flow","title":"Scene Request Flow","text":"<pre><code>// server/controllers/library/scenes.ts\n\nexport const findScenes = async (req, res) =&gt; {\n  const userId = req.user.id;\n\n  // Step 1: Get ALL scenes from server-wide cache\n  let scenes = stashCacheManager.getAllScenes();\n\n  // Step 2: Determine if expensive filters needed\n  const requiresUserData = hasExpensiveFilters(filters);\n\n  if (requiresUserData) {\n    // OLD PATH: Merge user data for ALL scenes first (expensive)\n    scenes = await mergeScenesWithUserData(scenes, userId);\n    scenes = applyQuickSceneFilters(scenes, filters);\n    scenes = applyExpensiveSceneFilters(scenes, filters);\n\n    // Apply restrictions\n    if (req.user.role !== \"ADMIN\") {\n      scenes = await userRestrictionService.filterScenesForUser(scenes, userId);\n    }\n\n    scenes = sortScenes(scenes, sortField, sortDirection);\n    const paginatedScenes = scenes.slice(startIndex, endIndex);\n\n  } else {\n    // NEW OPTIMIZED PATH: Filter/sort first, merge user data only for paginated scenes\n    scenes = applyQuickSceneFilters(scenes, filters);\n\n    // Apply restrictions\n    if (req.user.role !== \"ADMIN\") {\n      scenes = await userRestrictionService.filterScenesForUser(scenes, userId);\n    }\n\n    scenes = sortScenes(scenes, sortField, sortDirection);\n    const paginatedScenes = scenes.slice(startIndex, endIndex);\n\n    // Merge user data ONLY for paginated scenes (huge performance win)\n    const scenesWithUserData = await mergeScenesWithUserData(paginatedScenes, userId);\n  }\n\n  return res.json({ scenes: scenesWithUserData });\n};\n</code></pre>"},{"location":"development/content-restrictions/#performer-request-flow","title":"Performer Request Flow","text":"<pre><code>// server/controllers/library/performers.ts\n\nexport const findPerformers = async (req, res) =&gt; {\n  const userId = req.user.id;\n  const cacheVersion = stashCacheManager.getCacheVersion();\n\n  // Step 1: Try cached filtered performers\n  let performers = filteredEntityCacheService.get(userId, \"performers\", cacheVersion);\n\n  if (performers === null) {\n    // Cache MISS: Compute filtered performers\n    performers = stashCacheManager.getAllPerformers();\n\n    // Apply user restrictions (non-admins only)\n    if (req.user.role !== \"ADMIN\") {\n      performers = await userRestrictionService.filterPerformersForUser(performers, userId);\n    }\n\n    // Filter empty performers (non-admins only)\n    if (req.user.role !== \"ADMIN\") {\n      // Get visible groups/galleries first\n      let allGalleries = stashCacheManager.getAllGalleries();\n      let allGroups = stashCacheManager.getAllGroups();\n\n      allGalleries = await userRestrictionService.filterGalleriesForUser(allGalleries, userId);\n      allGroups = await userRestrictionService.filterGroupsForUser(allGroups, userId);\n\n      const visibleGalleries = emptyEntityFilterService.filterEmptyGalleries(allGalleries);\n      const visibleGroups = emptyEntityFilterService.filterEmptyGroups(allGroups);\n\n      performers = emptyEntityFilterService.filterEmptyPerformers(\n        performers,\n        visibleGroups,\n        visibleGalleries\n      );\n    }\n\n    // Store in cache\n    filteredEntityCacheService.set(userId, \"performers\", performers, cacheVersion);\n  }\n\n  // Step 2: Merge with FRESH user data (ratings, stats)\n  performers = await mergePerformersWithUserData(performers, userId);\n\n  // Step 3: Apply filters, search, sort, paginate\n  // ...\n\n  return res.json({ performers });\n};\n</code></pre>"},{"location":"development/content-restrictions/#known-issues-edge-cases","title":"Known Issues &amp; Edge Cases","text":""},{"location":"development/content-restrictions/#fixed-bugs-january-2025","title":"Fixed Bugs (January 2025)","text":""},{"location":"development/content-restrictions/#1-fixed-empty-filtering-uses-stash-counts-not-restriction-aware","title":"1. \u2705 FIXED: Empty Filtering Uses Stash Counts (Not Restriction-Aware)","text":"<p>Original Issue: <code>scene_count</code>, <code>image_count</code> from Stash included ALL content, not user-visible content</p> <p>Example of Bug: - Studio has 100 scenes (all have excluded tag) - <code>studio.scene_count = 100</code> (from Stash) - Empty filter: <code>if (studio.scene_count &gt; 0)</code> \u2192 keeps Studio - User sees Studio with 0 visible scenes</p> <p>Root Cause: <code>EmptyEntityFilterService</code> methods (<code>filterEmptyTags</code>, <code>filterEmptyStudios</code>, <code>filterEmptyPerformers</code>) relied on Stash's metadata counts which don't account for user restrictions.</p> <p>Fix Applied: <pre><code>// BEFORE (broken)\nfilterEmptyStudios(studios, visibleGroups, visibleGalleries) {\n  return studios.filter(studio =&gt; {\n    if (studio.scene_count &amp;&amp; studio.scene_count &gt; 0) return true; // \u274c Wrong count\n    // ...\n  });\n}\n\n// AFTER (fixed)\nfilterEmptyStudios(studios, visibleGroups, visibleGalleries, visibleScenes?) {\n  // Build set of studios in visible scenes\n  const studiosInVisibleScenes = new Set&lt;string&gt;();\n  if (visibleScenes) {\n    for (const scene of visibleScenes) {\n      if (scene.studio) {\n        studiosInVisibleScenes.add(scene.studio.id);\n      }\n    }\n  }\n\n  return studios.filter(studio =&gt; {\n    // Check if studio appears in visible scenes\n    if (visibleScenes &amp;&amp; studiosInVisibleScenes.has(studio.id)) {\n      return true;\n    }\n    // Fallback to old logic if visibleScenes not provided (backward compatibility)\n    if (!visibleScenes &amp;&amp; studio.scene_count &amp;&amp; studio.scene_count &gt; 0) {\n      return true;\n    }\n    // ...\n  });\n}\n</code></pre></p> <p>Changes Made: 1. Added optional <code>visibleScenes</code> parameter to <code>filterEmptyTags</code>, <code>filterEmptyStudios</code>, <code>filterEmptyPerformers</code> 2. Methods now build Sets of entity IDs that appear in visible scenes 3. Check actual visibility instead of relying on Stash counts 4. Backward compatible - falls back to old logic if <code>visibleScenes</code> not provided</p> <p>Controllers Updated: - <code>server/controllers/library/tags.ts</code> - Filters scenes first, passes to empty filter - <code>server/controllers/library/studios.ts</code> - Filters scenes first, passes to empty filter - <code>server/controllers/library/performers.ts</code> - Filters scenes first, passes to empty filter</p> <p>Test Coverage: 5/5 integration tests passing, including: - \u2705 Studio that ONLY has content in excluded Group is hidden - \u2705 Performer that ONLY appears in excluded Group is hidden - \u2705 Tag that ONLY appears in excluded Group is hidden - \u2705 Full cascading integration test passes</p> <p>Performance Impact: +50-100ms on cache miss (minimal), 0ms on cache hit (cached results unaffected)</p> <p>Impact: CRITICAL BUG FIXED - Could expose illegal content in user's country</p>"},{"location":"development/content-restrictions/#2-fixed-broken-tag-cascade-logic","title":"2. \u2705 FIXED: Broken Tag Cascade Logic","text":"<p>Original Issue: <code>filterTagsForUser()</code> tried to check <code>tag.groups</code> and <code>tag.galleries</code> arrays which don't exist</p> <p>Root Cause: Stash tags only have count fields (<code>group_count</code>, <code>gallery_count</code>), not arrays of groups/galleries</p> <p>Fix Applied: Removed broken cascade logic (lines 259-309 in <code>UserRestrictionService.ts</code>). The correct approach is now handled by <code>EmptyEntityFilterService.filterEmptyTags()</code> which checks if tags appear on visible scenes/performers/studios.</p> <p>Impact: MEDIUM - Prevented incorrect filtering logic</p>"},{"location":"development/content-restrictions/#3-fixed-no-cascading-tag-restrictions-on-scenes","title":"3. \u2705 FIXED: No Cascading Tag Restrictions on Scenes","text":"<p>Original Issue: If Studio has excluded Tag, Scenes from that Studio were NOT hidden</p> <p>Status: Already working correctly! The <code>getSceneEntityIds()</code> method in <code>UserRestrictionService</code> implements full cascading:</p> <pre><code>case \"tags\": {\n  const tagIds = new Set&lt;string&gt;();\n\n  // Direct scene tags\n  (scene.tags || []).forEach((t: EntityWithId) =&gt; {\n    tagIds.add(String(t.id));\n  });\n\n  // Studio tags (cascading)\n  if (scene.studio?.tags) {\n    (scene.studio.tags as EntityWithId[]).forEach((t: EntityWithId) =&gt; {\n      tagIds.add(String(t.id));\n    });\n  }\n\n  // Performer tags (cascading)\n  if (scene.performers) {\n    scene.performers.forEach((performer) =&gt; {\n      if ((performer as any).tags) {\n        ((performer as any).tags as EntityWithId[]).forEach((t: EntityWithId) =&gt; {\n          tagIds.add(String(t.id));\n        });\n      }\n    });\n  }\n\n  return Array.from(tagIds);\n}\n</code></pre> <p>Verified: Integration tests confirm this works correctly</p>"},{"location":"development/content-restrictions/#edge-cases","title":"Edge Cases","text":""},{"location":"development/content-restrictions/#1-include-exclude-conflict","title":"1. Include + Exclude Conflict","text":"<p>Scenario: User has INCLUDE Studio A, but EXCLUDE Tag X. Studio A produces Scene with Tag X.</p> <p>Current Behavior: Include runs first, then Exclude removes scene \u2192 Scene hidden</p> <p>Question: Is this expected? Or should Include take precedence?</p>"},{"location":"development/content-restrictions/#2-restrictempty-flag","title":"2. restrictEmpty Flag","text":"<p>Current Use: Rarely used, purpose unclear</p> <p>Behavior: If <code>true</code>, items with NO entities of this type are also excluded</p> <p>Example: <pre><code>{\n  \"entityType\": \"tags\",\n  \"mode\": \"EXCLUDE\",\n  \"entityIds\": [\"123\"],\n  \"restrictEmpty\": true\n}\n</code></pre> Result: Exclude scenes with Tag \"123\" AND scenes with NO tags at all</p> <p>Question: Is this feature needed? If not, should be removed to reduce complexity.</p>"},{"location":"development/content-restrictions/#3-circular-group-hierarchies","title":"3. Circular Group Hierarchies","text":"<p>Scenario: Group A is child of Group B, Group B is child of Group A</p> <p>Current Behavior: <code>checkHasContent()</code> uses <code>visited</code> Set to prevent infinite loops</p> <p>Status: HANDLED \u2705</p>"},{"location":"development/content-restrictions/#4-tag-dag-complexity","title":"4. Tag DAG Complexity","text":"<p>Scenario: Tags form directed acyclic graph with multiple parents</p> <p>Current Behavior: Tag kept if ANY child has content (OR logic)</p> <p>Question: Is this correct? Or should ALL parents be required (AND logic)?</p>"},{"location":"development/content-restrictions/#testing-strategy","title":"Testing Strategy","text":""},{"location":"development/content-restrictions/#unit-tests-needed","title":"Unit Tests Needed","text":""},{"location":"development/content-restrictions/#1-userrestrictionservice","title":"1. UserRestrictionService","text":"<pre><code>describe('UserRestrictionService', () =&gt; {\n  describe('filterScenesForUser', () =&gt; {\n    it('should exclude scenes with excluded tags', () =&gt; {});\n    it('should exclude scenes from excluded studios', () =&gt; {});\n    it('should exclude scenes in excluded groups', () =&gt; {});\n    it('should cascade: exclude scenes if studio has excluded tag', () =&gt; {});\n    it('should cascade: exclude scenes if performer has excluded tag', () =&gt; {});\n    it('should apply INCLUDE filters first', () =&gt; {});\n    it('should apply EXCLUDE filters after INCLUDE', () =&gt; {});\n    it('should respect restrictEmpty flag', () =&gt; {});\n    it('should return all scenes for admin users', () =&gt; {});\n  });\n\n  describe('filterStudiosForUser', () =&gt; {\n    it('should exclude studios with excluded studio IDs', () =&gt; {});\n    it('should CASCADE: exclude studios with excluded tags', () =&gt; {});  // BUG\n    it('should CASCADE: exclude studios with excluded groups', () =&gt; {});  // BUG\n    it('should apply INCLUDE mode correctly', () =&gt; {});\n  });\n\n  describe('filterPerformersForUser', () =&gt; {\n    it('should exclude performers with excluded tags', () =&gt; {});  // BUG (currently returns all)\n    it('should apply INCLUDE mode correctly', () =&gt; {});\n  });\n\n  describe('filterTagsForUser', () =&gt; {\n    it('should exclude tags by ID', () =&gt; {});\n    it('should apply INCLUDE mode correctly', () =&gt; {});\n  });\n});\n</code></pre>"},{"location":"development/content-restrictions/#2-emptyentityfilterservice","title":"2. EmptyEntityFilterService","text":"<pre><code>describe('EmptyEntityFilterService', () =&gt; {\n  describe('filterEmptyGalleries', () =&gt; {\n    it('should remove galleries with no images', () =&gt; {});\n    it('should keep galleries with images', () =&gt; {});\n  });\n\n  describe('filterEmptyGroups', () =&gt; {\n    it('should remove groups with no scenes', () =&gt; {});\n    it('should keep groups with scenes', () =&gt; {});\n    it('should keep parent groups if child has scenes', () =&gt; {});\n    it('should handle circular group hierarchies', () =&gt; {});\n  });\n\n  describe('filterEmptyStudios', () =&gt; {\n    it('should remove studios with no scenes and no groups', () =&gt; {});\n    it('should keep studios with scenes', () =&gt; {});\n    it('should keep studios with visible groups', () =&gt; {});\n    it('should keep studios with visible galleries', () =&gt; {});\n    it('should use restriction-aware counts', () =&gt; {});  // BUG\n  });\n\n  describe('filterEmptyPerformers', () =&gt; {\n    it('should remove performers with no scenes and no images', () =&gt; {});\n    it('should keep performers with scenes', () =&gt; {});\n    it('should keep performers in visible groups', () =&gt; {});\n    it('should keep performers with visible galleries', () =&gt; {});\n  });\n\n  describe('filterEmptyTags', () =&gt; {\n    it('should remove tags not attached to any entities', () =&gt; {});\n    it('should keep tags with scenes', () =&gt; {});\n    it('should keep tags with images', () =&gt; {});\n    it('should keep parent tags if child has content', () =&gt; {});\n    it('should handle complex tag DAG', () =&gt; {});\n  });\n});\n</code></pre>"},{"location":"development/content-restrictions/#3-integration-tests","title":"3. Integration Tests","text":"<pre><code>describe('Content Restrictions Integration', () =&gt; {\n  it('should cascade: Tag \u2192 Studio \u2192 Scene \u2192 Performer', async () =&gt; {\n    // Setup:\n    // - Tag \"Extreme\" applied to Studio \"XYZ\"\n    // - Studio \"XYZ\" produces Scene A\n    // - Performer \"John\" only in Scene A\n    // - User excludes Tag \"Extreme\"\n\n    // Expected:\n    // - Tag \"Extreme\" hidden\n    // - Studio \"XYZ\" hidden\n    // - Scene A hidden\n    // - Performer \"John\" hidden (only in excluded scene)\n  });\n\n  it('should handle INCLUDE + EXCLUDE interaction', async () =&gt; {\n    // User INCLUDEs Studio A, EXCLUDEs Tag X\n    // Scene from Studio A has Tag X\n    // Expected: Scene hidden (exclude takes precedence after include)\n  });\n\n  it('should not filter admin users', async () =&gt; {});\n\n  it('should invalidate cache when restrictions change', async () =&gt; {});\n});\n</code></pre>"},{"location":"development/content-restrictions/#manual-test-scenarios","title":"Manual Test Scenarios","text":""},{"location":"development/content-restrictions/#scenario-1-basic-tag-exclusion","title":"Scenario 1: Basic Tag Exclusion","text":"<ol> <li>Admin creates restriction: User 5 excludes Tag \"Extreme\"</li> <li>Login as User 5</li> <li>Verify:</li> <li>\u274c Tag \"Extreme\" not in tag list</li> <li>\u274c Scenes with Tag \"Extreme\" not in scene list</li> <li>\u274c Studios that ONLY produce \"Extreme\" tagged content are hidden</li> <li>\u274c Performers that ONLY appear in \"Extreme\" scenes are hidden</li> </ol>"},{"location":"development/content-restrictions/#scenario-2-cascading-tag-exclusion","title":"Scenario 2: Cascading Tag Exclusion","text":"<ol> <li>Admin creates restriction: User 5 excludes Tag \"Extreme\"</li> <li>Tag \"Extreme\" is applied to Studio \"XYZ Productions\"</li> <li>Login as User 5</li> <li>Verify:</li> <li>\u274c Studio \"XYZ Productions\" is hidden</li> <li>\u274c ALL scenes from \"XYZ Productions\" are hidden</li> <li>\u274c Performers only in \"XYZ Productions\" scenes are hidden</li> </ol>"},{"location":"development/content-restrictions/#scenario-3-group-exclusion-with-cascading-fixed","title":"Scenario 3: Group Exclusion with Cascading \u2705 FIXED","text":"<ol> <li>Admin creates restriction: User 5 excludes Group \"Extreme Collection\"</li> <li>Studio \"ABC\" produces scenes in \"Extreme Collection\"</li> <li>Login as User 5</li> <li>Verify:</li> <li>\u2705 Group \"Extreme Collection\" not in group list</li> <li>\u2705 Scenes in \"Extreme Collection\" not in scene list</li> <li>\u2705 Studio \"ABC\" is hidden if ALL its scenes are in excluded group</li> </ol>"},{"location":"development/content-restrictions/#scenario-4-empty-studio-after-restriction-fixed","title":"Scenario 4: Empty Studio After Restriction \u2705 FIXED","text":"<ol> <li>Studio \"XYZ\" has 10 scenes</li> <li>ALL 10 scenes have Tag \"Extreme\"</li> <li>User 5 excludes Tag \"Extreme\"</li> <li>Verify:</li> <li>\u2705 Studio \"XYZ\" is NOT shown (all scenes hidden, studio is now \"empty\")</li> </ol>"},{"location":"development/content-restrictions/#summary","title":"Summary","text":""},{"location":"development/content-restrictions/#what-works-january-2025","title":"What Works (January 2025)","text":"<ul> <li>\u2705 Direct exclusions (Scene has Tag \u2192 Scene hidden)</li> <li>\u2705 INCLUDE/EXCLUDE modes</li> <li>\u2705 restrictEmpty flag</li> <li>\u2705 Caching for performance</li> <li>\u2705 FIXED: Empty entity filtering now checks actual visibility</li> <li>\u2705 FIXED: Tags, Studios, Performers that only exist in excluded content are hidden</li> <li>\u2705 Admin bypass</li> <li>\u2705 Tag cascading (Tag \u2192 Studio \u2192 Scene) - was already working</li> <li>\u2705 Tag cascading (Tag \u2192 Performer \u2192 Scene) - was already working</li> <li>\u2705 Group cascading (Group \u2192 Scene \u2192 Studio/Performer/Tag hidden if no other content)</li> </ul>"},{"location":"development/content-restrictions/#test-coverage","title":"Test Coverage","text":"<ul> <li>\u2705 315/315 tests passing</li> <li>\u2705 Comprehensive TDD integration tests in <code>server/services/__tests__/UserRestrictionService.integration.test.ts</code></li> <li>\u2705 Real-world \"Bestiality\" Group exclusion scenario tested</li> <li>\u2705 Full cascading verified:</li> <li>Scene filtering</li> <li>Studio filtering (studios with no visible scenes hidden)</li> <li>Performer filtering (performers with no visible scenes hidden)</li> <li>Tag filtering (tags with no visible content hidden)</li> </ul>"},{"location":"development/content-restrictions/#known-limitations","title":"Known Limitations","text":"<ul> <li>Performer direct restrictions not implemented (only cascade filtering works)</li> <li><code>restrictEmpty</code> flag edge cases not fully tested</li> </ul>"},{"location":"development/content-restrictions/#next-steps","title":"Next Steps","text":"<ol> <li>Monitor production for any edge cases</li> <li>Add more comprehensive unit tests for individual services</li> <li>Consider implementing direct performer restrictions if needed</li> <li>Document performance characteristics with large datasets</li> </ol> <p>Document Version: 2.0 Last Updated: 2025-01-20 Author: Claude Code</p>"},{"location":"development/regression-testing/","title":"Regression Testing Guide","text":"<p>This guide provides comprehensive regression testing procedures for Peek Stash Browser. Use this checklist before releasing new versions to ensure core functionality remains stable.</p> <p>Report Inaccuracies</p> <p>If you find any errors, outdated information, or inaccurate testing steps in this document, please report them via GitHub Issues with the label <code>documentation</code>. This helps keep the testing guide accurate and useful for everyone.</p>"},{"location":"development/regression-testing/#testing-environment-setup","title":"Testing Environment Setup","text":"<p>Before beginning regression testing:</p> <ol> <li>Test Data: Ensure your Stash library has:</li> <li>Multiple scenes with various file formats (MP4, MKV, etc.)</li> <li>Scenes with different durations (short &lt;5min, medium 5-30min, long &gt;30min)</li> <li>Multiple performers, studios, tags</li> <li>At least one gallery and one group/movie</li> <li>Network Conditions: Test on stable network connection</li> <li>Browsers: Test on at least two browsers (Chrome/Edge and Firefox recommended)</li> <li>Clean State: Clear browser cache and cookies before testing critical flows</li> </ol>"},{"location":"development/regression-testing/#test-execution-guidelines","title":"Test Execution Guidelines","text":"<ul> <li>Mark Pass/Fail: Check off tests as you complete them</li> <li>Document Failures: Note version, browser, and steps to reproduce any failures</li> <li>Severity Levels:</li> <li>Critical: Blocks core functionality (video playback, login, etc.)</li> <li>High: Major feature broken (search, playlists, filtering)</li> <li>Medium: Feature degraded but usable</li> <li>Low: Minor UI/UX issue</li> </ul>"},{"location":"development/regression-testing/#core-feature-tests","title":"Core Feature Tests","text":""},{"location":"development/regression-testing/#1-authentication-user-management","title":"1. Authentication &amp; User Management","text":""},{"location":"development/regression-testing/#11-first-time-setup","title":"1.1 First-Time Setup","text":"<p>Precondition: Fresh installation with no existing database</p> <ul> <li> Setup wizard appears on first access</li> <li> Can configure path mappings successfully</li> <li> Path mappings are validated (invalid paths show error)</li> <li> Default admin user is created</li> <li> After setup, redirects to login page</li> </ul>"},{"location":"development/regression-testing/#12-login-flow","title":"1.2 Login Flow","text":"<ul> <li> Can log in with valid credentials</li> <li> Invalid credentials show error message</li> <li> Session persists after page refresh</li> <li> JWT token expires after 24 hours (requires waiting or manual token expiry)</li> <li> Expired token redirects to login page</li> </ul>"},{"location":"development/regression-testing/#13-user-preferences","title":"1.3 User Preferences","text":"<p>Precondition: Logged in as any user</p> <ul> <li> Settings page loads without errors</li> <li> Can change default video quality (auto, 1080p, 720p, 480p, 360p)</li> <li> Can change playback mode (auto, direct, transcode)</li> <li> Can change theme (multiple built-in themes available)</li> <li> Can change preview quality (sprite, webp, mp4)</li> <li> Can change minimum play percent (0-100% slider)</li> <li> Preferences persist after logout/login</li> <li> Preferences apply immediately (theme change, etc.)</li> </ul>"},{"location":"development/regression-testing/#14-user-management-admin-only","title":"1.4 User Management (Admin Only)","text":"<p>Precondition: Logged in as admin user</p> <ul> <li> Can view list of all users</li> <li> Can create new user (Admin or User role)</li> <li> Can delete non-admin users</li> <li> Cannot delete own admin account</li> <li> Can change user passwords</li> <li> Can toggle user roles (Admin \u2194 User)</li> </ul>"},{"location":"development/regression-testing/#2-video-playback","title":"2. Video Playback","text":""},{"location":"development/regression-testing/#21-direct-playback-no-transcoding","title":"2.1 Direct Playback (No Transcoding)","text":"<p>Precondition: Select quality \"Direct\" in video player</p> <ul> <li> Video starts playing within 3 seconds</li> <li> Playback is smooth (no stuttering)</li> <li> Audio syncs with video</li> <li> Can pause and resume</li> <li> Can seek to different timestamps (beginning, middle, end)</li> <li> Volume control works</li> <li> Fullscreen toggle works</li> <li> Player shows correct duration</li> <li> Timeline/scrubber reflects current position</li> </ul>"},{"location":"development/regression-testing/#22-transcoded-playback-hls","title":"2.2 Transcoded Playback (HLS)","text":"<p>Precondition: Select quality \"720p\" or lower in video player</p> <ul> <li> HLS stream starts within 5 seconds</li> <li> Quality selector shows available qualities (360p, 480p, 720p, 1080p)</li> <li> Can switch between qualities mid-playback</li> <li> Playback resumes at same position after quality change</li> <li> Seeking works correctly (forward and backward)</li> <li> Far seeks (&gt;2 minutes ahead) restart transcoding session properly</li> <li> Segments load progressively (check Network tab)</li> <li> No missing segments or 404 errors</li> <li> Transcoding session cleans up after 90 seconds of inactivity</li> </ul> <p>Test Scenarios:</p> <ul> <li> Short video (&lt;5min): Plays from start to finish without errors</li> <li> Long video (&gt;30min): Can seek to middle and end without issues</li> <li> Multiple quality switches: Switch between 360p \u2192 720p \u2192 480p during playback</li> <li> Rapid seeking: Seek multiple times in quick succession (shouldn't crash)</li> </ul>"},{"location":"development/regression-testing/#23-resume-playback","title":"2.3 Resume Playback","text":"<p>Precondition: Previously watched a scene partially (not to completion)</p> <ul> <li> Scene shows resume position indicator (progress bar on thumbnail)</li> <li> Clicking scene shows \"Resume\" and \"Restart\" options</li> <li> \"Resume\" starts playback at last position (within 5 seconds accuracy)</li> <li> \"Restart\" starts playback at 0:00</li> <li> Resume position updates as video plays</li> <li> Watching to completion clears resume position</li> </ul>"},{"location":"development/regression-testing/#24-watch-history-tracking","title":"2.4 Watch History Tracking","text":"<ul> <li> Play count increments after watching</li> <li> Play duration accumulates correctly</li> <li> O-counter increments when marking scenes</li> <li> Last played timestamp updates</li> <li> Watch history appears in \"Recently Watched\" carousel (if implemented)</li> <li> Watch history persists across sessions</li> </ul>"},{"location":"development/regression-testing/#3-scene-search-filtering-and-sorting","title":"3. Scene Search, Filtering, and Sorting","text":""},{"location":"development/regression-testing/#31-search-functionality","title":"3.1 Search Functionality","text":"<p>Location: Scenes page, search bar at top</p> <ul> <li> Typing in search bar shows results in real-time</li> <li> Search matches scene titles</li> <li> Search matches performer names</li> <li> Search matches studio names</li> <li> Search matches tag names</li> <li> Empty search shows all scenes</li> <li> Search results update immediately (&lt;500ms)</li> <li> Clearing search resets to full library</li> </ul>"},{"location":"development/regression-testing/#32-filtering","title":"3.2 Filtering","text":"<p>Location: Scenes page, filter panel (sidebar or modal)</p>"},{"location":"development/regression-testing/#basic-filters","title":"Basic Filters","text":"<ul> <li> Filter by performer (single selection)</li> <li> Filter by multiple performers (AND logic)</li> <li> Filter by studio (single selection)</li> <li> Filter by tag (single selection)</li> <li> Filter by multiple tags (AND/OR logic based on settings)</li> <li> Filter by rating (min/max range)</li> <li> Filter by organized status (Yes/No/All)</li> <li> Filter by O-counter value (min/max range)</li> </ul>"},{"location":"development/regression-testing/#advanced-filters","title":"Advanced Filters","text":"<ul> <li> Filter by duration (min/max range in minutes)</li> <li> Filter by resolution (SD/HD/4K/etc.)</li> <li> Filter by interactive (Yes/No if applicable)</li> <li> Combining multiple filters applies AND logic correctly</li> <li> Clearing filters resets to full library</li> </ul>"},{"location":"development/regression-testing/#filter-presets","title":"Filter Presets","text":"<ul> <li> Can save current filter state as preset</li> <li> Can load saved filter preset</li> <li> Can delete saved filter preset</li> <li> Presets persist across sessions</li> <li> Default presets load on page visit (if configured)</li> </ul>"},{"location":"development/regression-testing/#hidden-items-filter","title":"Hidden Items Filter","text":"<ul> <li> Filter shows \"Show Hidden Items\" toggle</li> <li> Hidden scenes are excluded by default</li> <li> Toggling \"Show Hidden Items\" reveals hidden scenes</li> <li> Hidden scenes display with visual indicator (dimmed, badge, etc.)</li> </ul>"},{"location":"development/regression-testing/#33-sorting","title":"3.3 Sorting","text":"<p>Location: Scenes page, sort dropdown</p> <ul> <li> Sort by Date Added (newest first)</li> <li> Sort by Date Added (oldest first)</li> <li> Sort by Title (A-Z)</li> <li> Sort by Title (Z-A)</li> <li> Sort by Duration (longest first)</li> <li> Sort by Duration (shortest first)</li> <li> Sort by Rating (highest first)</li> <li> Sort by Rating (lowest first)</li> <li> Sort by Play Count (most played first)</li> <li> Sort by Random (different order on each load)</li> <li> Sort order persists when navigating away and back</li> <li> Sort works correctly with active filters</li> </ul>"},{"location":"development/regression-testing/#34-paginationinfinite-scroll","title":"3.4 Pagination/Infinite Scroll","text":"<p>Precondition: Library has &gt;40 scenes (default page size)</p> <ul> <li> Initial page loads first 40 scenes</li> <li> Scrolling to bottom loads next page automatically</li> <li> Loading indicator appears while fetching</li> <li> No duplicate scenes appear</li> <li> Can scroll through entire library without errors</li> <li> Scroll position maintained when navigating back from scene details</li> </ul>"},{"location":"development/regression-testing/#4-scene-grid-and-preview-playback","title":"4. Scene Grid and Preview Playback","text":""},{"location":"development/regression-testing/#41-scene-cards-display","title":"4.1 Scene Cards Display","text":"<ul> <li> Scene thumbnails load correctly</li> <li> Scene titles display correctly</li> <li> Scene metadata visible (duration, rating, date, etc.)</li> <li> Performer names display (truncated if too many)</li> <li> Studio name displays (if applicable)</li> <li> Watch history indicators show (resume bar, play count, O-counter)</li> <li> Cards have hover effects (preview, actions, etc.)</li> </ul>"},{"location":"development/regression-testing/#42-preview-playback-on-hover","title":"4.2 Preview Playback on Hover","text":"<p>Precondition: Preview feature enabled in settings</p> <ul> <li> Hovering over scene card for 2 seconds starts preview</li> <li> Preview plays short clip from scene</li> <li> Preview has no audio (or low volume)</li> <li> Preview loops continuously while hovering</li> <li> Moving mouse away stops preview immediately</li> <li> Preview quality matches user preference (Low/Medium/High)</li> <li> Preview doesn't interfere with clicking/navigation</li> <li> Multiple rapid hovers don't cause errors</li> </ul>"},{"location":"development/regression-testing/#43-scene-card-actions","title":"4.3 Scene Card Actions","text":"<p>Location: Hover over scene card or three-dot menu</p> <ul> <li> Can play scene directly (navigates to player page)</li> <li> Can add scene to playlist (opens playlist selector)</li> <li> Can mark scene as watched</li> <li> Can mark O-counter increment</li> <li> Can rate scene (opens rating modal or inline rating)</li> <li> Can hide scene (requires confirmation, scene disappears)</li> <li> Can view scene details (navigates to details page)</li> <li> Can download original file (triggers download)</li> </ul>"},{"location":"development/regression-testing/#5-playlists","title":"5. Playlists","text":""},{"location":"development/regression-testing/#51-playlist-creation","title":"5.1 Playlist Creation","text":"<p>Location: Playlists page or scene card menu</p> <ul> <li> Can create new playlist with name</li> <li> Can create new playlist with description (optional)</li> <li> Empty playlists are allowed</li> <li> Duplicate playlist names are allowed (or prevented based on requirements)</li> <li> New playlist appears in playlists list immediately</li> </ul>"},{"location":"development/regression-testing/#52-addingremoving-scenes","title":"5.2 Adding/Removing Scenes","text":"<ul> <li> Can add scene to playlist from scene card menu</li> <li> Can add multiple scenes to playlist in batch</li> <li> Can remove scene from playlist (via playlist view)</li> <li> Can reorder scenes in playlist (drag-and-drop or up/down buttons)</li> <li> Playlist item count updates immediately</li> <li> Playlist thumbnail updates to first scene</li> </ul>"},{"location":"development/regression-testing/#53-playlist-playback","title":"5.3 Playlist Playback","text":"<p>Precondition: Playlist has at least 3 scenes</p> <ul> <li> Clicking playlist plays first scene</li> <li> Auto-advances to next scene after current finishes</li> <li> \"Previous\" button goes to previous scene</li> <li> \"Next\" button goes to next scene</li> <li> Playlist progress indicator shows (e.g., \"2 of 5\")</li> <li> Can exit playlist playback and return later (resumes at last scene)</li> <li> Shuffle mode randomizes playback order</li> <li> Repeat mode restarts playlist after last scene</li> <li> Shuffle + Repeat combination works correctly</li> </ul>"},{"location":"development/regression-testing/#54-playlist-management","title":"5.4 Playlist Management","text":"<ul> <li> Can rename playlist</li> <li> Can edit playlist description</li> <li> Can delete playlist (requires confirmation)</li> <li> Deleting playlist doesn't delete scenes</li> <li> Can duplicate playlist</li> <li> Can export playlist as M3U (downloads file with relative paths)</li> <li> Can clear all scenes from playlist</li> </ul>"},{"location":"development/regression-testing/#6-performers-studios-tags-galleries-groups","title":"6. Performers, Studios, Tags, Galleries, Groups","text":""},{"location":"development/regression-testing/#61-performers-page","title":"6.1 Performers Page","text":"<ul> <li> Performers grid loads with thumbnails</li> <li> Can search performers by name</li> <li> Can filter performers by tag (if applicable)</li> <li> Can sort performers (name, scene count, etc.)</li> <li> Clicking performer navigates to performer details</li> <li> Performer details show bio, image, scene count</li> <li> Performer details show list of scenes</li> <li> Can filter scenes on performer page (same filters as main scenes page)</li> <li> Can rate performer (if rating feature exists)</li> <li> Can mark performer as favorite</li> </ul>"},{"location":"development/regression-testing/#62-studios-page","title":"6.2 Studios Page","text":"<ul> <li> Studios grid loads with logos/thumbnails</li> <li> Can search studios by name</li> <li> Can sort studios (name, scene count, etc.)</li> <li> Clicking studio navigates to studio details</li> <li> Studio details show scene count and scene list</li> <li> Can filter scenes on studio page</li> <li> Can rate studio (if rating feature exists)</li> <li> Can mark studio as favorite</li> </ul>"},{"location":"development/regression-testing/#63-tags-page","title":"6.3 Tags Page","text":"<ul> <li> Tags list loads (grid or list view)</li> <li> Can search tags by name</li> <li> Can sort tags (name, scene count, etc.)</li> <li> Clicking tag navigates to tag details or filters scenes</li> <li> Tag details show scene count and scene list</li> <li> Can filter scenes by tag combinations (multiple tags)</li> <li> Can hide/show tag categories (if hierarchical)</li> </ul>"},{"location":"development/regression-testing/#64-galleries-page","title":"6.4 Galleries Page","text":"<ul> <li> Galleries grid loads with cover images</li> <li> Can search galleries by title</li> <li> Can filter galleries by performer/studio/tag</li> <li> Clicking gallery navigates to gallery viewer</li> <li> Gallery viewer shows all images in grid or slideshow</li> <li> Can navigate images with arrow keys or swipe</li> <li> Can zoom images</li> <li> Can download images</li> <li> Can rate gallery (if rating feature exists)</li> </ul>"},{"location":"development/regression-testing/#65-groupsmovies-page","title":"6.5 Groups/Movies Page","text":"<ul> <li> Groups grid loads with cover images</li> <li> Can search groups by name</li> <li> Can filter groups by studio/performer/tag</li> <li> Clicking group navigates to group details</li> <li> Group details show scene list in correct order</li> <li> Can play group as playlist (scenes in order)</li> <li> Can reorder scenes in group (if editing is allowed)</li> </ul>"},{"location":"development/regression-testing/#7-ratings-and-favorites","title":"7. Ratings and Favorites","text":""},{"location":"development/regression-testing/#71-rating-scenes","title":"7.1 Rating Scenes","text":"<ul> <li> Can rate scene from 0-100 (or 0-5 stars)</li> <li> Rating updates immediately on scene card</li> <li> Rating persists across sessions</li> <li> Can change rating multiple times</li> <li> Can clear rating (set to null/unrated)</li> <li> Average rating shown alongside user rating (if Stash has community ratings)</li> </ul>"},{"location":"development/regression-testing/#72-favorite-scenes","title":"7.2 Favorite Scenes","text":"<ul> <li> Can mark scene as favorite (heart icon)</li> <li> Favorite status toggles on/off</li> <li> Favorite indicator visible on scene card</li> <li> Can filter scenes to show only favorites</li> <li> Favorites persist across sessions</li> </ul>"},{"location":"development/regression-testing/#73-rating-other-entities","title":"7.3 Rating Other Entities","text":"<p>Test for Performers, Studios, Tags, Galleries, Groups:</p> <ul> <li> Can rate each entity type</li> <li> Can favorite each entity type</li> <li> Ratings and favorites persist</li> <li> Can filter by rating/favorite status</li> </ul>"},{"location":"development/regression-testing/#8-user-settings-and-preferences","title":"8. User Settings and Preferences","text":""},{"location":"development/regression-testing/#81-general-settings","title":"8.1 General Settings","text":"<p>Location: Settings page \u2192 General Settings section</p> <ul> <li> Can change default video quality (auto, 1080p, 720p, 480p, 360p)</li> <li> Can change playback mode (auto, direct, transcode)</li> <li> Can change theme (multiple built-in themes available)</li> <li> Can change preview quality (sprite, webp, mp4)</li> <li> Can toggle preview autoplay on hover (On/Off)</li> <li> Can change minimum play percent (0-100% slider)</li> <li> Can change default sort order for scenes</li> <li> Can change scenes per page (if configurable)</li> <li> Settings save immediately or on \"Save\" button click</li> <li> Settings apply immediately (no page refresh required for most)</li> </ul>"},{"location":"development/regression-testing/#82-carousel-preferences","title":"8.2 Carousel Preferences","text":"<p>Location: Settings page \u2192 Homepage Carousels section</p> <ul> <li> Can toggle hardcoded carousels on/off (Continue Watching, High Rated, etc.)</li> <li> Can reorder carousels with up/down buttons</li> <li> Changes reflect on home page after save</li> </ul>"},{"location":"development/regression-testing/#83-custom-carousels","title":"8.3 Custom Carousels","text":"<p>Location: Settings page \u2192 Homepage Carousels \u2192 Create Carousel</p> <ul> <li> Can create custom carousel with title and icon</li> <li> Can add filter rules (performers, tags, rating, etc.)</li> <li> Preview shows matching scenes before save</li> <li> Save is disabled until preview succeeds</li> <li> Can edit existing custom carousel</li> <li> Can delete custom carousel</li> <li> Custom carousel appears on homepage</li> <li> Maximum 15 custom carousels enforced</li> <li> Filter options are sorted alphabetically</li> <li> Scene titles use basename fallback when no title</li> </ul>"},{"location":"development/regression-testing/#84-navigation-preferences","title":"8.4 Navigation Preferences","text":"<p>Location: Settings page \u2192 Navigation Settings section</p> <ul> <li> Can toggle sidebar visibility (always visible, collapsible, hidden)</li> <li> Can toggle top bar elements (show/hide search, user menu, etc.)</li> <li> Can configure keyboard shortcuts (if customizable)</li> </ul>"},{"location":"development/regression-testing/#85-filter-presets","title":"8.5 Filter Presets","text":"<p>Location: Settings page \u2192 Filter Presets section</p> <ul> <li> Can view saved filter presets</li> <li> Can edit filter preset name/description</li> <li> Can delete filter preset</li> <li> Can set default filter preset (auto-loads on scenes page)</li> <li> Can export/import filter presets (JSON file)</li> </ul>"},{"location":"development/regression-testing/#86-hidden-items-user-feature","title":"8.6 Hidden Items (User Feature)","text":"<p>Location: Settings page \u2192 link to Hidden Items page</p> <ul> <li> Can hide individual scenes, performers, studios, tags, galleries, groups</li> <li> Hidden items link in Settings navigates to Hidden Items page</li> <li> Hidden Items page shows all hidden entities grouped by type</li> <li> Can unhide items from Hidden Items page</li> <li> \"Show Hidden Items\" toggle on filter panels reveals hidden content</li> <li> Hidden items persist across sessions</li> </ul>"},{"location":"development/regression-testing/#86-content-restrictions-admin-feature","title":"8.6 Content Restrictions (Admin Feature)","text":"<p>Location: User Management page \u2192 Content Restrictions modal (admin only)</p> <p>Note: This is an admin-only feature for managing per-user content restrictions, separate from user-level hidden items.</p> <ul> <li> Admin can access Content Restrictions modal from User Management</li> <li> Can set INCLUDE mode (user sees only specified groups/tags/studios/galleries)</li> <li> Can set EXCLUDE mode (user doesn't see specified groups/tags/studios/galleries)</li> <li> Can select multiple groups, tags, studios, galleries for restriction</li> <li> Restrictions apply only to the selected user</li> <li> Restrictions apply immediately across all pages for that user</li> <li> Restrictions persist across sessions</li> <li> Can clear all restrictions for a user</li> </ul>"},{"location":"development/regression-testing/#9-keyboard-navigation-and-shortcuts","title":"9. Keyboard Navigation and Shortcuts","text":""},{"location":"development/regression-testing/#91-global-shortcuts","title":"9.1 Global Shortcuts","text":"<p>Precondition: Focus on main application (not in text input)</p> <ul> <li> <code>Space</code> or <code>K</code> pauses/plays video (in player)</li> <li> <code>F</code> toggles fullscreen (in player)</li> <li> <code>M</code> toggles mute (in player)</li> <li> <code>Left/Right</code> arrow keys seek video (\u00b15 seconds)</li> <li> <code>Up/Down</code> arrow keys adjust volume (\u00b15%)</li> <li> <code>J/L</code> keys seek video (\u00b110 seconds)</li> <li> <code>Home/End</code> keys jump to start/end of video</li> <li> <code>Shift+&gt;/Shift+&lt;</code> adjust playback speed</li> <li> <code>Shift+N/Shift+P</code> next/previous scene in playlist</li> <li> Media hardware keys (Play/Pause, FastForward, Rewind, TrackNext, TrackPrevious)</li> <li> <code>0-9</code> seek to percentage (1 = 10%, 5 = 50%, etc.)</li> <li> <code>Esc</code> exits fullscreen or closes modals</li> <li> <code>/</code> focuses search bar</li> <li> <code>?</code> opens keyboard shortcuts help modal (if implemented)</li> </ul>"},{"location":"development/regression-testing/#92-scene-grid-navigation","title":"9.2 Scene Grid Navigation","text":"<p>Precondition: Focus on scenes grid (not in search/filter)</p> <ul> <li> Arrow keys navigate between scene cards</li> <li> <code>Enter</code> plays selected scene</li> <li> <code>A</code> adds selected scene to playlist</li> <li> <code>H</code> hides selected scene</li> <li> <code>R</code> opens rating modal for selected scene</li> <li> Tab/Shift+Tab navigates focusable elements</li> </ul>"},{"location":"development/regression-testing/#93-tv-mode-navigation","title":"9.3 TV Mode Navigation","text":"<p>Precondition: TV Mode enabled (if applicable)</p> <ul> <li> D-pad navigation works (arrow keys simulate remote)</li> <li> Enter/Select button activates items</li> <li> Back button exits player or modals</li> <li> Focus indicators are clearly visible</li> <li> No keyboard traps (can always navigate out)</li> </ul>"},{"location":"development/regression-testing/#10-server-settings-and-admin-features","title":"10. Server Settings and Admin Features","text":""},{"location":"development/regression-testing/#101-server-information","title":"10.1 Server Information","text":"<p>Precondition: Logged in as admin</p> <p>Location: Settings page \u2192 Server tab</p> <ul> <li> Server version displayed correctly (matches package.json)</li> <li> Stash server URL displayed</li> <li> Stash server version displayed (fetched from Stash API)</li> <li> Database location displayed</li> <li> Cache directory location displayed</li> <li> Uptime displayed (time since server start)</li> </ul>"},{"location":"development/regression-testing/#102-cache-management","title":"10.2 Cache Management","text":"<p>Location: Settings page \u2192 Server tab \u2192 Cache section</p> <ul> <li> Can view cache status (last refresh time, entity counts)</li> <li> Can manually refresh cache (button triggers refresh)</li> <li> Cache refresh shows progress indicator</li> <li> Cache refresh completes without errors</li> <li> Scene count updates after cache refresh</li> <li> New scenes from Stash appear after cache refresh</li> </ul>"},{"location":"development/regression-testing/#103-path-mappings","title":"10.3 Path Mappings","text":"<p>Location: Settings page \u2192 Server tab \u2192 Path Mappings section</p> <ul> <li> Can view existing path mappings (Stash path \u2192 Peek path)</li> <li> Can add new path mapping</li> <li> Can edit existing path mapping</li> <li> Can delete path mapping (requires confirmation)</li> <li> Invalid paths show validation error</li> <li> Path mappings apply immediately (no restart required)</li> <li> Test path translation feature works (if exists)</li> </ul>"},{"location":"development/regression-testing/#104-update-checker","title":"10.4 Update Checker","text":"<p>Location: Settings page \u2192 Server tab \u2192 Updates section</p> <ul> <li> Current version displayed</li> <li> \"Check for updates\" button queries GitHub API</li> <li> If update available, shows banner with version number and changelog link</li> <li> If no update, shows \"Up to date\" message</li> <li> Clicking changelog link opens GitHub release page in new tab</li> </ul>"},{"location":"development/regression-testing/#11-error-handling-and-edge-cases","title":"11. Error Handling and Edge Cases","text":""},{"location":"development/regression-testing/#111-network-errors","title":"11.1 Network Errors","text":"<p>Test Scenarios:</p> <ul> <li> Stash server offline: App shows error message, doesn't crash</li> <li> Stash server slow: Loading indicators appear, requests timeout gracefully</li> <li> Invalid Stash API key: Setup wizard or settings page shows authentication error</li> <li> Network interruption during playback: Video pauses, shows buffering indicator, resumes when network recovers</li> </ul>"},{"location":"development/regression-testing/#112-invalid-data-handling","title":"11.2 Invalid Data Handling","text":"<p>Test Scenarios:</p> <ul> <li> Scene with missing file: Shows error message instead of playing, doesn't crash app</li> <li> Scene with invalid path mapping: Shows error message, allows user to update path mappings</li> <li> Corrupted video file: FFmpeg fails gracefully, shows error message</li> <li> Scene with no duration: Displays \"Unknown duration\" or defaults to 0, doesn't crash</li> <li> Scene with no title: Displays filename or \"Untitled\" instead of crashing</li> </ul>"},{"location":"development/regression-testing/#113-permission-errors","title":"11.3 Permission Errors","text":"<p>Test Scenarios:</p> <ul> <li> Non-admin tries to access admin features: Redirected or shown \"Access Denied\" message</li> <li> Expired JWT token: Redirected to login page with message \"Session expired\"</li> <li> Invalid JWT token: Redirected to login page, doesn't crash</li> </ul>"},{"location":"development/regression-testing/#114-database-errors","title":"11.4 Database Errors","text":"<p>Test Scenarios (requires simulating DB issues):</p> <ul> <li> Database locked: Shows error message, retries operation</li> <li> Database migration fails: Server logs error, shows setup wizard or maintenance page</li> <li> Database corruption: Server detects and shows recovery instructions</li> </ul>"},{"location":"development/regression-testing/#115-browser-compatibility","title":"11.5 Browser Compatibility","text":"<p>Test on Multiple Browsers:</p> <ul> <li> Chrome/Edge: All features work</li> <li> Firefox: All features work</li> <li> Safari: All features work (if targeting macOS/iOS)</li> <li> Mobile browsers: Responsive layout, touch controls work</li> </ul>"},{"location":"development/regression-testing/#performance-testing","title":"Performance Testing","text":""},{"location":"development/regression-testing/#121-load-times","title":"12.1 Load Times","text":"<ul> <li> Initial page load: &lt;3 seconds on broadband connection</li> <li> Scene grid load: &lt;2 seconds for first 40 scenes</li> <li> Video player load: &lt;3 seconds to first frame (direct playback)</li> <li> HLS stream start: &lt;5 seconds to first frame (transcoded playback)</li> <li> Search/filter response: &lt;500ms for typical library (&lt;10,000 scenes)</li> </ul>"},{"location":"development/regression-testing/#122-resource-usage","title":"12.2 Resource Usage","text":"<p>Precondition: Monitor browser DevTools Performance tab</p> <ul> <li> Memory usage: No memory leaks during 30-minute session</li> <li> CPU usage: &lt;20% CPU during idle browsing (not playing video)</li> <li> Network usage: Only necessary requests (no redundant API calls)</li> </ul>"},{"location":"development/regression-testing/#123-concurrent-sessions","title":"12.3 Concurrent Sessions","text":"<p>Test Scenarios:</p> <ul> <li> Multiple browser tabs: Can play different videos in 2+ tabs simultaneously</li> <li> Multiple users: 2+ users can log in and use app concurrently without interference</li> <li> Transcoding sessions: Multiple concurrent HLS streams don't exhaust server resources</li> </ul>"},{"location":"development/regression-testing/#mobile-and-responsive-testing","title":"Mobile and Responsive Testing","text":""},{"location":"development/regression-testing/#131-mobile-layout","title":"13.1 Mobile Layout","text":"<p>Precondition: Test on mobile device or browser DevTools mobile emulation</p> <ul> <li> Scenes grid adapts to narrow viewport (1-2 columns)</li> <li> Navigation menu becomes hamburger or bottom nav</li> <li> Scene cards remain readable and tappable (no tiny text/buttons)</li> <li> Video player controls are touch-friendly (large buttons)</li> <li> Search bar and filters accessible on mobile</li> <li> Settings page scrollable and functional</li> </ul>"},{"location":"development/regression-testing/#132-touch-controls","title":"13.2 Touch Controls","text":"<ul> <li> Tap scene card to play</li> <li> Swipe to scroll scene grid</li> <li> Pinch to zoom images (in galleries)</li> <li> Tap player controls to pause/play/seek</li> <li> Double-tap player to toggle fullscreen</li> <li> Swipe to navigate between scenes in playlist (if applicable)</li> </ul>"},{"location":"development/regression-testing/#post-release-monitoring","title":"Post-Release Monitoring","text":"<p>After deploying a new version to production:</p> <ol> <li>Check server logs: Look for errors or warnings in first 24 hours</li> <li>Monitor user reports: Track GitHub issues for bug reports</li> <li>Check update notifications: Verify users see update banner if applicable</li> <li>Database migrations: Confirm migrations ran successfully on user instances</li> <li>Performance: Monitor server resource usage (CPU, memory, disk) for anomalies</li> </ol>"},{"location":"development/regression-testing/#test-report-template","title":"Test Report Template","text":"<p>After completing regression testing, document results:</p> <pre><code>**Peek Stash Browser - Regression Test Report**\n\n**Version Tested**: 1.X.X\n**Test Date**: YYYY-MM-DD\n**Tester**: [Your Name]\n**Environment**:\n- Docker Version: X.X.X\n- Browser(s): Chrome X.X, Firefox X.X\n- Stash Version: X.X.X\n- Test Library Size: X scenes, Y performers, Z studios\n\n**Test Results Summary**:\n- Total Tests: X\n- Passed: X\n- Failed: X\n- Skipped: X (with reason)\n\n**Critical Issues Found**:\n1. [Issue description, steps to reproduce, severity]\n2. ...\n\n**High Priority Issues Found**:\n1. [Issue description, steps to reproduce, severity]\n2. ...\n\n**Medium/Low Priority Issues**:\n- [Brief list]\n\n**Recommendation**: \u2705 Ready for release / \u26a0\ufe0f Release with known issues / \u274c Do not release\n\n**Additional Notes**:\n[Any observations, performance notes, or suggestions]\n</code></pre>"},{"location":"development/regression-testing/#automation-recommendations","title":"Automation Recommendations","text":"<p>For future improvements, consider automating these tests:</p> <ul> <li>Unit tests: Core utility functions (path mapping, filter logic, etc.)</li> <li>Integration tests: API endpoints with mock data</li> <li>End-to-end tests: Playwright or Cypress for critical user flows (login, playback, search)</li> <li>Visual regression tests: Screenshot comparison for UI changes</li> <li>Performance tests: Lighthouse CI for page load metrics</li> </ul>"},{"location":"development/regression-testing/#updating-this-document","title":"Updating This Document","text":"<p>As new features are added, update this regression testing guide:</p> <ol> <li>Add new test sections for new features (e.g., \"14. Social Features\")</li> <li>Update existing tests if feature behavior changes</li> <li>Archive obsolete tests (mark as \"Deprecated\" if removed)</li> <li>Keep test steps concise and actionable</li> <li>Include preconditions and expected results for clarity</li> </ol> <p>Last Updated: 2025-01-21 (Version 1.6.0)</p>"},{"location":"getting-started/configuration/","title":"Configuration","text":"<p>Peek Stash Browser is configured through environment variables and the setup wizard. This page documents all available configuration options.</p>"},{"location":"getting-started/configuration/#stash-connection-setup-wizard","title":"Stash Connection (Setup Wizard)","text":"<p>As of v2.0, Stash connection details are configured via the Setup Wizard and stored in the database:</p> <ul> <li>Stash URL: Your Stash GraphQL endpoint (e.g., <code>http://192.168.1.100:9999/graphql</code>)</li> <li>Stash API Key: API key from Stash Settings \u2192 Security</li> </ul> <p>The wizard runs automatically on first access. No environment variables needed for Stash connection!</p> <p>Upgrading from v1.x? Your existing <code>STASH_URL</code> and <code>STASH_API_KEY</code> environment variables will auto-migrate to the database on first start. You can remove them from your container configuration after successful migration.</p>"},{"location":"getting-started/configuration/#required-environment-variables","title":"Required Environment Variables","text":"Variable Description Example <code>JWT_SECRET</code> JWT signing key Generate with <code>openssl rand -base64 32</code>"},{"location":"getting-started/configuration/#generating-jwt-secret","title":"Generating JWT Secret","text":"<p>Linux/macOS/unRAID: <pre><code>openssl rand -base64 32\n</code></pre></p> <p>Windows PowerShell: <pre><code>$rng = [System.Security.Cryptography.RandomNumberGenerator]::Create()\n$bytes = New-Object byte[] 32\n$rng.GetBytes($bytes)\n[Convert]::ToBase64String($bytes)\n</code></pre></p>"},{"location":"getting-started/configuration/#optional-environment-variables","title":"Optional Environment Variables","text":"<p>These settings have sensible defaults but can be customized:</p> Variable Description Default Notes <code>DATABASE_URL</code> SQLite database file <code>file:/app/data/peek-stash-browser.db</code> Path inside container <code>CONFIG_DIR</code> App data directory <code>/app/data</code> Database + HLS cache <code>TMP_DIR</code> Transcoding temp directory <code>/app/tmp</code> Needs fast I/O <code>NODE_ENV</code> Environment mode <code>production</code> <code>development</code> or <code>production</code>"},{"location":"getting-started/configuration/#video-streaming-v20","title":"Video Streaming (v2.0+)","text":"<p>As of v2.0, Peek streams video directly through Stash - no local media access required!</p> <ul> <li>Videos are proxied through the Stash API</li> <li>No media volume mounts needed</li> <li>No path mapping configuration required</li> <li>Simpler container setup</li> </ul> <p>This is a significant simplification from v1.x which required mounting media directories and configuring path mappings.</p>"},{"location":"getting-started/configuration/#security-settings","title":"Security Settings","text":"Variable Description Default When to Use <code>SECURE_COOKIES</code> Enable secure cookie flag <code>false</code> Set to <code>true</code> when using HTTPS reverse proxy <p>Security Best Practices</p> <ul> <li>Set a strong <code>JWT_SECRET</code> during installation (required)</li> <li>Set <code>SECURE_COOKIES=true</code> when using HTTPS</li> <li>Don't expose Peek directly to the internet without a reverse proxy</li> <li>Admin credentials are created during setup wizard (no default passwords)</li> <li>Stash API key is stored securely in the database (not in environment variables)</li> </ul>"},{"location":"getting-started/configuration/#example-configurations","title":"Example Configurations","text":""},{"location":"getting-started/configuration/#minimal-production-configuration-v20","title":"Minimal Production Configuration (v2.0+)","text":"<pre><code># Required\nJWT_SECRET=your_very_long_random_secret_key_here\n\n# Stash connection configured via Setup Wizard (stored in database)\n# All other settings use defaults\n</code></pre>"},{"location":"getting-started/configuration/#complete-production-configuration","title":"Complete Production Configuration","text":"<pre><code># Authentication (Required)\nJWT_SECRET=your_very_long_random_secret_key_here\n\n# Database (Optional - defaults shown)\nDATABASE_URL=file:/app/data/peek-stash-browser.db\nCONFIG_DIR=/app/data\n\n# Security (Optional)\nSECURE_COOKIES=true\n\n# Environment (Optional)\nNODE_ENV=production\n\n# Stash connection configured via Setup Wizard (stored in database)\n</code></pre>"},{"location":"getting-started/configuration/#development-configuration","title":"Development Configuration","text":"<pre><code># Authentication\nJWT_SECRET=dev-secret-change-in-production\n\n# Database (local SQLite file)\nDATABASE_URL=file:./data/peek-db.db\n\n# Development\nNODE_ENV=development\n\n# Stash connection configured via Setup Wizard\n</code></pre>"},{"location":"getting-started/configuration/#docker-compose-example","title":"Docker Compose Example","text":"<pre><code>services:\n  peek:\n    image: carrotwaxr/peek-stash-browser:latest\n    container_name: peek-stash-browser\n    ports:\n      - \"6969:80\"\n    volumes:\n      - peek-data:/app/data\n    environment:\n      - JWT_SECRET=${JWT_SECRET}\n      # Optional\n      - NODE_ENV=production\n      - SECURE_COOKIES=false\n    restart: unless-stopped\n\nvolumes:\n  peek-data:\n</code></pre> <p>Stash Connection</p> <p>Stash URL and API key are configured via the Setup Wizard on first access and stored in the database.</p>"},{"location":"getting-started/configuration/#troubleshooting-configuration-issues","title":"Troubleshooting Configuration Issues","text":""},{"location":"getting-started/configuration/#cannot-connect-to-stash","title":"Cannot Connect to Stash","text":"<p>Check:</p> <ul> <li>Stash URL is accessible from the Peek container</li> <li>Stash API key is correct and not expired</li> <li>Stash GraphQL API is enabled</li> </ul> <p>Test connectivity:</p> <pre><code>docker exec peek-stash-browser curl http://your-stash-ip:9999/graphql\n</code></pre> <p>You can update Stash connection details in Settings \u2192 Stash Configuration.</p>"},{"location":"getting-started/configuration/#videos-wont-play","title":"Videos Won't Play","text":"<p>Check:</p> <ul> <li>Stash connection is configured correctly (Settings \u2192 Stash Configuration)</li> <li>Stash server is running and accessible</li> <li>The scene exists in Stash and has a valid video file</li> </ul>"},{"location":"getting-started/configuration/#authentication-issues","title":"Authentication Issues","text":"<p>Check:</p> <ul> <li><code>JWT_SECRET</code> is set</li> <li><code>SECURE_COOKIES</code> matches your HTTP/HTTPS setup</li> <li>Database is writable</li> </ul>"},{"location":"getting-started/configuration/#next-steps","title":"Next Steps","text":"<ul> <li>Quick Start Guide</li> <li>Troubleshooting</li> </ul>"},{"location":"getting-started/installation/","title":"Installation","text":"<p>Peek Stash Browser can be deployed in several ways depending on your needs and environment.</p>"},{"location":"getting-started/installation/#prerequisites","title":"Prerequisites","text":"<p>Before installing Peek, ensure you have:</p> <ul> <li>Stash Server running with GraphQL API enabled</li> <li>Docker installed (Docker Compose only needed for development)</li> <li>Network access from container to Stash server</li> </ul>"},{"location":"getting-started/installation/#stash-configuration","title":"Stash Configuration","text":"<ol> <li>Enable API in Stash settings</li> <li>Generate API key in Settings \u2192 Security</li> <li>Note GraphQL endpoint (usually <code>http://stash-ip:9999/graphql</code>)</li> <li>Ensure network access from your Docker host to Stash</li> </ol> <p>Note: As of v2.0, Peek streams video directly through Stash - no media volume mounts required!</p>"},{"location":"getting-started/installation/#installation-methods","title":"Installation Methods","text":""},{"location":"getting-started/installation/#option-1-unraid","title":"Option 1: unRAID","text":""},{"location":"getting-started/installation/#community-applications-recommended","title":"Community Applications (Recommended)","text":"<p>Easiest Installation Method</p> <p>This is the recommended method for unRAID users - everything is pre-configured!</p> <ol> <li>Install from Community Applications:</li> <li>Search for \"Peek Stash Browser\" in unRAID's Community Applications</li> <li>Click install and configure your settings</li> <li>Access at <code>http://your-unraid-ip:6969</code></li> </ol>"},{"location":"getting-started/installation/#manual-template-installation","title":"Manual Template Installation","text":"<p>If Peek isn't available in Community Applications yet, or if you want to install the latest template manually:</p> <p>Step 1: Download the template file</p> <p>Get the template from GitHub:</p> <pre><code>https://raw.githubusercontent.com/carrotwaxr/peek-stash-browser/master/unraid-template.xml\n</code></pre> <p>Step 2: Install the template</p> <p>=== \"USB/Boot Share Exported (Easier)\" 1. Copy <code>unraid-template.xml</code> to your network share at: <code>\\\\your.server.ip.address\\flash\\config\\plugins\\dockerMan\\templates-user</code> 2. The template will be available immediately in Docker tab \u2192 Add Container \u2192 User Templates</p> <p>=== \"USB/Boot Share NOT Exported\" 1. Copy <code>unraid-template.xml</code> to any accessible share (e.g., <code>\\\\your.server.ip.address\\downloads</code>) 2. SSH into your unRAID server 3. Move the template file: <code>bash        cp /mnt/user/downloads/unraid-template.xml /boot/config/plugins/dockerMan/templates-user/</code> 4. The template will be available immediately in Docker tab \u2192 Add Container \u2192 User Templates</p> <p>No Restart Required</p> <p>You do NOT need to restart Docker or unRAID - the template is picked up automatically.</p> <p>Step 3: Configure the container</p> <ol> <li>Go to Docker tab \u2192 Add Container</li> <li>Select \"peek-stash-browser\" from User Templates dropdown</li> <li>Configure required settings:</li> <li>JWT Secret: Generate with <code>openssl rand -hex 32</code> in unRAID terminal</li> <li>App Data Directory: Path for Peek data (e.g., <code>/mnt/user/appdata/peek-stash-browser</code>)</li> <li>Click Apply</li> <li>Access at <code>http://your-unraid-ip:6969</code></li> <li>Complete the Setup Wizard to connect to your Stash server</li> </ol>"},{"location":"getting-started/installation/#option-2-docker-single-container","title":"Option 2: Docker (Single Container)","text":"<p>Recommended for Production</p> <p>Single container includes everything - frontend, backend, and database</p> <pre><code># Pull the latest image\ndocker pull carrotwaxr/peek-stash-browser:latest\n\n# Generate JWT secret\nexport JWT_SECRET=$(openssl rand -base64 32)\n\n# Run Peek\ndocker run -d \\\n  --name peek-stash-browser \\\n  -p 6969:80 \\\n  -v peek-data:/app/data \\\n  -e JWT_SECRET=\"${JWT_SECRET}\" \\\n  carrotwaxr/peek-stash-browser:latest\n</code></pre> <p>Volume Mounts:</p> <ul> <li><code>peek-data</code> - Database and app data (Docker named volume)</li> </ul> <p>Required Environment Variables:</p> <ul> <li><code>JWT_SECRET</code> - Secret for JWT authentication (recommended to set manually)</li> </ul> <p>Note: Stash URL and API key are configured via the Setup Wizard on first access - no environment variables needed!</p> <p>See Configuration Guide for all environment variables.</p>"},{"location":"getting-started/installation/#windows-examples","title":"Windows Examples","text":"<pre><code># Pull the latest image from Docker Hub\ndocker pull carrotwaxr/peek-stash-browser:latest\n\n# Generate JWT secret (one-time)\n$rng = [System.Security.Cryptography.RandomNumberGenerator]::Create()\n$bytes = New-Object byte[] 32\n$rng.GetBytes($bytes)\n$jwt = [Convert]::ToBase64String($bytes)\n\n# Run Peek\ndocker run -d `\n    --name peek-stash-browser `\n    -p 6969:80 `\n    -v peek-data:/app/data `\n    -e JWT_SECRET=$jwt `\n    carrotwaxr/peek-stash-browser:latest\n</code></pre> <p>Managing the container:</p> <pre><code># View logs\ndocker logs peek-stash-browser\n\n# Stop container\ndocker stop peek-stash-browser\n\n# Start container\ndocker start peek-stash-browser\n\n# Restart container\ndocker restart peek-stash-browser\n\n# Update to new version\ndocker stop peek-stash-browser\ndocker rm peek-stash-browser\ndocker pull carrotwaxr/peek-stash-browser:latest\n# Then re-run the docker run command above\n</code></pre> <p>Data persists across updates!</p> <p>Your database and configuration are saved in the <code>peek-data</code> volume and won't be lost when updating.</p>"},{"location":"getting-started/installation/#linuxmacos-examples","title":"Linux/macOS Examples","text":"<pre><code># Pull the latest image from Docker Hub\ndocker pull carrotwaxr/peek-stash-browser:latest\n\n# Generate a secure random JWT secret\nexport JWT_SECRET=$(openssl rand -base64 32)\n\n# Run Peek\ndocker run -d \\\n    --name peek-stash-browser \\\n    -p 6969:80 \\\n    -v peek-data:/app/data \\\n    -e JWT_SECRET=\"${JWT_SECRET}\" \\\n    carrotwaxr/peek-stash-browser:latest\n</code></pre> <p>Managing the container:</p> <pre><code># View logs\ndocker logs peek-stash-browser\n\n# Follow logs in real-time\ndocker logs -f peek-stash-browser\n\n# Stop container\ndocker stop peek-stash-browser\n\n# Start container\ndocker start peek-stash-browser\n\n# Restart container\ndocker restart peek-stash-browser\n\n# Update to new version\ndocker stop peek-stash-browser\ndocker rm peek-stash-browser\ndocker pull carrotwaxr/peek-stash-browser:latest\n# Then re-run the docker run command above\n</code></pre> <p>Data persists across updates!</p> <p>Your database and configuration are saved in the <code>peek-data</code> volume and won't be lost when updating.</p>"},{"location":"getting-started/installation/#option-3-docker-compose-development","title":"Option 3: Docker Compose (Development)","text":"<p>For Development Only</p> <p>This method is for development with hot reloading enabled</p> <ol> <li>Clone and setup:</li> </ol> <pre><code>git clone https://github.com/carrotwaxr/peek-stash-browser.git\ncd peek-stash-browser\ncp .env.example .env\n</code></pre> <ol> <li>Configure environment (edit <code>.env</code>):</li> </ol> <pre><code>JWT_SECRET=your-dev-secret-here\nDATABASE_URL=file:./data/peek-stash-browser.db\n</code></pre> <ol> <li>Start services:</li> </ol> <pre><code>docker-compose up -d\n</code></pre> <ol> <li>Access the app: Open <code>http://localhost:6969</code></li> </ol>"},{"location":"getting-started/installation/#first-access-setup-wizard","title":"First Access &amp; Setup Wizard","text":"<p>After installation, access Peek in your browser for the first-time setup:</p> <ol> <li>Navigate to <code>http://localhost:6969</code> (or your server IP)</li> <li>Complete the 4-step setup wizard:</li> <li>Welcome: Introduction to Peek</li> <li>Create Admin: Set your admin username and password</li> <li>Connect to Stash: Enter your Stash URL and API key</li> <li>Complete: Setup finished!</li> <li>Login with your newly created admin credentials</li> </ol>"},{"location":"getting-started/installation/#updating-peek","title":"Updating Peek","text":""},{"location":"getting-started/installation/#check-for-updates","title":"Check for Updates","text":"<p>Peek includes a built-in update checker:</p> <ol> <li>Navigate to Settings \u2192 Server Settings</li> <li>Scroll to the Version Information section</li> <li>Click Check for Updates</li> </ol> <p>The system will query GitHub for new releases and notify you if an update is available.</p>"},{"location":"getting-started/installation/#update-procedure","title":"Update Procedure","text":"<p>To update your Docker container to the latest version:</p> unRAIDLinux/macOSWindows <p>Easiest method: Click Force Update in the Docker tab to pull the latest image and restart.</p> <pre><code># Stop and remove current container\ndocker stop peek-stash-browser\ndocker rm peek-stash-browser\n\n# Pull latest image\ndocker pull carrotwaxr/peek-stash-browser:latest\n\n# Restart with same docker run command you used for installation\ndocker run -d \\\n  --name peek-stash-browser \\\n  -p 6969:80 \\\n  -v peek-data:/app/data \\\n  -e JWT_SECRET=\"${JWT_SECRET}\" \\\n  carrotwaxr/peek-stash-browser:latest\n</code></pre> <pre><code># Stop and remove current container\ndocker stop peek-stash-browser\ndocker rm peek-stash-browser\n\n# Pull latest image\ndocker pull carrotwaxr/peek-stash-browser:latest\n\n# Restart with same docker run command you used for installation\ndocker run -d `\n  --name peek-stash-browser `\n  -p 6969:80 `\n  -v peek-data:/app/data `\n  -e JWT_SECRET=$jwt `\n  carrotwaxr/peek-stash-browser:latest\n</code></pre> <p>Your data persists across updates</p> <p>Database, user settings, Stash configuration, and playlists are stored in the <code>peek-data</code> volume and will not be lost.</p>"},{"location":"getting-started/installation/#version-pinning","title":"Version Pinning","text":"<p>To use a specific version instead of <code>:latest</code>:</p> <pre><code># Pull and use specific version\ndocker pull carrotwaxr/peek-stash-browser:1.0.0\ndocker run ... carrotwaxr/peek-stash-browser:1.0.0\n</code></pre> <p>Available versions: GitHub Releases</p>"},{"location":"getting-started/installation/#port-configuration","title":"Port Configuration","text":"Environment Port Service Description Production <code>6969</code> Complete App nginx serves frontend + proxies API Development <code>6969</code> Frontend UI Vite dev server with hot reloading Development <code>8000</code> Backend API Express server (internal Docker network) <p>Production uses only one port!</p> <p>Production deployment exposes only port <code>6969</code> - nginx handles everything internally</p>"},{"location":"getting-started/installation/#hardware-recommendations","title":"Hardware Recommendations","text":"Component Minimum Recommended CPU 2 cores 4+ cores (for multiple transcoding streams) RAM 2GB 4GB+ Storage SSD for database SSD for database, network storage for media Network 100 Mbps Gigabit (for 4K content)"},{"location":"getting-started/installation/#next-steps","title":"Next Steps","text":"<ul> <li>Configure environment variables</li> <li>Quick Start Guide</li> <li>Troubleshooting</li> </ul>"},{"location":"getting-started/quick-start/","title":"Quick Start","text":"<p>Get Peek up and running in 5 minutes!</p>"},{"location":"getting-started/quick-start/#step-1-install-peek","title":"Step 1: Install Peek","text":"Docker (Fastest)unRAIDDocker Compose <pre><code># Pull the latest image\ndocker pull carrotwaxr/peek-stash-browser:latest\n\n# Generate JWT secret\nexport JWT_SECRET=$(openssl rand -base64 32)\n\n# Run Peek\ndocker run -d \\\n  --name peek-stash-browser \\\n  -p 6969:80 \\\n  -v /path/to/media:/app/media:ro \\\n  -v peek-data:/app/data \\\n  -e STASH_URL=\"http://your-stash:9999/graphql\" \\\n  -e STASH_API_KEY=\"your_api_key\" \\\n  -e JWT_SECRET=\"${JWT_SECRET}\" \\\n  carrotwaxr/peek-stash-browser:latest\n</code></pre> <ol> <li>Search \"Peek Stash Browser\" in Community Applications</li> <li>Click Install</li> <li>Configure Stash URL and API key</li> <li>Generate JWT secret: <code>openssl rand -hex 32</code></li> <li>Click Apply</li> </ol> <pre><code>git clone https://github.com/carrotwaxr/peek-stash-browser.git\ncd peek-stash-browser\ncp .env.example .env\n# Edit .env with your settings\ndocker-compose up -d\n</code></pre>"},{"location":"getting-started/quick-start/#step-2-setup-wizard","title":"Step 2: Setup Wizard","text":"<ol> <li>Open browser: <code>http://localhost:6969</code> (or your server IP)</li> <li>Complete the 5-step setup wizard:</li> <li>Welcome - Introduction to Peek</li> <li>Discover Libraries - Auto-discover your Stash library paths</li> <li>Configure Paths - Map Stash paths to Peek container paths</li> <li>Create Admin - Set your admin username and password</li> <li>Complete - Setup finished!</li> </ol> <p>Path Mapping Made Easy</p> <p>The wizard automatically discovers your Stash libraries and helps you configure path mappings correctly!</p>"},{"location":"getting-started/quick-start/#step-3-browse-your-library","title":"Step 3: Browse Your Library","text":"<ul> <li>Scenes: Browse all your video content</li> <li>Performers: View performers and their scenes</li> <li>Studios: Explore by production company</li> <li>Tags: Find content by tags</li> </ul>"},{"location":"getting-started/quick-start/#step-4-watch-videos","title":"Step 4: Watch Videos","text":"<ol> <li>Click any scene to view details</li> <li>Click Play to start video</li> <li>Quality automatically adjusts based on network</li> <li>Use timeline to seek through video</li> </ol>"},{"location":"getting-started/quick-start/#step-5-create-playlists","title":"Step 5: Create Playlists","text":"<p>Organize your favorite scenes into custom playlists:</p> <ol> <li>Click Playlists in the navigation menu</li> <li>Click Create Playlist</li> <li>Enter a name and optional description</li> <li>Click Create</li> </ol> <p>Adding Scenes: - Click the + icon on any scene card - Select your playlist from the menu - Scene is added instantly!</p> <p>Playing Playlists: - Click a playlist to view its scenes - Click Play to start playback - Use Shuffle to randomize order - Use Repeat to loop your playlist</p> <p>Learn More</p> <p>See the Complete Playlists Guide for reordering scenes, editing playlists, and more!</p>"},{"location":"getting-started/quick-start/#common-tasks","title":"Common Tasks","text":""},{"location":"getting-started/quick-start/#update-admin-password","title":"Update Admin Password","text":"<ol> <li>Click user icon (top right)</li> <li>Select Settings</li> <li>Enter new password</li> <li>Click Save</li> </ol>"},{"location":"getting-started/quick-start/#create-additional-users","title":"Create Additional Users","text":"<ol> <li>Go to Users (admin only)</li> <li>Click Create User</li> <li>Enter username, email, password</li> <li>Select role (Admin or User)</li> <li>Click Create</li> </ol>"},{"location":"getting-started/quick-start/#configure-theme","title":"Configure Theme","text":"<ol> <li>Click theme toggle icon (moon/sun)</li> <li>Choose Dark or Light mode</li> <li>Theme preference is saved automatically</li> </ol>"},{"location":"getting-started/quick-start/#video-playback-tips","title":"Video Playback Tips","text":"<ul> <li>Direct Play: If browser supports the format, plays directly (no transcoding)</li> <li>Transcoded: HLS streaming with adaptive quality when needed</li> <li>Seeking: Full timeline scrubbing works in both modes</li> <li>Quality: Click quality button to manually select resolution</li> </ul>"},{"location":"getting-started/quick-start/#keyboard-shortcuts","title":"Keyboard Shortcuts","text":"Key Action <code>Space</code> Play/Pause <code>\u2190</code> Seek backward 10s <code>\u2192</code> Seek forward 10s <code>\u2191</code> Volume up <code>\u2193</code> Volume down <code>F</code> Toggle fullscreen <code>M</code> Mute/unmute <p>Full Keyboard Navigation</p> <p>Peek supports complete keyboard navigation including TV mode! See the Keyboard Navigation Guide for all shortcuts.</p>"},{"location":"getting-started/quick-start/#troubleshooting-first-time-issues","title":"Troubleshooting First-Time Issues","text":""},{"location":"getting-started/quick-start/#cant-login","title":"Can't Login","text":"<ul> <li>Check container logs: <code>docker logs peek-stash-browser</code></li> <li>Verify database was created in <code>/app/data</code></li> <li>Ensure <code>JWT_SECRET</code> is set (or auto-generated)</li> </ul>"},{"location":"getting-started/quick-start/#no-scenes-showing","title":"No Scenes Showing","text":"<ul> <li>Check <code>STASH_URL</code> is correct</li> <li>Verify <code>STASH_API_KEY</code> is valid</li> <li>Test Stash connectivity from container:   <pre><code>docker exec peek-stash-browser curl http://your-stash:9999/graphql\n</code></pre></li> </ul>"},{"location":"getting-started/quick-start/#videos-wont-play","title":"Videos Won't Play","text":"<ul> <li>Verify media path is mounted correctly:   <pre><code>docker exec peek-stash-browser ls /app/media\n</code></pre></li> <li>Check path mapping configuration</li> <li>Ensure FFmpeg is installed (included in official image)</li> </ul>"},{"location":"getting-started/quick-start/#next-steps","title":"Next Steps","text":"<ul> <li>Full Configuration Guide</li> <li>Complete Troubleshooting</li> </ul>"},{"location":"getting-started/quick-start/#need-help","title":"Need Help?","text":"<ul> <li>Troubleshooting Guide</li> <li>GitHub Issues</li> <li>Stash Discord - #third-party-integrations channel</li> </ul>"},{"location":"getting-started/upgrading/","title":"Upgrading Peek","text":"<p>This guide covers upgrading Peek to new versions, including database migration procedures and backup strategies.</p>"},{"location":"getting-started/upgrading/#version-300-beta-sqlite-entity-cache","title":"Version 3.0.0 (Beta) - SQLite Entity Cache","text":"<p>Release Type: Beta - recommended for testing only</p> <p>Latest: <code>v3.0.0-beta.2</code></p> <p>Version 3.0.0 introduces a major architectural change: Stash entity data is now stored in SQLite tables instead of being held in memory. This provides:</p> <ul> <li>Scalability: Support for 100k+ scenes without memory exhaustion</li> <li>Performance: Sub-100ms query times with proper indexing</li> <li>Persistence: Library data survives container restarts</li> </ul>"},{"location":"getting-started/upgrading/#whats-changed","title":"What's Changed","text":"Before (v2.1.x) After (v3.0.0) In-memory cache SQLite tables ~3.6 hour sync for 22k scenes ~3 minute sync Memory-limited (~50k scenes max) Disk-limited (tested to 100k+) Data lost on restart Data persists"},{"location":"getting-started/upgrading/#database-changes-summary","title":"Database Changes Summary","text":"<p>The migration adds new tables only - it does NOT modify your existing user data tables:</p> <p>New Tables (23 total): - 7 entity tables: <code>StashScene</code>, <code>StashPerformer</code>, <code>StashStudio</code>, <code>StashTag</code>, <code>StashGroup</code>, <code>StashGallery</code>, <code>StashImage</code> - 14 junction tables for relationships (e.g., <code>ScenePerformer</code>, <code>SceneTag</code>, <code>PerformerTag</code>) - 2 sync management tables: <code>SyncState</code>, <code>SyncSettings</code></p> <p>Preserved Data: - User accounts and passwords - Watch history and resume positions - Playlists and playlist items - Scene/performer/studio/tag ratings and favorites - Filter presets and carousel preferences - Content restrictions and hidden entities - Custom themes</p>"},{"location":"getting-started/upgrading/#pre-upgrade-checklist","title":"Pre-Upgrade Checklist","text":"<ol> <li>Back up your database (see Backup Procedure below)</li> <li>Note your current Peek version: Settings &gt; Server Statistics</li> <li>Ensure Docker has sufficient disk space (~500MB for 100k scenes)</li> </ol>"},{"location":"getting-started/upgrading/#backup-procedure","title":"Backup Procedure","text":"<p>Your Peek database is a single SQLite file. Back it up before upgrading:</p>"},{"location":"getting-started/upgrading/#option-1-docker-compose-recommended","title":"Option 1: Docker Compose (Recommended)","text":"<pre><code># Stop Peek to ensure clean backup\ndocker-compose stop peek-server\n\n# Find your data directory (check your docker-compose.yml volumes)\n# Default is ./data or a named volume\n\n# Copy the database file\ncp ./data/peek.db ./data/peek.db.backup-$(date +%Y%m%d)\n\n# Or if using a named volume:\ndocker run --rm -v peek_data:/data -v $(pwd):/backup alpine \\\n  cp /data/peek.db /backup/peek.db.backup-$(date +%Y%m%d)\n\n# Restart Peek\ndocker-compose start peek-server\n</code></pre>"},{"location":"getting-started/upgrading/#option-2-unraid-users","title":"Option 2: unRAID Users","text":"<ol> <li>Navigate to your Peek appdata folder (typically <code>/mnt/user/appdata/peek/</code>)</li> <li>Copy <code>peek.db</code> to a safe location outside the container</li> <li>Also copy <code>peek.db-wal</code> and <code>peek.db-shm</code> if they exist (WAL mode files)</li> </ol>"},{"location":"getting-started/upgrading/#option-3-while-running-less-safe","title":"Option 3: While Running (Less Safe)","text":"<p>SQLite supports hot backups, but stopping the container is safer:</p> <pre><code># If you can't stop the container\ndocker exec peek-server sqlite3 /app/data/peek.db \".backup '/app/data/peek-backup.db'\"\ndocker cp peek-server:/app/data/peek-backup.db ./peek.db.backup\n</code></pre>"},{"location":"getting-started/upgrading/#upgrade-steps","title":"Upgrade Steps","text":""},{"location":"getting-started/upgrading/#step-1-pull-the-new-image","title":"Step 1: Pull the New Image","text":"<pre><code># For docker-compose users\ndocker-compose pull\n\n# For manual docker users\ndocker pull carrotwaxr/peek:3.0.0-beta.2\n</code></pre>"},{"location":"getting-started/upgrading/#step-2-restart-the-container","title":"Step 2: Restart the Container","text":"<pre><code># Docker Compose\ndocker-compose down\ndocker-compose up -d\n\n# Manual Docker\ndocker stop peek-server\ndocker rm peek-server\ndocker run -d --name peek-server ... carrotwaxr/peek:3.0.0-beta.2\n</code></pre>"},{"location":"getting-started/upgrading/#step-3-wait-for-migration","title":"Step 3: Wait for Migration","text":"<p>On first startup, Prisma will automatically apply the migration: - Check logs: <code>docker-compose logs -f peek-server</code> - Look for: <code>Applied migration: 20251211000000_stash_entities</code> - Migration typically completes in under 5 seconds</p>"},{"location":"getting-started/upgrading/#step-4-wait-for-initial-sync","title":"Step 4: Wait for Initial Sync","text":"<p>The sync starts automatically on first startup after migration. Watch the logs or the sync progress banner in the UI.</p> <p>Sync times depend on your library size: | Library Size | Expected Time | |--------------|---------------| | 1,000 scenes | ~15 seconds | | 10,000 scenes | ~1-2 minutes | | 50,000 scenes | ~5-8 minutes | | 100,000 scenes | ~15-20 minutes |</p>"},{"location":"getting-started/upgrading/#rollback-procedure","title":"Rollback Procedure","text":"<p>If something goes wrong, you can restore your backup:</p> <pre><code># Stop Peek\ndocker-compose stop peek-server\n\n# Restore the backup\ncp ./data/peek.db.backup-YYYYMMDD ./data/peek.db\n\n# Restart with old image\ndocker-compose up -d\n</code></pre> <p>Note: If you need to downgrade the Docker image version, you may need to delete the migration record:</p> <pre><code># Only if downgrading AND experiencing migration errors\ndocker exec peek-server sqlite3 /app/data/peek.db \\\n  \"DELETE FROM _prisma_migrations WHERE migration_name = '20251211000000_stash_entities'\"\n</code></pre>"},{"location":"getting-started/upgrading/#troubleshooting","title":"Troubleshooting","text":""},{"location":"getting-started/upgrading/#library-is-empty-after-upgrade","title":"\"Library is empty after upgrade\"","text":"<p>The sync should start automatically on first startup. If your library appears empty after waiting several minutes, check the logs for errors. You can also manually trigger a sync from Settings &gt; Sync.</p>"},{"location":"getting-started/upgrading/#migration-failed","title":"\"Migration failed\"","text":"<p>Check the logs for the specific error: <pre><code>docker-compose logs peek-server | grep -i migration\n</code></pre></p> <p>Common issues: - Disk full: Free up space and restart - Permission denied: Check volume mount permissions - Database locked: Stop other processes accessing the DB</p>"},{"location":"getting-started/upgrading/#sync-is-very-slow","title":"\"Sync is very slow\"","text":"<p>The initial sync after upgrade fetches all data from Stash. Subsequent syncs are incremental and much faster (typically &lt;30 seconds).</p>"},{"location":"getting-started/upgrading/#cant-connect-to-stash","title":"\"Can't connect to Stash\"","text":"<p>Verify your Stash configuration in Settings. The upgrade doesn't change your Stash connection settings.</p>"},{"location":"getting-started/upgrading/#whats-not-included-in-300-beta","title":"What's NOT Included in 3.0.0 Beta","text":"<p>This beta focuses on the core architecture change. These features are planned for stable release:</p> <ul> <li> Automatic incremental sync on Stash scan complete</li> <li> Full-text search across all entity types</li> <li> Multi-Stash instance support</li> </ul>"},{"location":"getting-started/upgrading/#reporting-issues","title":"Reporting Issues","text":"<p>Found a bug? Please report it: - GitHub: github.com/carrotwaxr/peek-stash-browser/issues - Discourse: discourse.stashapp.cc</p> <p>Include: 1. Your Peek version (Settings &gt; Server Statistics) 2. Your Stash version 3. Library size (scene count) 4. Relevant log output 5. Steps to reproduce</p>"},{"location":"plans/2025-12-09-image-proxy-performance-design/","title":"Design: Image Proxy Performance","text":""},{"location":"plans/2025-12-09-image-proxy-performance-design/#problem","title":"Problem","text":"<p>After fixing SQLite query performance (350-500ms), the app still becomes unresponsive when browsing scenes. Network requests pile up in pending/stalled state, and scene cards never finish loading their images.</p>"},{"location":"plans/2025-12-09-image-proxy-performance-design/#root-cause","title":"Root Cause","text":"<p>When a page of 24 scene cards loads: 1. All 24 cards render immediately 2. Each card has an <code>&lt;img&gt;</code> for the screenshot (plus sprites/previews on hover) 3. Browser queues all 24 image requests quickly (<code>loading=\"lazy\"</code> only defers slightly) 4. All 24 requests hit Peek's proxy simultaneously 5. Proxy opens 24 separate TCP connections to Stash 6. Stash gets overwhelmed, responses slow dramatically 7. Browser's 6-connection-per-host limit causes additional stalling 8. Cards never finish loading</p>"},{"location":"plans/2025-12-09-image-proxy-performance-design/#solution","title":"Solution","text":"<p>Three-part fix targeting both backend and frontend:</p>"},{"location":"plans/2025-12-09-image-proxy-performance-design/#1-backend-connection-pooling","title":"1. Backend: Connection Pooling","text":"<p>Problem: Each proxy request creates a new TCP connection with full handshake overhead.</p> <p>Solution: Use HTTP agents with keep-alive connection pooling.</p> <pre><code>// server/controllers/proxy.ts\n\nimport http from \"http\";\nimport https from \"https\";\n\n// Reusable agents with connection pooling\nconst httpAgent = new http.Agent({\n  keepAlive: true,\n  maxSockets: 6,\n  keepAliveMsecs: 30000\n});\n\nconst httpsAgent = new https.Agent({\n  keepAlive: true,\n  maxSockets: 6,\n  keepAliveMsecs: 30000\n});\n\n// In proxy handlers:\nconst agent = urlObj.protocol === \"https:\" ? httpsAgent : httpAgent;\nhttpModule.get(fullUrl, { agent }, (proxyRes) =&gt; { ... });\n</code></pre>"},{"location":"plans/2025-12-09-image-proxy-performance-design/#2-backend-concurrency-limiting","title":"2. Backend: Concurrency Limiting","text":"<p>Problem: Unlimited concurrent requests overwhelm Stash.</p> <p>Solution: Add a semaphore to limit concurrent outbound requests.</p> <pre><code>// server/controllers/proxy.ts\n\nconst MAX_CONCURRENT_REQUESTS = 4;\nlet activeRequests = 0;\nconst requestQueue: Array&lt;() =&gt; void&gt; = [];\n\nasync function withConcurrencyLimit&lt;T&gt;(fn: () =&gt; Promise&lt;T&gt;): Promise&lt;T&gt; {\n  if (activeRequests &gt;= MAX_CONCURRENT_REQUESTS) {\n    await new Promise&lt;void&gt;(resolve =&gt; requestQueue.push(resolve));\n  }\n  activeRequests++;\n  try {\n    return await fn();\n  } finally {\n    activeRequests--;\n    const next = requestQueue.shift();\n    if (next) next();\n  }\n}\n\n// Wrap proxy logic:\nexport const proxyStashMedia = async (req: Request, res: Response) =&gt; {\n  await withConcurrencyLimit(async () =&gt; {\n    // existing proxy logic\n  });\n};\n</code></pre>"},{"location":"plans/2025-12-09-image-proxy-performance-design/#3-frontend-true-lazy-loading","title":"3. Frontend: True Lazy Loading","text":"<p>Problem: <code>loading=\"lazy\"</code> on <code>&lt;img&gt;</code> doesn't prevent browser from queuing all images.</p> <p>Solution: Only set <code>src</code> when card enters viewport using IntersectionObserver.</p> <pre><code>// client/src/components/ui/SceneCardPreview.jsx\n\nconst [shouldLoadScreenshot, setShouldLoadScreenshot] = useState(false);\n\nuseEffect(() =&gt; {\n  if (!containerElement) return;\n\n  const observer = new IntersectionObserver(\n    ([entry]) =&gt; {\n      if (entry.isIntersecting) {\n        setShouldLoadScreenshot(true);\n        observer.disconnect();\n      }\n    },\n    { rootMargin: \"200px\" } // Load slightly before visible\n  );\n  observer.observe(containerElement);\n  return () =&gt; observer.disconnect();\n}, [containerElement]);\n\n// Render - only set src when ready\n&lt;img\n  src={shouldLoadScreenshot ? scene?.paths?.screenshot : undefined}\n  alt={scene?.title || \"Scene\"}\n  className=\"w-full h-full object-contain\"\n  style={{ backgroundColor: \"var(--bg-secondary)\" }}\n/&gt;\n</code></pre>"},{"location":"plans/2025-12-09-image-proxy-performance-design/#files-to-modify","title":"Files to Modify","text":"File Change <code>server/controllers/proxy.ts</code> Add connection pooling agents, concurrency limiter <code>client/src/components/ui/SceneCardPreview.jsx</code> IntersectionObserver for screenshot lazy loading"},{"location":"plans/2025-12-09-image-proxy-performance-design/#implementation-order","title":"Implementation Order","text":"<ol> <li>Backend changes first (immediate improvement)</li> <li>Frontend changes second (further reduces load)</li> </ol>"},{"location":"plans/2025-12-09-image-proxy-performance-design/#not-doing-yagni","title":"Not Doing (YAGNI)","text":"<ul> <li>Server-side disk cache: Browser cache with <code>Cache-Control: immutable, max-age=1year</code> is sufficient. Stash images are essentially immutable.</li> <li>Virtualization: Overkill for 24 cards per page. Would add complexity without proportional benefit.</li> <li>Priority queuing: Simple FIFO queue is sufficient. No need to prioritize certain image types.</li> </ul>"},{"location":"plans/2025-12-09-image-proxy-performance-design/#expected-results","title":"Expected Results","text":"<ul> <li>Initial page load: 4 concurrent requests max instead of 24</li> <li>Scrolling: Progressive loading as cards enter viewport</li> <li>Repeat visits: Browser cache serves images instantly</li> <li>Stash load: Dramatically reduced, no more overwhelming</li> </ul>"},{"location":"plans/2025-12-09-image-proxy-performance-design/#success-criteria","title":"Success Criteria","text":"<ul> <li>Scene grid loads without hanging</li> <li>Network tab shows controlled request flow (not 24 pending)</li> <li>Cards load progressively as user scrolls</li> <li>No browser unresponsiveness during navigation</li> </ul>"},{"location":"plans/2025-12-09-json-blob-elimination/","title":"JSON Blob Elimination - Implementation Plan","text":"<p>Date: 2025-12-09 Feature: Eliminate JSON blob storage to achieve ~5 minute sync for 22k scenes (vs 3.6 hours) Branch: <code>feature/cache-scalability-investigation</code> Design Doc: json-blob-elimination-plan.md</p>"},{"location":"plans/2025-12-09-json-blob-elimination/#overview","title":"Overview","text":"<p>This plan eliminates the JSON blob (<code>data</code> column) from cached entities and replaces it with explicit database columns. URL transformation moves from sync-time to read-time.</p> <p>Current State: - Scenes/Images sync stores <code>data: \"{}\"</code> (empty JSON) - never worked properly - Performers/Studios/Tags/Groups/Galleries store full JSON blob in <code>data</code> column - ~100 scenes/minute sync speed (3.6 hours for 22k scenes)</p> <p>Target State: - All entity fields stored as individual columns - URLs transformed at read time via proxy - Batch SQL operations for sync - ~5 minute sync for 22k scenes</p>"},{"location":"plans/2025-12-09-json-blob-elimination/#task-1-add-scene-schema-columns","title":"Task 1: Add Scene Schema Columns","text":""},{"location":"plans/2025-12-09-json-blob-elimination/#11-update-prisma-schema-cachedscene","title":"1.1 Update Prisma Schema - CachedScene","text":"<p>File: <code>server/prisma/schema.prisma</code></p> <p>Location: Lines 396-431 (CachedScene model)</p> <p>Replace: <pre><code>model CachedScene {\n    id              String    @id                    // Stash scene ID\n    stashInstanceId String?                          // Which Stash server\n\n    // Indexed fields for filtering/sorting\n    title           String?\n    code            String?\n    date            String?                          // YYYY-MM-DD\n    studioId        String?\n    rating100       Int?\n    duration        Int?                             // seconds (from file)\n    organized       Boolean   @default(false)\n\n    // Full entity data as JSON (performers, tags, files, paths, streams, etc.)\n    data            String                           // JSON blob\n\n    // Sync metadata\n    stashCreatedAt  DateTime?\n    stashUpdatedAt  DateTime?\n    syncedAt        DateTime  @default(now())\n    deletedAt       DateTime?\n\n    // Junction table relations\n    performers      ScenePerformer[]\n    tags            SceneTag[]\n    groups          SceneGroup[]\n    galleries       SceneGallery[]\n\n    @@index([studioId])\n    @@index([date])\n    @@index([stashCreatedAt])\n    @@index([stashUpdatedAt])\n    @@index([rating100])\n    @@index([duration])\n    @@index([deletedAt])\n}\n</code></pre></p> <p>With: <pre><code>model CachedScene {\n    id              String    @id                    // Stash scene ID\n    stashInstanceId String?                          // Which Stash server\n\n    // === Core fields (indexed) ===\n    title           String?\n    code            String?\n    date            String?                          // YYYY-MM-DD\n    studioId        String?\n    rating100       Int?\n    duration        Int?                             // seconds (from primary file)\n    organized       Boolean   @default(false)\n\n    // === Content fields ===\n    details         String?                          // Scene description\n\n    // === Primary file metadata ===\n    filePath        String?                          // Primary file path\n    fileBitRate     Int?                             // bits/second\n    fileFrameRate   Float?                           // fps\n    fileWidth       Int?                             // pixels\n    fileHeight      Int?                             // pixels\n    fileVideoCodec  String?                          // e.g., \"h264\", \"hevc\"\n    fileAudioCodec  String?                          // e.g., \"aac\", \"ac3\"\n    fileSize        BigInt?                          // bytes (can be &gt; 4GB)\n\n    // === Stash paths (raw, transformed at read time) ===\n    pathScreenshot  String?                          // Screenshot URL path\n    pathPreview     String?                          // Preview video path\n    pathSprite      String?                          // Sprite sheet path\n    pathVtt         String?                          // VTT chapter path\n    pathChaptersVtt String?                          // Chapters VTT path\n    pathStream      String?                          // Primary stream path\n    pathCaption     String?                          // Caption path\n\n    // === Stream data (small JSON array) ===\n    streams         String?                          // JSON: [{url, mime_type, label}]\n\n    // === Stash counter data ===\n    oCounter        Int       @default(0)            // Stash o_counter\n    playCount       Int       @default(0)            // Stash play_count\n    playDuration    Float     @default(0)            // Stash play_duration\n\n    // === Sync metadata ===\n    stashCreatedAt  DateTime?\n    stashUpdatedAt  DateTime?\n    syncedAt        DateTime  @default(now())\n    deletedAt       DateTime?\n\n    // === Junction table relations ===\n    performers      ScenePerformer[]\n    tags            SceneTag[]\n    groups          SceneGroup[]\n    galleries       SceneGallery[]\n\n    @@index([studioId])\n    @@index([date])\n    @@index([stashCreatedAt])\n    @@index([stashUpdatedAt])\n    @@index([rating100])\n    @@index([duration])\n    @@index([deletedAt])\n    @@index([oCounter])\n    @@index([playCount])\n}\n</code></pre></p> <p>Verification: <pre><code>cd server &amp;&amp; npx prisma validate\n</code></pre></p> <p>Expected: \"Your schema is valid\"</p>"},{"location":"plans/2025-12-09-json-blob-elimination/#12-update-prisma-schema-cachedimage","title":"1.2 Update Prisma Schema - CachedImage","text":"<p>File: <code>server/prisma/schema.prisma</code></p> <p>Location: Lines 578-608 (CachedImage model)</p> <p>Replace: <pre><code>model CachedImage {\n    id              String    @id\n    stashInstanceId String?\n\n    title           String?\n    date            String?\n    studioId        String?\n    rating100       Int?\n    oCounter        Int       @default(0)\n    organized       Boolean   @default(false)\n    width           Int?\n    height          Int?\n    fileSize        Int?\n\n    data            String\n\n    stashCreatedAt  DateTime?\n    stashUpdatedAt  DateTime?\n    syncedAt        DateTime  @default(now())\n    deletedAt       DateTime?\n\n    performers      ImagePerformer[]\n    tags            ImageTag[]\n    galleries       ImageGallery[]\n\n    @@index([studioId])\n    @@index([date])\n    @@index([rating100])\n    @@index([stashUpdatedAt])\n    @@index([deletedAt])\n}\n</code></pre></p> <p>With: <pre><code>model CachedImage {\n    id              String    @id\n    stashInstanceId String?\n\n    // === Core fields ===\n    title           String?\n    date            String?\n    studioId        String?\n    rating100       Int?\n    oCounter        Int       @default(0)\n    organized       Boolean   @default(false)\n\n    // === File metadata ===\n    filePath        String?                          // Image file path\n    width           Int?\n    height          Int?\n    fileSize        BigInt?                          // bytes\n\n    // === Stash paths (raw, transformed at read time) ===\n    pathThumbnail   String?                          // Thumbnail URL path\n    pathPreview     String?                          // Preview URL path\n    pathImage       String?                          // Full image URL path\n\n    // === Sync metadata ===\n    stashCreatedAt  DateTime?\n    stashUpdatedAt  DateTime?\n    syncedAt        DateTime  @default(now())\n    deletedAt       DateTime?\n\n    // === Relations ===\n    performers      ImagePerformer[]\n    tags            ImageTag[]\n    galleries       ImageGallery[]\n\n    @@index([studioId])\n    @@index([date])\n    @@index([rating100])\n    @@index([stashUpdatedAt])\n    @@index([deletedAt])\n}\n</code></pre></p> <p>Verification: <pre><code>cd server &amp;&amp; npx prisma validate\n</code></pre></p>"},{"location":"plans/2025-12-09-json-blob-elimination/#13-update-prisma-schema-cachedperformer","title":"1.3 Update Prisma Schema - CachedPerformer","text":"<p>File: <code>server/prisma/schema.prisma</code></p> <p>Location: Lines 433-464 (CachedPerformer model)</p> <p>Replace: <pre><code>model CachedPerformer {\n    id              String    @id\n    stashInstanceId String?\n\n    name            String\n    disambiguation  String?\n    gender          String?\n    birthdate       String?\n    favorite        Boolean   @default(false)\n    rating100       Int?\n    sceneCount      Int       @default(0)\n    imageCount      Int       @default(0)\n    galleryCount    Int       @default(0)\n\n    data            String\n\n    stashCreatedAt  DateTime?\n    stashUpdatedAt  DateTime?\n    syncedAt        DateTime  @default(now())\n    deletedAt       DateTime?\n\n    scenes          ScenePerformer[]\n    images          ImagePerformer[]\n\n    @@index([name])\n    @@index([gender])\n    @@index([favorite])\n    @@index([rating100])\n    @@index([sceneCount])\n    @@index([stashUpdatedAt])\n    @@index([deletedAt])\n}\n</code></pre></p> <p>With: <pre><code>model CachedPerformer {\n    id              String    @id\n    stashInstanceId String?\n\n    // === Core fields ===\n    name            String\n    disambiguation  String?\n    gender          String?\n    birthdate       String?\n    favorite        Boolean   @default(false)\n    rating100       Int?\n    sceneCount      Int       @default(0)\n    imageCount      Int       @default(0)\n    galleryCount    Int       @default(0)\n\n    // === Extended fields ===\n    details         String?                          // Biography\n    aliasList       String?                          // JSON array of aliases\n    country         String?\n    ethnicity       String?\n    hairColor       String?\n    eyeColor        String?\n    heightCm        Int?                             // Height in cm\n    weightKg        Int?                             // Weight in kg\n    measurements    String?                          // e.g., \"34D-24-34\"\n    tattoos         String?\n    piercings       String?\n    careerLength    String?\n    deathDate       String?\n    url             String?                          // Homepage\n\n    // === Stash paths (raw, transformed at read time) ===\n    imagePath       String?                          // Profile image path\n\n    // === Sync metadata ===\n    stashCreatedAt  DateTime?\n    stashUpdatedAt  DateTime?\n    syncedAt        DateTime  @default(now())\n    deletedAt       DateTime?\n\n    // === Relations ===\n    scenes          ScenePerformer[]\n    images          ImagePerformer[]\n\n    @@index([name])\n    @@index([gender])\n    @@index([favorite])\n    @@index([rating100])\n    @@index([sceneCount])\n    @@index([stashUpdatedAt])\n    @@index([deletedAt])\n}\n</code></pre></p>"},{"location":"plans/2025-12-09-json-blob-elimination/#14-update-prisma-schema-cachedstudio","title":"1.4 Update Prisma Schema - CachedStudio","text":"<p>File: <code>server/prisma/schema.prisma</code></p> <p>Location: Lines 466-492 (CachedStudio model)</p> <p>Replace: <pre><code>model CachedStudio {\n    id              String    @id\n    stashInstanceId String?\n\n    name            String\n    parentId        String?\n    favorite        Boolean   @default(false)\n    rating100       Int?\n    sceneCount      Int       @default(0)\n    imageCount      Int       @default(0)\n    galleryCount    Int       @default(0)\n\n    data            String\n\n    stashCreatedAt  DateTime?\n    stashUpdatedAt  DateTime?\n    syncedAt        DateTime  @default(now())\n    deletedAt       DateTime?\n\n    @@index([name])\n    @@index([parentId])\n    @@index([favorite])\n    @@index([rating100])\n    @@index([sceneCount])\n    @@index([stashUpdatedAt])\n    @@index([deletedAt])\n}\n</code></pre></p> <p>With: <pre><code>model CachedStudio {\n    id              String    @id\n    stashInstanceId String?\n\n    // === Core fields ===\n    name            String\n    parentId        String?\n    favorite        Boolean   @default(false)\n    rating100       Int?\n    sceneCount      Int       @default(0)\n    imageCount      Int       @default(0)\n    galleryCount    Int       @default(0)\n\n    // === Extended fields ===\n    details         String?                          // Studio description\n    url             String?                          // Studio website\n\n    // === Stash paths (raw, transformed at read time) ===\n    imagePath       String?                          // Logo image path\n\n    // === Sync metadata ===\n    stashCreatedAt  DateTime?\n    stashUpdatedAt  DateTime?\n    syncedAt        DateTime  @default(now())\n    deletedAt       DateTime?\n\n    @@index([name])\n    @@index([parentId])\n    @@index([favorite])\n    @@index([rating100])\n    @@index([sceneCount])\n    @@index([stashUpdatedAt])\n    @@index([deletedAt])\n}\n</code></pre></p>"},{"location":"plans/2025-12-09-json-blob-elimination/#15-update-prisma-schema-cachedtag","title":"1.5 Update Prisma Schema - CachedTag","text":"<p>File: <code>server/prisma/schema.prisma</code></p> <p>Location: Lines 494-518 (CachedTag model)</p> <p>Replace: <pre><code>model CachedTag {\n    id              String    @id\n    stashInstanceId String?\n\n    name            String\n    favorite        Boolean   @default(false)\n    sceneCount      Int       @default(0)\n    imageCount      Int       @default(0)\n\n    data            String\n\n    stashCreatedAt  DateTime?\n    stashUpdatedAt  DateTime?\n    syncedAt        DateTime  @default(now())\n    deletedAt       DateTime?\n\n    scenes          SceneTag[]\n    images          ImageTag[]\n\n    @@index([name])\n    @@index([favorite])\n    @@index([sceneCount])\n    @@index([stashUpdatedAt])\n    @@index([deletedAt])\n}\n</code></pre></p> <p>With: <pre><code>model CachedTag {\n    id              String    @id\n    stashInstanceId String?\n\n    // === Core fields ===\n    name            String\n    favorite        Boolean   @default(false)\n    sceneCount      Int       @default(0)\n    imageCount      Int       @default(0)\n\n    // === Extended fields ===\n    description     String?                          // Tag description\n    parentIds       String?                          // JSON array of parent tag IDs\n\n    // === Stash paths (raw, transformed at read time) ===\n    imagePath       String?                          // Tag image path\n\n    // === Sync metadata ===\n    stashCreatedAt  DateTime?\n    stashUpdatedAt  DateTime?\n    syncedAt        DateTime  @default(now())\n    deletedAt       DateTime?\n\n    // === Relations ===\n    scenes          SceneTag[]\n    images          ImageTag[]\n\n    @@index([name])\n    @@index([favorite])\n    @@index([sceneCount])\n    @@index([stashUpdatedAt])\n    @@index([deletedAt])\n}\n</code></pre></p>"},{"location":"plans/2025-12-09-json-blob-elimination/#16-update-prisma-schema-cachedgroup","title":"1.6 Update Prisma Schema - CachedGroup","text":"<p>File: <code>server/prisma/schema.prisma</code></p> <p>Location: Lines 520-547 (CachedGroup model)</p> <p>Replace: <pre><code>model CachedGroup {\n    id              String    @id\n    stashInstanceId String?\n\n    name            String\n    date            String?\n    studioId        String?\n    rating100       Int?\n    duration        Int?\n    sceneCount      Int       @default(0)\n\n    data            String\n\n    stashCreatedAt  DateTime?\n    stashUpdatedAt  DateTime?\n    syncedAt        DateTime  @default(now())\n    deletedAt       DateTime?\n\n    scenes          SceneGroup[]\n\n    @@index([name])\n    @@index([date])\n    @@index([studioId])\n    @@index([rating100])\n    @@index([sceneCount])\n    @@index([stashUpdatedAt])\n    @@index([deletedAt])\n}\n</code></pre></p> <p>With: <pre><code>model CachedGroup {\n    id              String    @id\n    stashInstanceId String?\n\n    // === Core fields ===\n    name            String\n    date            String?\n    studioId        String?\n    rating100       Int?\n    duration        Int?\n    sceneCount      Int       @default(0)\n\n    // === Extended fields ===\n    director        String?\n    synopsis        String?\n    urls            String?                          // JSON array of URLs\n\n    // === Stash paths (raw, transformed at read time) ===\n    frontImagePath  String?                          // Front cover image\n    backImagePath   String?                          // Back cover image\n\n    // === Sync metadata ===\n    stashCreatedAt  DateTime?\n    stashUpdatedAt  DateTime?\n    syncedAt        DateTime  @default(now())\n    deletedAt       DateTime?\n\n    // === Relations ===\n    scenes          SceneGroup[]\n\n    @@index([name])\n    @@index([date])\n    @@index([studioId])\n    @@index([rating100])\n    @@index([sceneCount])\n    @@index([stashUpdatedAt])\n    @@index([deletedAt])\n}\n</code></pre></p>"},{"location":"plans/2025-12-09-json-blob-elimination/#17-update-prisma-schema-cachedgallery","title":"1.7 Update Prisma Schema - CachedGallery","text":"<p>File: <code>server/prisma/schema.prisma</code></p> <p>Location: Lines 549-576 (CachedGallery model)</p> <p>Replace: <pre><code>model CachedGallery {\n    id              String    @id\n    stashInstanceId String?\n\n    title           String?\n    date            String?\n    studioId        String?\n    rating100       Int?\n    imageCount      Int       @default(0)\n\n    data            String\n\n    stashCreatedAt  DateTime?\n    stashUpdatedAt  DateTime?\n    syncedAt        DateTime  @default(now())\n    deletedAt       DateTime?\n\n    scenes          SceneGallery[]\n    images          ImageGallery[]\n\n    @@index([title])\n    @@index([date])\n    @@index([studioId])\n    @@index([rating100])\n    @@index([imageCount])\n    @@index([stashUpdatedAt])\n    @@index([deletedAt])\n}\n</code></pre></p> <p>With: <pre><code>model CachedGallery {\n    id              String    @id\n    stashInstanceId String?\n\n    // === Core fields ===\n    title           String?\n    date            String?\n    studioId        String?\n    rating100       Int?\n    imageCount      Int       @default(0)\n\n    // === Extended fields ===\n    details         String?                          // Gallery description\n    url             String?                          // Gallery URL\n    code            String?                          // Gallery code\n\n    // === File metadata ===\n    folderPath      String?                          // Folder path if folder-based\n\n    // === Stash paths (raw, transformed at read time) ===\n    coverPath       String?                          // Cover image path\n\n    // === Sync metadata ===\n    stashCreatedAt  DateTime?\n    stashUpdatedAt  DateTime?\n    syncedAt        DateTime  @default(now())\n    deletedAt       DateTime?\n\n    // === Relations ===\n    scenes          SceneGallery[]\n    images          ImageGallery[]\n\n    @@index([title])\n    @@index([date])\n    @@index([studioId])\n    @@index([rating100])\n    @@index([imageCount])\n    @@index([stashUpdatedAt])\n    @@index([deletedAt])\n}\n</code></pre></p>"},{"location":"plans/2025-12-09-json-blob-elimination/#18-create-migration","title":"1.8 Create Migration","text":"<p>Command: <pre><code>cd server &amp;&amp; npx prisma migrate dev --name eliminate_json_blob\n</code></pre></p> <p>Verification: - Migration file created in <code>server/prisma/migrations/</code> - No errors during migration - Database has new columns</p>"},{"location":"plans/2025-12-09-json-blob-elimination/#task-2-update-stashsyncservice-scene-sync","title":"Task 2: Update StashSyncService - Scene Sync","text":""},{"location":"plans/2025-12-09-json-blob-elimination/#21-update-processscenesbatch","title":"2.1 Update processScenesBatch","text":"<p>File: <code>server/services/StashSyncService.ts</code></p> <p>Location: Lines 617-715 (processScenesBatch method)</p> <p>Replace the entire method with: <pre><code>private async processScenesBatch(\n  scenes: Scene[],\n  stashInstanceId: string | undefined,\n  batchStart: number,\n  totalCount: number\n): Promise&lt;void&gt; {\n  const sceneIds = scenes.map(s =&gt; s.id);\n\n  // Bulk delete all junction records for this batch\n  await Promise.all([\n    prisma.scenePerformer.deleteMany({ where: { sceneId: { in: sceneIds } } }),\n    prisma.sceneTag.deleteMany({ where: { sceneId: { in: sceneIds } } }),\n    prisma.sceneGroup.deleteMany({ where: { sceneId: { in: sceneIds } } }),\n    prisma.sceneGallery.deleteMany({ where: { sceneId: { in: sceneIds } } }),\n  ]);\n\n  // Build bulk scene upsert using raw SQL\n  const sceneValues = scenes.map(scene =&gt; {\n    const file = scene.files?.[0];\n    const paths = scene.paths;\n\n    return `(\n      '${this.escape(scene.id)}',\n      ${stashInstanceId ? `'${this.escape(stashInstanceId)}'` : 'NULL'},\n      ${this.escapeNullable(scene.title)},\n      ${this.escapeNullable(scene.code)},\n      ${this.escapeNullable(scene.date)},\n      ${scene.studio?.id ? `'${this.escape(scene.studio.id)}'` : 'NULL'},\n      ${scene.rating100 ?? 'NULL'},\n      ${file?.duration ? Math.round(file.duration) : 'NULL'},\n      ${scene.organized ? 1 : 0},\n      ${this.escapeNullable(scene.details)},\n      ${this.escapeNullable(file?.path)},\n      ${file?.bit_rate ?? 'NULL'},\n      ${file?.frame_rate ?? 'NULL'},\n      ${file?.width ?? 'NULL'},\n      ${file?.height ?? 'NULL'},\n      ${this.escapeNullable(file?.video_codec)},\n      ${this.escapeNullable(file?.audio_codec)},\n      ${file?.size ?? 'NULL'},\n      ${this.escapeNullable(paths?.screenshot)},\n      ${this.escapeNullable(paths?.preview)},\n      ${this.escapeNullable(paths?.sprite)},\n      ${this.escapeNullable(paths?.vtt)},\n      ${this.escapeNullable(paths?.chapters_vtt)},\n      ${this.escapeNullable(paths?.stream)},\n      ${this.escapeNullable(paths?.caption)},\n      ${this.escapeNullable(JSON.stringify(scene.sceneStreams || []))},\n      ${scene.o_counter ?? 0},\n      ${scene.play_count ?? 0},\n      ${scene.play_duration ?? 0},\n      ${scene.created_at ? `'${scene.created_at}'` : 'NULL'},\n      ${scene.updated_at ? `'${scene.updated_at}'` : 'NULL'},\n      datetime('now'),\n      NULL\n    )`;\n  }).join(',\\n');\n\n  await prisma.$executeRawUnsafe(`\n    INSERT INTO CachedScene (\n      id, stashInstanceId, title, code, date, studioId, rating100, duration,\n      organized, details, filePath, fileBitRate, fileFrameRate, fileWidth,\n      fileHeight, fileVideoCodec, fileAudioCodec, fileSize, pathScreenshot,\n      pathPreview, pathSprite, pathVtt, pathChaptersVtt, pathStream, pathCaption,\n      streams, oCounter, playCount, playDuration, stashCreatedAt, stashUpdatedAt,\n      syncedAt, deletedAt\n    ) VALUES ${sceneValues}\n    ON CONFLICT(id) DO UPDATE SET\n      title = excluded.title,\n      code = excluded.code,\n      date = excluded.date,\n      studioId = excluded.studioId,\n      rating100 = excluded.rating100,\n      duration = excluded.duration,\n      organized = excluded.organized,\n      details = excluded.details,\n      filePath = excluded.filePath,\n      fileBitRate = excluded.fileBitRate,\n      fileFrameRate = excluded.fileFrameRate,\n      fileWidth = excluded.fileWidth,\n      fileHeight = excluded.fileHeight,\n      fileVideoCodec = excluded.fileVideoCodec,\n      fileAudioCodec = excluded.fileAudioCodec,\n      fileSize = excluded.fileSize,\n      pathScreenshot = excluded.pathScreenshot,\n      pathPreview = excluded.pathPreview,\n      pathSprite = excluded.pathSprite,\n      pathVtt = excluded.pathVtt,\n      pathChaptersVtt = excluded.pathChaptersVtt,\n      pathStream = excluded.pathStream,\n      pathCaption = excluded.pathCaption,\n      streams = excluded.streams,\n      oCounter = excluded.oCounter,\n      playCount = excluded.playCount,\n      playDuration = excluded.playDuration,\n      stashCreatedAt = excluded.stashCreatedAt,\n      stashUpdatedAt = excluded.stashUpdatedAt,\n      syncedAt = excluded.syncedAt,\n      deletedAt = NULL\n  `);\n\n  // Collect all junction records\n  const performerRecords: string[] = [];\n  const tagRecords: string[] = [];\n  const groupRecords: string[] = [];\n  const galleryRecords: string[] = [];\n\n  for (const scene of scenes) {\n    for (const p of scene.performers || []) {\n      performerRecords.push(`('${this.escape(scene.id)}', '${this.escape(p.id)}')`);\n    }\n    for (const t of scene.tags || []) {\n      tagRecords.push(`('${this.escape(scene.id)}', '${this.escape(t.id)}')`);\n    }\n    for (const g of scene.groups || []) {\n      const groupObj = (g as any).group || g;\n      const index = (g as any).scene_index ?? 'NULL';\n      groupRecords.push(`('${this.escape(scene.id)}', '${this.escape(groupObj.id)}', ${index})`);\n    }\n    for (const g of scene.galleries || []) {\n      galleryRecords.push(`('${this.escape(scene.id)}', '${this.escape(g.id)}')`);\n    }\n  }\n\n  // Batch insert junction records\n  const inserts = [];\n\n  if (performerRecords.length &gt; 0) {\n    inserts.push(prisma.$executeRawUnsafe(\n      `INSERT OR IGNORE INTO ScenePerformer (sceneId, performerId) VALUES ${performerRecords.join(',')}`\n    ));\n  }\n  if (tagRecords.length &gt; 0) {\n    inserts.push(prisma.$executeRawUnsafe(\n      `INSERT OR IGNORE INTO SceneTag (sceneId, tagId) VALUES ${tagRecords.join(',')}`\n    ));\n  }\n  if (groupRecords.length &gt; 0) {\n    inserts.push(prisma.$executeRawUnsafe(\n      `INSERT OR IGNORE INTO SceneGroup (sceneId, groupId, sceneIndex) VALUES ${groupRecords.join(',')}`\n    ));\n  }\n  if (galleryRecords.length &gt; 0) {\n    inserts.push(prisma.$executeRawUnsafe(\n      `INSERT OR IGNORE INTO SceneGallery (sceneId, galleryId) VALUES ${galleryRecords.join(',')}`\n    ));\n  }\n\n  await Promise.all(inserts);\n\n  // Log progress\n  const currentTotal = batchStart + scenes.length;\n  logger.info(\n    `Scenes: ${currentTotal}/${totalCount} (${Math.round((currentTotal / totalCount) * 100)}%)`\n  );\n}\n</code></pre></p>"},{"location":"plans/2025-12-09-json-blob-elimination/#22-add-sql-escape-helpers","title":"2.2 Add SQL Escape Helpers","text":"<p>File: <code>server/services/StashSyncService.ts</code></p> <p>Location: After line 51 (after class declaration, before methods)</p> <p>Add: <pre><code>/**\n * Escape a string for SQL, handling quotes\n */\nprivate escape(value: string): string {\n  return value.replace(/'/g, \"''\");\n}\n\n/**\n * Escape a nullable string for SQL\n * Returns 'value' or NULL\n */\nprivate escapeNullable(value: string | null | undefined): string {\n  if (value === null || value === undefined) return 'NULL';\n  return `'${this.escape(value)}'`;\n}\n</code></pre></p>"},{"location":"plans/2025-12-09-json-blob-elimination/#23-update-syncscenes-page_size","title":"2.3 Update syncScenes PAGE_SIZE","text":"<p>File: <code>server/services/StashSyncService.ts</code></p> <p>Location: Line 53</p> <p>Replace: <pre><code>private readonly PAGE_SIZE = 100; // Very small batches for scene junction tables\n</code></pre></p> <p>With: <pre><code>private readonly PAGE_SIZE = 500; // Larger batches now that we use bulk SQL\n</code></pre></p>"},{"location":"plans/2025-12-09-json-blob-elimination/#task-3-update-other-entity-sync-methods","title":"Task 3: Update Other Entity Sync Methods","text":""},{"location":"plans/2025-12-09-json-blob-elimination/#31-update-processperformersbatch","title":"3.1 Update processPerformersBatch","text":"<p>File: <code>server/services/StashSyncService.ts</code></p> <p>Location: Lines 797-849 (processPerformersBatch method)</p> <p>Replace with: <pre><code>private async processPerformersBatch(\n  performers: Performer[],\n  stashInstanceId?: string\n): Promise&lt;void&gt; {\n  const values = performers.map(performer =&gt; {\n    return `(\n      '${this.escape(performer.id)}',\n      ${stashInstanceId ? `'${this.escape(stashInstanceId)}'` : 'NULL'},\n      ${this.escapeNullable(performer.name)},\n      ${this.escapeNullable(performer.disambiguation)},\n      ${this.escapeNullable(performer.gender)},\n      ${this.escapeNullable(performer.birthdate)},\n      ${performer.favorite ? 1 : 0},\n      ${performer.rating100 ?? 'NULL'},\n      ${performer.scene_count ?? 0},\n      ${performer.image_count ?? 0},\n      ${performer.gallery_count ?? 0},\n      ${this.escapeNullable(performer.details)},\n      ${this.escapeNullable(JSON.stringify(performer.alias_list || []))},\n      ${this.escapeNullable(performer.country)},\n      ${this.escapeNullable(performer.ethnicity)},\n      ${this.escapeNullable(performer.hair_color)},\n      ${this.escapeNullable(performer.eye_color)},\n      ${performer.height_cm ?? 'NULL'},\n      ${performer.weight ?? 'NULL'},\n      ${this.escapeNullable(performer.measurements)},\n      ${this.escapeNullable(performer.tattoos)},\n      ${this.escapeNullable(performer.piercings)},\n      ${this.escapeNullable(performer.career_length)},\n      ${this.escapeNullable(performer.death_date)},\n      ${this.escapeNullable(performer.url)},\n      ${this.escapeNullable(performer.image_path)},\n      ${performer.created_at ? `'${performer.created_at}'` : 'NULL'},\n      ${performer.updated_at ? `'${performer.updated_at}'` : 'NULL'},\n      datetime('now'),\n      NULL\n    )`;\n  }).join(',\\n');\n\n  await prisma.$executeRawUnsafe(`\n    INSERT INTO CachedPerformer (\n      id, stashInstanceId, name, disambiguation, gender, birthdate, favorite,\n      rating100, sceneCount, imageCount, galleryCount, details, aliasList,\n      country, ethnicity, hairColor, eyeColor, heightCm, weightKg, measurements,\n      tattoos, piercings, careerLength, deathDate, url, imagePath,\n      stashCreatedAt, stashUpdatedAt, syncedAt, deletedAt\n    ) VALUES ${values}\n    ON CONFLICT(id) DO UPDATE SET\n      name = excluded.name,\n      disambiguation = excluded.disambiguation,\n      gender = excluded.gender,\n      birthdate = excluded.birthdate,\n      favorite = excluded.favorite,\n      rating100 = excluded.rating100,\n      sceneCount = excluded.sceneCount,\n      imageCount = excluded.imageCount,\n      galleryCount = excluded.galleryCount,\n      details = excluded.details,\n      aliasList = excluded.aliasList,\n      country = excluded.country,\n      ethnicity = excluded.ethnicity,\n      hairColor = excluded.hairColor,\n      eyeColor = excluded.eyeColor,\n      heightCm = excluded.heightCm,\n      weightKg = excluded.weightKg,\n      measurements = excluded.measurements,\n      tattoos = excluded.tattoos,\n      piercings = excluded.piercings,\n      careerLength = excluded.careerLength,\n      deathDate = excluded.deathDate,\n      url = excluded.url,\n      imagePath = excluded.imagePath,\n      stashCreatedAt = excluded.stashCreatedAt,\n      stashUpdatedAt = excluded.stashUpdatedAt,\n      syncedAt = excluded.syncedAt,\n      deletedAt = NULL\n  `);\n}\n</code></pre></p>"},{"location":"plans/2025-12-09-json-blob-elimination/#32-update-processstudiosbatch","title":"3.2 Update processStudiosBatch","text":"<p>File: <code>server/services/StashSyncService.ts</code></p> <p>Location: Lines 931-970 (processStudiosBatch method)</p> <p>Replace with: <pre><code>private async processStudiosBatch(studios: Studio[], stashInstanceId?: string): Promise&lt;void&gt; {\n  const values = studios.map(studio =&gt; {\n    return `(\n      '${this.escape(studio.id)}',\n      ${stashInstanceId ? `'${this.escape(stashInstanceId)}'` : 'NULL'},\n      ${this.escapeNullable(studio.name)},\n      ${studio.parent_studio?.id ? `'${this.escape(studio.parent_studio.id)}'` : 'NULL'},\n      ${studio.favorite ? 1 : 0},\n      ${studio.rating100 ?? 'NULL'},\n      ${studio.scene_count ?? 0},\n      ${studio.image_count ?? 0},\n      ${studio.gallery_count ?? 0},\n      ${this.escapeNullable(studio.details)},\n      ${this.escapeNullable(studio.url)},\n      ${this.escapeNullable(studio.image_path)},\n      ${studio.created_at ? `'${studio.created_at}'` : 'NULL'},\n      ${studio.updated_at ? `'${studio.updated_at}'` : 'NULL'},\n      datetime('now'),\n      NULL\n    )`;\n  }).join(',\\n');\n\n  await prisma.$executeRawUnsafe(`\n    INSERT INTO CachedStudio (\n      id, stashInstanceId, name, parentId, favorite, rating100, sceneCount,\n      imageCount, galleryCount, details, url, imagePath, stashCreatedAt,\n      stashUpdatedAt, syncedAt, deletedAt\n    ) VALUES ${values}\n    ON CONFLICT(id) DO UPDATE SET\n      name = excluded.name,\n      parentId = excluded.parentId,\n      favorite = excluded.favorite,\n      rating100 = excluded.rating100,\n      sceneCount = excluded.sceneCount,\n      imageCount = excluded.imageCount,\n      galleryCount = excluded.galleryCount,\n      details = excluded.details,\n      url = excluded.url,\n      imagePath = excluded.imagePath,\n      stashCreatedAt = excluded.stashCreatedAt,\n      stashUpdatedAt = excluded.stashUpdatedAt,\n      syncedAt = excluded.syncedAt,\n      deletedAt = NULL\n  `);\n}\n</code></pre></p>"},{"location":"plans/2025-12-09-json-blob-elimination/#33-update-processtagsbatch","title":"3.3 Update processTagsBatch","text":"<p>File: <code>server/services/StashSyncService.ts</code></p> <p>Location: Lines 1052-1085 (processTagsBatch method)</p> <p>Replace with: <pre><code>private async processTagsBatch(tags: Tag[], stashInstanceId?: string): Promise&lt;void&gt; {\n  const values = tags.map(tag =&gt; {\n    const parentIds = tag.parents?.map(p =&gt; p.id) || [];\n    return `(\n      '${this.escape(tag.id)}',\n      ${stashInstanceId ? `'${this.escape(stashInstanceId)}'` : 'NULL'},\n      ${this.escapeNullable(tag.name)},\n      ${tag.favorite ? 1 : 0},\n      ${tag.scene_count ?? 0},\n      ${tag.image_count ?? 0},\n      ${this.escapeNullable(tag.description)},\n      ${this.escapeNullable(JSON.stringify(parentIds))},\n      ${this.escapeNullable(tag.image_path)},\n      ${tag.created_at ? `'${tag.created_at}'` : 'NULL'},\n      ${tag.updated_at ? `'${tag.updated_at}'` : 'NULL'},\n      datetime('now'),\n      NULL\n    )`;\n  }).join(',\\n');\n\n  await prisma.$executeRawUnsafe(`\n    INSERT INTO CachedTag (\n      id, stashInstanceId, name, favorite, sceneCount, imageCount, description,\n      parentIds, imagePath, stashCreatedAt, stashUpdatedAt, syncedAt, deletedAt\n    ) VALUES ${values}\n    ON CONFLICT(id) DO UPDATE SET\n      name = excluded.name,\n      favorite = excluded.favorite,\n      sceneCount = excluded.sceneCount,\n      imageCount = excluded.imageCount,\n      description = excluded.description,\n      parentIds = excluded.parentIds,\n      imagePath = excluded.imagePath,\n      stashCreatedAt = excluded.stashCreatedAt,\n      stashUpdatedAt = excluded.stashUpdatedAt,\n      syncedAt = excluded.syncedAt,\n      deletedAt = NULL\n  `);\n}\n</code></pre></p>"},{"location":"plans/2025-12-09-json-blob-elimination/#34-update-processgroupsbatch","title":"3.4 Update processGroupsBatch","text":"<p>File: <code>server/services/StashSyncService.ts</code></p> <p>Location: Lines 1167-1205 (processGroupsBatch method)</p> <p>Replace with: <pre><code>private async processGroupsBatch(groups: Group[], stashInstanceId?: string): Promise&lt;void&gt; {\n  const values = groups.map(group =&gt; {\n    const duration = group.duration || null;\n    const urls = group.urls || [];\n    return `(\n      '${this.escape(group.id)}',\n      ${stashInstanceId ? `'${this.escape(stashInstanceId)}'` : 'NULL'},\n      ${this.escapeNullable(group.name)},\n      ${this.escapeNullable(group.date)},\n      ${group.studio?.id ? `'${this.escape(group.studio.id)}'` : 'NULL'},\n      ${group.rating100 ?? 'NULL'},\n      ${duration ? Math.round(duration) : 'NULL'},\n      ${group.scene_count ?? 0},\n      ${this.escapeNullable(group.director)},\n      ${this.escapeNullable(group.synopsis)},\n      ${this.escapeNullable(JSON.stringify(urls))},\n      ${this.escapeNullable(group.front_image_path)},\n      ${this.escapeNullable(group.back_image_path)},\n      ${group.created_at ? `'${group.created_at}'` : 'NULL'},\n      ${group.updated_at ? `'${group.updated_at}'` : 'NULL'},\n      datetime('now'),\n      NULL\n    )`;\n  }).join(',\\n');\n\n  await prisma.$executeRawUnsafe(`\n    INSERT INTO CachedGroup (\n      id, stashInstanceId, name, date, studioId, rating100, duration, sceneCount,\n      director, synopsis, urls, frontImagePath, backImagePath, stashCreatedAt,\n      stashUpdatedAt, syncedAt, deletedAt\n    ) VALUES ${values}\n    ON CONFLICT(id) DO UPDATE SET\n      name = excluded.name,\n      date = excluded.date,\n      studioId = excluded.studioId,\n      rating100 = excluded.rating100,\n      duration = excluded.duration,\n      sceneCount = excluded.sceneCount,\n      director = excluded.director,\n      synopsis = excluded.synopsis,\n      urls = excluded.urls,\n      frontImagePath = excluded.frontImagePath,\n      backImagePath = excluded.backImagePath,\n      stashCreatedAt = excluded.stashCreatedAt,\n      stashUpdatedAt = excluded.stashUpdatedAt,\n      syncedAt = excluded.syncedAt,\n      deletedAt = NULL\n  `);\n}\n</code></pre></p>"},{"location":"plans/2025-12-09-json-blob-elimination/#35-update-processgalleriesbatch","title":"3.5 Update processGalleriesBatch","text":"<p>File: <code>server/services/StashSyncService.ts</code></p> <p>Location: Lines 1287-1325 (processGalleriesBatch method)</p> <p>Replace with: <pre><code>private async processGalleriesBatch(\n  galleries: Gallery[],\n  stashInstanceId?: string\n): Promise&lt;void&gt; {\n  const values = galleries.map(gallery =&gt; {\n    const folder = gallery.folder;\n    return `(\n      '${this.escape(gallery.id)}',\n      ${stashInstanceId ? `'${this.escape(stashInstanceId)}'` : 'NULL'},\n      ${this.escapeNullable(gallery.title)},\n      ${this.escapeNullable(gallery.date)},\n      ${gallery.studio?.id ? `'${this.escape(gallery.studio.id)}'` : 'NULL'},\n      ${gallery.rating100 ?? 'NULL'},\n      ${gallery.image_count ?? 0},\n      ${this.escapeNullable(gallery.details)},\n      ${this.escapeNullable(gallery.url)},\n      ${this.escapeNullable(gallery.code)},\n      ${this.escapeNullable(folder?.path)},\n      ${this.escapeNullable(gallery.cover?.paths?.thumbnail)},\n      ${gallery.created_at ? `'${gallery.created_at}'` : 'NULL'},\n      ${gallery.updated_at ? `'${gallery.updated_at}'` : 'NULL'},\n      datetime('now'),\n      NULL\n    )`;\n  }).join(',\\n');\n\n  await prisma.$executeRawUnsafe(`\n    INSERT INTO CachedGallery (\n      id, stashInstanceId, title, date, studioId, rating100, imageCount,\n      details, url, code, folderPath, coverPath, stashCreatedAt, stashUpdatedAt,\n      syncedAt, deletedAt\n    ) VALUES ${values}\n    ON CONFLICT(id) DO UPDATE SET\n      title = excluded.title,\n      date = excluded.date,\n      studioId = excluded.studioId,\n      rating100 = excluded.rating100,\n      imageCount = excluded.imageCount,\n      details = excluded.details,\n      url = excluded.url,\n      code = excluded.code,\n      folderPath = excluded.folderPath,\n      coverPath = excluded.coverPath,\n      stashCreatedAt = excluded.stashCreatedAt,\n      stashUpdatedAt = excluded.stashUpdatedAt,\n      syncedAt = excluded.syncedAt,\n      deletedAt = NULL\n  `);\n}\n</code></pre></p>"},{"location":"plans/2025-12-09-json-blob-elimination/#36-update-processimagesbatch","title":"3.6 Update processImagesBatch","text":"<p>File: <code>server/services/StashSyncService.ts</code></p> <p>Location: Lines 1407-1482 (processImagesBatch method)</p> <p>Replace with: <pre><code>private async processImagesBatch(images: any[], stashInstanceId?: string): Promise&lt;void&gt; {\n  const imageIds = images.map(i =&gt; i.id);\n\n  // Bulk delete junction records\n  await Promise.all([\n    prisma.imagePerformer.deleteMany({ where: { imageId: { in: imageIds } } }),\n    prisma.imageTag.deleteMany({ where: { imageId: { in: imageIds } } }),\n    prisma.imageGallery.deleteMany({ where: { imageId: { in: imageIds } } }),\n  ]);\n\n  // Build bulk image upsert\n  const values = images.map(image =&gt; {\n    const visualFile = image.visual_files?.[0];\n    const paths = image.paths;\n    return `(\n      '${this.escape(image.id)}',\n      ${stashInstanceId ? `'${this.escape(stashInstanceId)}'` : 'NULL'},\n      ${this.escapeNullable(image.title)},\n      ${this.escapeNullable(image.date)},\n      ${image.studio?.id ? `'${this.escape(image.studio.id)}'` : 'NULL'},\n      ${image.rating100 ?? 'NULL'},\n      ${image.o_counter ?? 0},\n      ${image.organized ? 1 : 0},\n      ${this.escapeNullable(visualFile?.path)},\n      ${visualFile?.width ?? 'NULL'},\n      ${visualFile?.height ?? 'NULL'},\n      ${visualFile?.size ?? 'NULL'},\n      ${this.escapeNullable(paths?.thumbnail)},\n      ${this.escapeNullable(paths?.preview)},\n      ${this.escapeNullable(paths?.image)},\n      ${image.created_at ? `'${image.created_at}'` : 'NULL'},\n      ${image.updated_at ? `'${image.updated_at}'` : 'NULL'},\n      datetime('now'),\n      NULL\n    )`;\n  }).join(',\\n');\n\n  await prisma.$executeRawUnsafe(`\n    INSERT INTO CachedImage (\n      id, stashInstanceId, title, date, studioId, rating100, oCounter, organized,\n      filePath, width, height, fileSize, pathThumbnail, pathPreview, pathImage,\n      stashCreatedAt, stashUpdatedAt, syncedAt, deletedAt\n    ) VALUES ${values}\n    ON CONFLICT(id) DO UPDATE SET\n      title = excluded.title,\n      date = excluded.date,\n      studioId = excluded.studioId,\n      rating100 = excluded.rating100,\n      oCounter = excluded.oCounter,\n      organized = excluded.organized,\n      filePath = excluded.filePath,\n      width = excluded.width,\n      height = excluded.height,\n      fileSize = excluded.fileSize,\n      pathThumbnail = excluded.pathThumbnail,\n      pathPreview = excluded.pathPreview,\n      pathImage = excluded.pathImage,\n      stashCreatedAt = excluded.stashCreatedAt,\n      stashUpdatedAt = excluded.stashUpdatedAt,\n      syncedAt = excluded.syncedAt,\n      deletedAt = NULL\n  `);\n\n  // Collect junction records\n  const performerRecords: string[] = [];\n  const tagRecords: string[] = [];\n  const galleryRecords: string[] = [];\n\n  for (const image of images) {\n    for (const p of image.performers || []) {\n      performerRecords.push(`('${this.escape(image.id)}', '${this.escape(p.id)}')`);\n    }\n    for (const t of image.tags || []) {\n      tagRecords.push(`('${this.escape(image.id)}', '${this.escape(t.id)}')`);\n    }\n    for (const g of image.galleries || []) {\n      galleryRecords.push(`('${this.escape(image.id)}', '${this.escape(g.id)}')`);\n    }\n  }\n\n  // Batch insert junction records\n  const inserts = [];\n\n  if (performerRecords.length &gt; 0) {\n    inserts.push(prisma.$executeRawUnsafe(\n      `INSERT OR IGNORE INTO ImagePerformer (imageId, performerId) VALUES ${performerRecords.join(',')}`\n    ));\n  }\n  if (tagRecords.length &gt; 0) {\n    inserts.push(prisma.$executeRawUnsafe(\n      `INSERT OR IGNORE INTO ImageTag (imageId, tagId) VALUES ${tagRecords.join(',')}`\n    ));\n  }\n  if (galleryRecords.length &gt; 0) {\n    inserts.push(prisma.$executeRawUnsafe(\n      `INSERT OR IGNORE INTO ImageGallery (imageId, galleryId) VALUES ${galleryRecords.join(',')}`\n    ));\n  }\n\n  await Promise.all(inserts);\n}\n</code></pre></p>"},{"location":"plans/2025-12-09-json-blob-elimination/#37-remove-transform-imports","title":"3.7 Remove Transform Imports","text":"<p>File: <code>server/services/StashSyncService.ts</code></p> <p>Location: Lines 19-27</p> <p>Replace: <pre><code>import {\n  transformGallery,\n  transformGroup,\n  transformImage,\n  transformPerformer,\n  transformScene,\n  transformStudio,\n  transformTag,\n} from \"../utils/pathMapping.js\";\n</code></pre></p> <p>With: <pre><code>// Transform functions no longer needed - URLs transformed at read time\n</code></pre></p>"},{"location":"plans/2025-12-09-json-blob-elimination/#task-4-update-cachedentityqueryservice","title":"Task 4: Update CachedEntityQueryService","text":""},{"location":"plans/2025-12-09-json-blob-elimination/#41-update-scene-query-methods","title":"4.1 Update Scene Query Methods","text":"<p>File: <code>server/services/CachedEntityQueryService.ts</code></p> <p>Location: Lines 95-101 (getAllScenes method)</p> <p>Replace: <pre><code>async getAllScenes(): Promise&lt;NormalizedScene[]&gt; {\n  const cached = await prisma.cachedScene.findMany({\n    where: { deletedAt: null },\n  });\n\n  return cached.map((c) =&gt; this.parseSceneData(c.data));\n}\n</code></pre></p> <p>With: <pre><code>async getAllScenes(): Promise&lt;NormalizedScene[]&gt; {\n  const cached = await prisma.cachedScene.findMany({\n    where: { deletedAt: null },\n  });\n\n  return cached.map((c) =&gt; this.transformScene(c));\n}\n</code></pre></p>"},{"location":"plans/2025-12-09-json-blob-elimination/#42-update-getscene-method","title":"4.2 Update getScene Method","text":"<p>File: <code>server/services/CachedEntityQueryService.ts</code></p> <p>Location: Lines 106-113 (getScene method)</p> <p>Replace: <pre><code>async getScene(id: string): Promise&lt;NormalizedScene | null&gt; {\n  const cached = await prisma.cachedScene.findFirst({\n    where: { id, deletedAt: null },\n  });\n\n  if (!cached) return null;\n  return this.parseSceneData(cached.data);\n}\n</code></pre></p> <p>With: <pre><code>async getScene(id: string): Promise&lt;NormalizedScene | null&gt; {\n  const cached = await prisma.cachedScene.findFirst({\n    where: { id, deletedAt: null },\n    include: {\n      performers: { include: { performer: true } },\n      tags: { include: { tag: true } },\n      groups: { include: { group: true } },\n      galleries: { include: { gallery: true } },\n    },\n  });\n\n  if (!cached) return null;\n  return this.transformSceneWithRelations(cached);\n}\n</code></pre></p>"},{"location":"plans/2025-12-09-json-blob-elimination/#43-add-new-transform-methods","title":"4.3 Add New Transform Methods","text":"<p>File: <code>server/services/CachedEntityQueryService.ts</code></p> <p>Location: After line 563 (replace existing parseSceneData and other parse methods)</p> <p>Replace parseSceneData and add new methods: <pre><code>// ==================== Data Transform Helpers ====================\n\nprivate transformScene(scene: any): NormalizedScene {\n  return {\n    id: scene.id,\n    title: scene.title,\n    code: scene.code,\n    date: scene.date,\n    details: scene.details,\n    rating100: scene.rating100,\n    organized: scene.organized,\n\n    // File metadata\n    files: scene.filePath ? [{\n      path: scene.filePath,\n      duration: scene.duration,\n      bit_rate: scene.fileBitRate,\n      frame_rate: scene.fileFrameRate,\n      width: scene.fileWidth,\n      height: scene.fileHeight,\n      video_codec: scene.fileVideoCodec,\n      audio_codec: scene.fileAudioCodec,\n      size: scene.fileSize ? Number(scene.fileSize) : null,\n    }] : [],\n\n    // Transformed URLs\n    paths: {\n      screenshot: this.transformUrl(scene.pathScreenshot),\n      preview: this.transformUrl(scene.pathPreview),\n      sprite: this.transformUrl(scene.pathSprite),\n      vtt: this.transformUrl(scene.pathVtt),\n      chapters_vtt: this.transformUrl(scene.pathChaptersVtt),\n      stream: this.transformUrl(scene.pathStream),\n      caption: this.transformUrl(scene.pathCaption),\n    },\n\n    // Parse streams JSON\n    sceneStreams: scene.streams\n      ? JSON.parse(scene.streams).map((s: any) =&gt; ({\n          ...s,\n          url: this.transformUrl(s.url),\n        }))\n      : [],\n\n    // Stash counters\n    o_counter: scene.oCounter ?? 0,\n    play_count: scene.playCount ?? 0,\n    play_duration: scene.playDuration ?? 0,\n\n    // Timestamps\n    created_at: scene.stashCreatedAt?.toISOString() ?? null,\n    updated_at: scene.stashUpdatedAt?.toISOString() ?? null,\n\n    // Nested entities (empty - loaded separately or via include)\n    studio: null,\n    performers: [],\n    tags: [],\n    groups: [],\n    galleries: [],\n\n    // User fields (defaults)\n    ...DEFAULT_SCENE_USER_FIELDS,\n  } as NormalizedScene;\n}\n\nprivate transformSceneWithRelations(scene: any): NormalizedScene {\n  const base = this.transformScene(scene);\n\n  // Add nested entities\n  if (scene.performers) {\n    base.performers = scene.performers.map((sp: any) =&gt;\n      this.transformPerformer(sp.performer)\n    );\n  }\n  if (scene.tags) {\n    base.tags = scene.tags.map((st: any) =&gt;\n      this.transformTag(st.tag)\n    );\n  }\n  if (scene.groups) {\n    base.groups = scene.groups.map((sg: any) =&gt; ({\n      ...this.transformGroup(sg.group),\n      scene_index: sg.sceneIndex,\n    }));\n  }\n  if (scene.galleries) {\n    base.galleries = scene.galleries.map((sg: any) =&gt;\n      this.transformGallery(sg.gallery)\n    );\n  }\n\n  return base;\n}\n\nprivate transformPerformer(performer: any): NormalizedPerformer {\n  return {\n    id: performer.id,\n    name: performer.name,\n    disambiguation: performer.disambiguation,\n    gender: performer.gender,\n    birthdate: performer.birthdate,\n    favorite: performer.favorite ?? false,\n    rating100: performer.rating100,\n    scene_count: performer.sceneCount ?? 0,\n    image_count: performer.imageCount ?? 0,\n    gallery_count: performer.galleryCount ?? 0,\n    details: performer.details,\n    alias_list: performer.aliasList ? JSON.parse(performer.aliasList) : [],\n    country: performer.country,\n    ethnicity: performer.ethnicity,\n    hair_color: performer.hairColor,\n    eye_color: performer.eyeColor,\n    height_cm: performer.heightCm,\n    weight: performer.weightKg,\n    measurements: performer.measurements,\n    tattoos: performer.tattoos,\n    piercings: performer.piercings,\n    career_length: performer.careerLength,\n    death_date: performer.deathDate,\n    url: performer.url,\n    image_path: this.transformUrl(performer.imagePath),\n    created_at: performer.stashCreatedAt?.toISOString() ?? null,\n    updated_at: performer.stashUpdatedAt?.toISOString() ?? null,\n    ...DEFAULT_PERFORMER_USER_FIELDS,\n  } as NormalizedPerformer;\n}\n\nprivate transformStudio(studio: any): NormalizedStudio {\n  return {\n    id: studio.id,\n    name: studio.name,\n    parent_studio: studio.parentId ? { id: studio.parentId } : null,\n    favorite: studio.favorite ?? false,\n    rating100: studio.rating100,\n    scene_count: studio.sceneCount ?? 0,\n    image_count: studio.imageCount ?? 0,\n    gallery_count: studio.galleryCount ?? 0,\n    details: studio.details,\n    url: studio.url,\n    image_path: this.transformUrl(studio.imagePath),\n    created_at: studio.stashCreatedAt?.toISOString() ?? null,\n    updated_at: studio.stashUpdatedAt?.toISOString() ?? null,\n    ...DEFAULT_STUDIO_USER_FIELDS,\n  } as NormalizedStudio;\n}\n\nprivate transformTag(tag: any): NormalizedTag {\n  return {\n    id: tag.id,\n    name: tag.name,\n    favorite: tag.favorite ?? false,\n    scene_count: tag.sceneCount ?? 0,\n    image_count: tag.imageCount ?? 0,\n    description: tag.description,\n    parents: tag.parentIds ? JSON.parse(tag.parentIds).map((id: string) =&gt; ({ id })) : [],\n    image_path: this.transformUrl(tag.imagePath),\n    created_at: tag.stashCreatedAt?.toISOString() ?? null,\n    updated_at: tag.stashUpdatedAt?.toISOString() ?? null,\n    ...DEFAULT_TAG_USER_FIELDS,\n  } as NormalizedTag;\n}\n\nprivate transformGroup(group: any): NormalizedGroup {\n  return {\n    id: group.id,\n    name: group.name,\n    date: group.date,\n    studio: group.studioId ? { id: group.studioId } : null,\n    rating100: group.rating100,\n    duration: group.duration,\n    scene_count: group.sceneCount ?? 0,\n    director: group.director,\n    synopsis: group.synopsis,\n    urls: group.urls ? JSON.parse(group.urls) : [],\n    front_image_path: this.transformUrl(group.frontImagePath),\n    back_image_path: this.transformUrl(group.backImagePath),\n    created_at: group.stashCreatedAt?.toISOString() ?? null,\n    updated_at: group.stashUpdatedAt?.toISOString() ?? null,\n    ...DEFAULT_GROUP_USER_FIELDS,\n  } as NormalizedGroup;\n}\n\nprivate transformGallery(gallery: any): NormalizedGallery {\n  return {\n    id: gallery.id,\n    title: gallery.title,\n    date: gallery.date,\n    studio: gallery.studioId ? { id: gallery.studioId } : null,\n    rating100: gallery.rating100,\n    image_count: gallery.imageCount ?? 0,\n    details: gallery.details,\n    url: gallery.url,\n    code: gallery.code,\n    folder: gallery.folderPath ? { path: gallery.folderPath } : null,\n    cover: gallery.coverPath ? { paths: { thumbnail: this.transformUrl(gallery.coverPath) } } : null,\n    created_at: gallery.stashCreatedAt?.toISOString() ?? null,\n    updated_at: gallery.stashUpdatedAt?.toISOString() ?? null,\n    ...DEFAULT_GALLERY_USER_FIELDS,\n  } as NormalizedGallery;\n}\n\nprivate transformUrl(path: string | null): string | null {\n  if (!path) return null;\n  // Replace Stash host with proxy prefix\n  return `/api/proxy/stash${path}`;\n}\n</code></pre></p>"},{"location":"plans/2025-12-09-json-blob-elimination/#44-update-all-other-query-methods","title":"4.4 Update All Other Query Methods","text":"<p>File: <code>server/services/CachedEntityQueryService.ts</code></p> <p>Update all methods that use <code>parseXxxData</code> to use the new <code>transformXxx</code> methods:</p> <ul> <li><code>getScenesByIds</code>: Use <code>this.transformScene(c)</code> instead of <code>this.parseSceneData(c.data)</code></li> <li><code>getAllPerformers</code>: Use <code>this.transformPerformer(c)</code> instead of <code>this.parsePerformerData(c.data)</code></li> <li><code>getPerformer</code>: Use <code>this.transformPerformer(cached)</code> instead of <code>this.parsePerformerData(cached.data)</code></li> <li><code>getPerformersByIds</code>: Use <code>this.transformPerformer(c)</code> instead of <code>this.parsePerformerData(c.data)</code></li> <li>(Similar for all other entity types)</li> </ul>"},{"location":"plans/2025-12-09-json-blob-elimination/#task-5-clean-up","title":"Task 5: Clean Up","text":""},{"location":"plans/2025-12-09-json-blob-elimination/#51-remove-pathmapping-transform-functions","title":"5.1 Remove pathMapping Transform Functions","text":"<p>File: <code>server/utils/pathMapping.ts</code></p> <p>Remove <code>transformScene</code>, <code>transformPerformer</code>, <code>transformStudio</code>, <code>transformTag</code>, <code>transformGroup</code>, <code>transformGallery</code>, <code>transformImage</code> functions as they're no longer needed.</p> <p>Keep only the path mapping utilities for file path translation.</p>"},{"location":"plans/2025-12-09-json-blob-elimination/#52-delete-old-parse-methods","title":"5.2 Delete Old Parse Methods","text":"<p>File: <code>server/services/CachedEntityQueryService.ts</code></p> <p>Remove the old methods: - <code>parseSceneData</code> - <code>parsePerformerData</code> - <code>parseStudioData</code> - <code>parseTagData</code> - <code>parseGalleryData</code> - <code>parseGroupData</code></p>"},{"location":"plans/2025-12-09-json-blob-elimination/#task-6-test-and-verify","title":"Task 6: Test and Verify","text":""},{"location":"plans/2025-12-09-json-blob-elimination/#61-run-type-check","title":"6.1 Run Type Check","text":"<pre><code>cd server &amp;&amp; npx tsc --noEmit\n</code></pre> <p>Expected: No TypeScript errors</p>"},{"location":"plans/2025-12-09-json-blob-elimination/#62-run-lint","title":"6.2 Run Lint","text":"<pre><code>cd server &amp;&amp; npm run lint\n</code></pre> <p>Expected: No lint errors</p>"},{"location":"plans/2025-12-09-json-blob-elimination/#63-test-full-sync","title":"6.3 Test Full Sync","text":"<pre><code>docker-compose up -d\ndocker-compose logs -f peek-server\n</code></pre> <p>Expected: - Sync completes without errors - Sync time &lt; 10 minutes for 22k scenes - All entity types show correct counts</p>"},{"location":"plans/2025-12-09-json-blob-elimination/#64-test-query-responses","title":"6.4 Test Query Responses","text":"<p>Test API endpoints return correct data: - GET /api/library/scenes - Verify scenes have all fields - GET /api/library/scenes/:id - Verify nested entities load - GET /api/library/performers - Verify performers have fields - GET /api/library/studios - Verify studios have fields</p>"},{"location":"plans/2025-12-09-json-blob-elimination/#rollback-plan","title":"Rollback Plan","text":"<p>If issues arise:</p> <ol> <li>Revert migration: <code>npx prisma migrate reset</code></li> <li>Restore old code from git</li> <li>Re-run sync with old code</li> </ol>"},{"location":"plans/2025-12-09-json-blob-elimination/#summary","title":"Summary","text":"<p>Total Tasks: 6 major tasks with ~25 sub-tasks</p> <p>Key Changes: 1. Schema: Add ~50 new columns across 7 entity types 2. Sync: Replace individual Prisma upserts with bulk SQL 3. Query: Transform URLs at read time instead of sync time 4. Remove: JSON blob column and transform functions</p> <p>Expected Outcome: - Sync time: 3.6 hours \u2192 ~5 minutes - DB operations per batch: ~500 \u2192 ~9 - Query performance: No JSON.parse overhead</p>"},{"location":"plans/2025-12-09-performance-optimization-final/","title":"Brainstorm: Final Performance Optimization Pass","text":""},{"location":"plans/2025-12-09-performance-optimization-final/#context","title":"Context","text":"<p>This branch (<code>feature/cache-scalability-investigation</code>) has made significant progress on SQLite performance. We need a final pass to ensure sub-second page loads throughout the app.</p>"},{"location":"plans/2025-12-09-performance-optimization-final/#background-documents-to-read","title":"Background Documents to Read","text":"<p>Before brainstorming, read these documents to understand the journey:</p> <ol> <li><code>docs/plans/2025-12-09-sqlite-performance-brainstorm.md</code> - Original problem statement</li> <li><code>docs/plans/2025-12-09-sqlite-performance-design.md</code> - Solution implemented (named volumes)</li> <li><code>docs/design/cache-scalability-brainstorm.md</code> - Earlier design exploration</li> <li><code>docs/design/cache-scalability-plan.md</code> - Original implementation plan</li> </ol>"},{"location":"plans/2025-12-09-performance-optimization-final/#current-state","title":"Current State","text":"<p>What's working: - Named Docker volumes fix Windows I/O bottleneck (100x improvement) - SceneQueryBuilder pushes filtering/sorting to SQL (no more in-memory filtering) - Basic scene browsing queries now ~350-500ms (was 8-18 seconds)</p> <p>What's not working: - Scene cards show \"Unknown Scene\" instead of filename fallback (fixed: added <code>basename</code> to files) - Browser becomes non-responsive after loading several pages - Images on cards load slowly or hang - Some operations may still be hitting slow paths</p>"},{"location":"plans/2025-12-09-performance-optimization-final/#key-files-to-examine","title":"Key Files to Examine","text":"<p>Query Layer: - <code>server/services/SceneQueryBuilder.ts</code> - SQL query builder for scenes - <code>server/services/CachedEntityQueryService.ts</code> - Prisma-based queries (old path) - <code>server/controllers/library/scenes.ts</code> - Scenes API endpoint</p> <p>Data Layer: - <code>server/prisma/schema.prisma</code> - Database schema and indexes - <code>server/services/StashCacheManager.ts</code> - Sync from Stash</p> <p>Frontend: - <code>client/src/utils/format.js</code> - <code>getSceneTitle()</code> fallback logic - <code>client/src/components/ui/CardComponents.jsx</code> - Scene card rendering - <code>client/src/services/api.js</code> - API client</p>"},{"location":"plans/2025-12-09-performance-optimization-final/#benchmark-script","title":"Benchmark Script","text":"<p>Run the benchmark to establish baselines: <pre><code>cd server\nnpx ts-node scripts/benchmark-performance.ts\n</code></pre></p> <p>Target: All operations &lt;500ms</p>"},{"location":"plans/2025-12-09-performance-optimization-final/#issues-to-investigate","title":"Issues to Investigate","text":"<ol> <li>Image loading performance</li> <li>Are proxy requests to Stash slow?</li> <li>Is there connection pooling?</li> <li> <p>Are images being loaded inefficiently (all at once vs lazy)?</p> </li> <li> <p>Browser hanging after navigation</p> </li> <li>Memory leak from keeping old data?</li> <li>Too many concurrent requests?</li> <li> <p>React re-render storms?</p> </li> <li> <p>Query paths not using SQL builder</p> </li> <li>Which endpoints still use old Prisma queries?</li> <li>Carousel endpoint performance?</li> <li> <p>Performer/studio detail pages?</p> </li> <li> <p>Missing optimizations</p> </li> <li>Connection pooling for SQLite?</li> <li>PRAGMA settings for read-heavy workload?</li> <li>Response caching for static data (studios, tags)?</li> </ol>"},{"location":"plans/2025-12-09-performance-optimization-final/#success-criteria","title":"Success Criteria","text":"<ul> <li>Scenes grid: &lt;500ms to load 24 scenes</li> <li>Page navigation: &lt;500ms to switch pages</li> <li>Detail pages: &lt;500ms to load performer/studio with their scenes</li> <li>Carousel: &lt;500ms to load home page carousels</li> <li>Image loading: Progressive, doesn't block UI</li> <li>Browser: Stays responsive during navigation</li> </ul>"},{"location":"plans/2025-12-09-performance-optimization-final/#questions-to-answer","title":"Questions to Answer","text":"<ol> <li>What's causing the browser to become non-responsive?</li> <li>Are there API endpoints that bypass the fast SQL path?</li> <li>What frontend optimizations are needed (lazy loading, virtualization)?</li> <li>Are there quick SQLite/Prisma tuning wins still available?</li> <li>Is the image proxy a bottleneck?</li> </ol>"},{"location":"plans/2025-12-09-performance-optimization-final/#deliverables","title":"Deliverables","text":"<ol> <li>Root cause analysis of remaining performance issues</li> <li>Prioritized list of fixes with effort estimates</li> <li>Implementation plan for sub-second page loads</li> </ol>"},{"location":"plans/2025-12-09-performance-optimization/","title":"Scene Query Performance Optimization Implementation Plan","text":"<p>For Claude: REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.</p> <p>Goal: Reduce scene browse query time from 22+ seconds to under 1 second by pushing pagination to SQLite and eliminating redundant data transfer.</p> <p>Architecture: Replace the current \"load all 22k scenes \u2192 filter in JS\" pattern with database-level pagination. Exclude heavy columns (<code>streams</code>, <code>data</code>) from browse queries. Generate stream URLs on-demand only when playing a scene.</p> <p>Tech Stack: Prisma 6, SQLite, TypeScript, Express</p>"},{"location":"plans/2025-12-09-performance-optimization/#background","title":"Background","text":"<p>Current baseline (measured): - SQLite query: 19.9 seconds (fetching 22k rows with 4.4KB <code>streams</code> column each) - Transform to JS objects: 2.7 seconds - Total: 22.8 seconds per request</p> <p>Root causes: 1. <code>getAllScenes()</code> fetches every row on every request 2. <code>streams</code> column contains redundant JSON (~96MB total) - same 13 URLs per scene, only ID differs 3. <code>data</code> column is legacy JSON blob (empty but still transferred)</p>"},{"location":"plans/2025-12-09-performance-optimization/#task-1-add-browse_select-constant","title":"Task 1: Add BROWSE_SELECT Constant","text":"<p>Files: - Modify: <code>server/services/CachedEntityQueryService.ts:88-111</code></p> <p>Step 1: Add the select constant at class level</p> <p>Add this after line 88 (inside the class, before the first method):</p> <pre><code>  // Columns to select for browse queries (excludes heavy streams/data columns)\n  private readonly BROWSE_SELECT = {\n    id: true,\n    stashInstanceId: true,\n    title: true,\n    code: true,\n    date: true,\n    studioId: true,\n    rating100: true,\n    duration: true,\n    organized: true,\n    details: true,\n    filePath: true,\n    fileBitRate: true,\n    fileFrameRate: true,\n    fileWidth: true,\n    fileHeight: true,\n    fileVideoCodec: true,\n    fileAudioCodec: true,\n    fileSize: true,\n    pathScreenshot: true,\n    pathPreview: true,\n    pathSprite: true,\n    pathVtt: true,\n    pathChaptersVtt: true,\n    pathStream: true,\n    pathCaption: true,\n    // Explicitly NOT selecting: streams, data\n    oCounter: true,\n    playCount: true,\n    playDuration: true,\n    stashCreatedAt: true,\n    stashUpdatedAt: true,\n    syncedAt: true,\n    deletedAt: true,\n  } as const;\n</code></pre> <p>Step 2: Verify TypeScript compiles</p> <p>Run: <code>cd server &amp;&amp; npx tsc --noEmit</code> Expected: No errors</p> <p>Step 3: Commit</p> <pre><code>git add server/services/CachedEntityQueryService.ts\ngit commit -m \"feat: add BROWSE_SELECT constant for optimized scene queries\"\n</code></pre>"},{"location":"plans/2025-12-09-performance-optimization/#task-2-create-transformsceneforbrowse-method","title":"Task 2: Create transformSceneForBrowse Method","text":"<p>Files: - Modify: <code>server/services/CachedEntityQueryService.ts</code> (after transformScene method, around line 674)</p> <p>Step 1: Add the new transform method</p> <p>Add this method after <code>transformScene</code> (around line 674):</p> <pre><code>  /**\n   * Transform scene for browse queries (no streams - generated on demand)\n   */\n  private transformSceneForBrowse(scene: any): NormalizedScene {\n    return {\n      // User fields (defaults first, then override with actual values)\n      ...DEFAULT_SCENE_USER_FIELDS,\n\n      id: scene.id,\n      title: scene.title,\n      code: scene.code,\n      date: scene.date,\n      details: scene.details,\n      rating100: scene.rating100,\n      organized: scene.organized,\n\n      // File metadata\n      files: scene.filePath ? [{\n        path: scene.filePath,\n        duration: scene.duration,\n        bit_rate: scene.fileBitRate,\n        frame_rate: scene.fileFrameRate,\n        width: scene.fileWidth,\n        height: scene.fileHeight,\n        video_codec: scene.fileVideoCodec,\n        audio_codec: scene.fileAudioCodec,\n        size: scene.fileSize ? Number(scene.fileSize) : null,\n      }] : [],\n\n      // Transformed URLs\n      paths: {\n        screenshot: this.transformUrl(scene.pathScreenshot),\n        preview: this.transformUrl(scene.pathPreview),\n        sprite: this.transformUrl(scene.pathSprite),\n        vtt: this.transformUrl(scene.pathVtt),\n        chapters_vtt: this.transformUrl(scene.pathChaptersVtt),\n        stream: this.transformUrl(scene.pathStream),\n        caption: this.transformUrl(scene.pathCaption),\n      },\n\n      // Empty sceneStreams for browse - generated on demand for playback\n      sceneStreams: [],\n\n      // Stash counters (override defaults)\n      o_counter: scene.oCounter ?? 0,\n      play_count: scene.playCount ?? 0,\n      play_duration: scene.playDuration ?? 0,\n\n      // Timestamps\n      created_at: scene.stashCreatedAt?.toISOString() ?? null,\n      updated_at: scene.stashUpdatedAt?.toISOString() ?? null,\n\n      // Nested entities (empty - loaded separately or via include)\n      studio: null,\n      performers: [],\n      tags: [],\n      groups: [],\n      galleries: [],\n    } as unknown as NormalizedScene;\n  }\n</code></pre> <p>Step 2: Verify TypeScript compiles</p> <p>Run: <code>cd server &amp;&amp; npx tsc --noEmit</code> Expected: No errors</p> <p>Step 3: Commit</p> <pre><code>git add server/services/CachedEntityQueryService.ts\ngit commit -m \"feat: add transformSceneForBrowse method without streams\"\n</code></pre>"},{"location":"plans/2025-12-09-performance-optimization/#task-3-update-getallscenes-to-use-browse_select","title":"Task 3: Update getAllScenes to Use BROWSE_SELECT","text":"<p>Files: - Modify: <code>server/services/CachedEntityQueryService.ts:95-111</code></p> <p>Step 1: Update the getAllScenes method</p> <p>Replace the current <code>getAllScenes</code> method with:</p> <pre><code>  async getAllScenes(): Promise&lt;NormalizedScene[]&gt; {\n    const startTotal = Date.now();\n\n    const queryStart = Date.now();\n    const cached = await prisma.cachedScene.findMany({\n      where: { deletedAt: null },\n      select: this.BROWSE_SELECT,\n    });\n    const queryTime = Date.now() - queryStart;\n\n    const transformStart = Date.now();\n    const result = cached.map((c) =&gt; this.transformSceneForBrowse(c));\n    const transformTime = Date.now() - transformStart;\n\n    logger.info(`getAllScenes: query=${queryTime}ms, transform=${transformTime}ms, total=${Date.now() - startTotal}ms, count=${cached.length}`);\n\n    return result;\n  }\n</code></pre> <p>Step 2: Verify TypeScript compiles</p> <p>Run: <code>cd server &amp;&amp; npx tsc --noEmit</code> Expected: No errors</p> <p>Step 3: Commit</p> <pre><code>git add server/services/CachedEntityQueryService.ts\ngit commit -m \"feat: getAllScenes now uses BROWSE_SELECT (excludes streams/data)\"\n</code></pre>"},{"location":"plans/2025-12-09-performance-optimization/#task-4-add-generatescenestreams-helper","title":"Task 4: Add generateSceneStreams Helper","text":"<p>Files: - Modify: <code>server/services/CachedEntityQueryService.ts</code> (add before transformScene method)</p> <p>Step 1: Add the stream URL generator</p> <p>Add this method before <code>transformScene</code>:</p> <pre><code>  /**\n   * Generate scene stream URLs on-demand\n   * All scenes have the same stream formats - only the ID varies\n   * This eliminates storing ~4.4KB of redundant JSON per scene\n   */\n  private generateSceneStreams(sceneId: string): Array&lt;{url: string; mime_type: string; label: string}&gt; {\n    const formats = [\n      { ext: '', mime: 'video/mp4', label: 'Direct stream', resolution: null },\n      { ext: '.mp4', mime: 'video/mp4', label: 'MP4', resolution: 'ORIGINAL' },\n      { ext: '.mp4', mime: 'video/mp4', label: 'MP4 Standard (480p)', resolution: 'STANDARD' },\n      { ext: '.mp4', mime: 'video/mp4', label: 'MP4 Low (240p)', resolution: 'LOW' },\n      { ext: '.webm', mime: 'video/webm', label: 'WEBM', resolution: 'ORIGINAL' },\n      { ext: '.webm', mime: 'video/webm', label: 'WEBM Standard (480p)', resolution: 'STANDARD' },\n      { ext: '.webm', mime: 'video/webm', label: 'WEBM Low (240p)', resolution: 'LOW' },\n      { ext: '.m3u8', mime: 'application/vnd.apple.mpegurl', label: 'HLS', resolution: 'ORIGINAL' },\n      { ext: '.m3u8', mime: 'application/vnd.apple.mpegurl', label: 'HLS Standard (480p)', resolution: 'STANDARD' },\n      { ext: '.m3u8', mime: 'application/vnd.apple.mpegurl', label: 'HLS Low (240p)', resolution: 'LOW' },\n      { ext: '.mpd', mime: 'application/dash+xml', label: 'DASH', resolution: 'ORIGINAL' },\n      { ext: '.mpd', mime: 'application/dash+xml', label: 'DASH Standard (480p)', resolution: 'STANDARD' },\n      { ext: '.mpd', mime: 'application/dash+xml', label: 'DASH Low (240p)', resolution: 'LOW' },\n    ];\n\n    return formats.map(f =&gt; {\n      const basePath = `/scene/${sceneId}/stream${f.ext}`;\n      const fullPath = f.resolution ? `${basePath}?resolution=${f.resolution}` : basePath;\n      return {\n        url: `/api/proxy/stash?path=${encodeURIComponent(fullPath)}`,\n        mime_type: f.mime,\n        label: f.label,\n      };\n    });\n  }\n</code></pre> <p>Step 2: Verify TypeScript compiles</p> <p>Run: <code>cd server &amp;&amp; npx tsc --noEmit</code> Expected: No errors</p> <p>Step 3: Commit</p> <pre><code>git add server/services/CachedEntityQueryService.ts\ngit commit -m \"feat: add generateSceneStreams helper for on-demand URL generation\"\n</code></pre>"},{"location":"plans/2025-12-09-performance-optimization/#task-5-update-getscene-to-generate-streams-on-demand","title":"Task 5: Update getScene to Generate Streams On-Demand","text":"<p>Files: - Modify: <code>server/services/CachedEntityQueryService.ts</code> - the <code>getScene</code> method (around line 116)</p> <p>Step 1: Find and read current getScene method</p> <p>The current <code>getScene</code> method should be around line 116. It needs to generate streams instead of reading from DB.</p> <p>Step 2: Update transformScene to use generateSceneStreams</p> <p>Modify the <code>transformScene</code> method to generate streams instead of parsing from DB. Change this section:</p> <pre><code>      // Parse streams JSON\n      sceneStreams: scene.streams\n        ? JSON.parse(scene.streams).map((s: any) =&gt; ({\n            ...s,\n            url: this.transformUrl(s.url),\n          }))\n        : [],\n</code></pre> <p>To:</p> <pre><code>      // Generate streams on-demand (no longer stored in DB)\n      sceneStreams: this.generateSceneStreams(scene.id),\n</code></pre> <p>Step 3: Verify TypeScript compiles</p> <p>Run: <code>cd server &amp;&amp; npx tsc --noEmit</code> Expected: No errors</p> <p>Step 4: Commit</p> <pre><code>git add server/services/CachedEntityQueryService.ts\ngit commit -m \"feat: getScene now generates streams on-demand\"\n</code></pre>"},{"location":"plans/2025-12-09-performance-optimization/#task-6-run-linting","title":"Task 6: Run Linting","text":"<p>Step 1: Run ESLint on modified files</p> <p>Run: <code>cd server &amp;&amp; npm run lint</code> Expected: No errors (or only pre-existing warnings)</p> <p>Step 2: Fix any lint errors if present</p> <p>If there are errors, fix them.</p> <p>Step 3: Commit any lint fixes</p> <pre><code>git add server/services/CachedEntityQueryService.ts\ngit commit -m \"fix: lint fixes for CachedEntityQueryService\"\n</code></pre>"},{"location":"plans/2025-12-09-performance-optimization/#task-7-build-and-test-phase-1","title":"Task 7: Build and Test Phase 1","text":"<p>Step 1: Rebuild Docker containers</p> <p>Run: <code>docker-compose up --build -d</code> Expected: Containers start successfully</p> <p>Step 2: Wait for server to be ready</p> <p>Run: <code>docker-compose logs -f peek-server 2&gt;&amp;1 | head -50</code> Expected: See \"Peek Server Ready\" message</p> <p>Step 3: Test scenes page load</p> <p>Open browser to Peek app, navigate to Scenes page. Watch server logs for timing:</p> <p>Run: <code>docker-compose logs --tail=50 peek-server 2&gt;&amp;1 | grep -E \"(getAllScenes|findScenes)\"</code></p> <p>Step 4: Document results</p> <p>Expected improvement: Query time should drop significantly (from ~20s to ~2-5s) due to excluding <code>streams</code> column.</p> <p>Record the new timings in this format: <pre><code>getAllScenes: query=XXXXms, transform=XXXXms, total=XXXXms\nfindScenes: TOTAL request took XXXXms\n</code></pre></p>"},{"location":"plans/2025-12-09-performance-optimization/#task-8-test-scene-detail-playback","title":"Task 8: Test Scene Detail Playback","text":"<p>Step 1: Navigate to a scene detail page</p> <p>Click on any scene card to open the scene detail/player page.</p> <p>Step 2: Verify video player shows stream options</p> <p>The video player source selector should show all stream formats: - Direct stream - MP4 / MP4 Standard / MP4 Low - WEBM / WEBM Standard / WEBM Low - HLS / HLS Standard / HLS Low - DASH / DASH Standard / DASH Low</p> <p>Step 3: Test playback</p> <p>Click play and verify the video streams correctly.</p> <p>Step 4: If playback fails, check logs</p> <p>Run: <code>docker-compose logs --tail=100 peek-server 2&gt;&amp;1 | grep -i error</code></p> <p>If there are issues with stream URLs, we may need to adjust the <code>generateSceneStreams</code> method.</p>"},{"location":"plans/2025-12-09-performance-optimization/#task-9-commit-phase-1-complete","title":"Task 9: Commit Phase 1 Complete","text":"<p>Step 1: Verify all changes are committed</p> <p>Run: <code>git status</code> Expected: Clean working directory</p> <p>Step 2: If uncommitted changes exist, commit them</p> <pre><code>git add -A\ngit commit -m \"feat: phase 1 complete - exclude streams from browse queries\"\n</code></pre>"},{"location":"plans/2025-12-09-performance-optimization/#phase-2-tasks-database-level-pagination","title":"Phase 2 Tasks (Database-Level Pagination)","text":"<p>These tasks will be detailed in a follow-up plan after Phase 1 results are measured. The approach depends on how much improvement we get from Phase 1:</p> <ul> <li>If Phase 1 gets us to &lt;5 seconds: Phase 2 adds pagination for further improvement</li> <li>If Phase 1 still shows &gt;10 seconds: We need to investigate other bottlenecks first</li> </ul> <p>Phase 2 will include: - Task 10: Add getScenesPagedWithFilters method - Task 11: Add filter-to-Prisma-where conversion - Task 12: Update findScenes controller to use paginated queries - Task 13: Update carousel queries - Task 14: Schema migration to drop streams/data columns</p>"},{"location":"plans/2025-12-09-performance-optimization/#verification-checklist","title":"Verification Checklist","text":"<p>After all tasks: - [ ] TypeScript compiles: <code>cd server &amp;&amp; npx tsc --noEmit</code> - [ ] Linting passes: <code>cd server &amp;&amp; npm run lint</code> - [ ] Scenes page loads in &lt;5 seconds (Phase 1 target) - [ ] Scene detail page loads correctly - [ ] Video playback works with all stream formats - [ ] All commits are clean and atomic</p>"},{"location":"plans/2025-12-09-sql-native-scene-queries/","title":"SQL-Native Scene Queries Implementation Plan","text":"<p>For Claude: REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.</p> <p>Goal: Replace in-memory scene filtering with SQL queries to achieve &lt;200ms response times at any scale.</p> <p>Architecture: New <code>SceneQueryBuilder</code> service constructs parameterized SQL with JOINs for user data and subqueries for entity filters. All filtering, sorting, and pagination happens at the database level.</p> <p>Tech Stack: Prisma 6 with <code>$queryRawUnsafe</code>, SQLite, TypeScript</p>"},{"location":"plans/2025-12-09-sql-native-scene-queries/#task-1-create-scenequerybuilder-types-and-interface","title":"Task 1: Create SceneQueryBuilder Types and Interface","text":"<p>Files: - Create: <code>server/services/SceneQueryBuilder.ts</code> - Reference: <code>server/types/peekFilters.ts</code> - Reference: <code>server/types/entities.ts</code></p> <p>Step 1: Create the file with types and interface</p> <pre><code>/**\n * SceneQueryBuilder - SQL-native scene querying\n *\n * Builds parameterized SQL queries for scene filtering, sorting, and pagination.\n * Eliminates the need to load all scenes into memory.\n */\nimport type { PeekSceneFilter, NormalizedScene } from \"../types/index.js\";\nimport prisma from \"../prisma/singleton.js\";\nimport { logger } from \"../utils/logger.js\";\n\n// Filter clause builder result\ninterface FilterClause {\n  sql: string;\n  params: (string | number | boolean)[];\n}\n\n// Query builder options\nexport interface SceneQueryOptions {\n  userId: number;\n  filters?: PeekSceneFilter;\n  excludedSceneIds?: Set&lt;string&gt;;\n  sort: string;\n  sortDirection: \"ASC\" | \"DESC\";\n  page: number;\n  perPage: number;\n  randomSeed?: number;\n}\n\n// Query result\nexport interface SceneQueryResult {\n  scenes: NormalizedScene[];\n  total: number;\n}\n\n/**\n * Builds and executes SQL queries for scene filtering\n */\nclass SceneQueryBuilder {\n  /**\n   * Execute a scene query with the given options\n   */\n  async execute(options: SceneQueryOptions): Promise&lt;SceneQueryResult&gt; {\n    // TODO: Implement in subsequent tasks\n    throw new Error(\"Not implemented\");\n  }\n}\n\n// Export singleton instance\nexport const sceneQueryBuilder = new SceneQueryBuilder();\n</code></pre> <p>Step 2: Verify file compiles</p> <p>Run: <code>cd server &amp;&amp; npx tsc --noEmit</code> Expected: No errors related to SceneQueryBuilder.ts</p> <p>Step 3: Commit</p> <pre><code>git add server/services/SceneQueryBuilder.ts\ngit commit -m \"feat: add SceneQueryBuilder types and interface skeleton\"\n</code></pre>"},{"location":"plans/2025-12-09-sql-native-scene-queries/#task-2-implement-base-query-structure","title":"Task 2: Implement Base Query Structure","text":"<p>Files: - Modify: <code>server/services/SceneQueryBuilder.ts</code></p> <p>Step 1: Add column selection and base FROM/JOIN clauses</p> <p>Add these private properties and methods to the <code>SceneQueryBuilder</code> class:</p> <pre><code>class SceneQueryBuilder {\n  // Column list for SELECT - all CachedScene fields plus user data\n  private readonly SELECT_COLUMNS = `\n    s.id, s.title, s.code, s.date, s.studioId, s.rating100 AS stashRating100,\n    s.duration, s.organized, s.details, s.filePath, s.fileBitRate,\n    s.fileFrameRate, s.fileWidth, s.fileHeight, s.fileVideoCodec,\n    s.fileAudioCodec, s.fileSize, s.pathScreenshot, s.pathPreview,\n    s.pathSprite, s.pathVtt, s.pathChaptersVtt, s.pathStream, s.pathCaption,\n    s.oCounter AS stashOCounter, s.playCount AS stashPlayCount,\n    s.playDuration AS stashPlayDuration, s.stashCreatedAt, s.stashUpdatedAt,\n    r.rating AS userRating, r.favorite AS userFavorite,\n    w.playCount AS userPlayCount, w.playDuration AS userPlayDuration,\n    w.lastPlayedAt AS userLastPlayedAt, w.oCount AS userOCount,\n    w.resumeTime AS userResumeTime, w.oHistory AS userOHistory,\n    w.playHistory AS userPlayHistory\n  `.trim();\n\n  // Base FROM clause with user data JOINs\n  private buildFromClause(userId: number): { sql: string; params: number[] } {\n    return {\n      sql: `\n        FROM CachedScene s\n        LEFT JOIN SceneRating r ON s.id = r.sceneId AND r.userId = ?\n        LEFT JOIN WatchHistory w ON s.id = w.sceneId AND w.userId = ?\n      `.trim(),\n      params: [userId, userId],\n    };\n  }\n\n  // Base WHERE clause (always filter deleted)\n  private buildBaseWhere(): FilterClause {\n    return {\n      sql: \"s.deletedAt IS NULL\",\n      params: [],\n    };\n  }\n\n  async execute(options: SceneQueryOptions): Promise&lt;SceneQueryResult&gt; {\n    const startTime = Date.now();\n    const { userId, page, perPage } = options;\n\n    // Build FROM clause\n    const fromClause = this.buildFromClause(userId);\n\n    // Build WHERE clause (just base for now)\n    const whereClause = this.buildBaseWhere();\n\n    // Build full query\n    const offset = (page - 1) * perPage;\n    const sql = `\n      SELECT ${this.SELECT_COLUMNS}\n      ${fromClause.sql}\n      WHERE ${whereClause.sql}\n      ORDER BY s.stashCreatedAt DESC\n      LIMIT ? OFFSET ?\n    `;\n\n    const params = [...fromClause.params, ...whereClause.params, perPage, offset];\n\n    logger.info(\"SceneQueryBuilder.execute\", {\n      sql: sql.replace(/\\s+/g, \" \").trim(),\n      paramCount: params.length,\n    });\n\n    // Execute query\n    const rows = await prisma.$queryRawUnsafe&lt;any[]&gt;(sql, ...params);\n\n    // Count query (same WHERE, no LIMIT/OFFSET)\n    const countSql = `\n      SELECT COUNT(DISTINCT s.id) as total\n      ${fromClause.sql}\n      WHERE ${whereClause.sql}\n    `;\n    const countParams = [...fromClause.params, ...whereClause.params];\n    const countResult = await prisma.$queryRawUnsafe&lt;{ total: number }[]&gt;(\n      countSql,\n      ...countParams\n    );\n    const total = Number(countResult[0]?.total || 0);\n\n    // Transform rows (placeholder - just return raw for now)\n    const scenes = rows.map((row) =&gt; this.transformRow(row));\n\n    logger.info(\"SceneQueryBuilder.execute complete\", {\n      queryTimeMs: Date.now() - startTime,\n      resultCount: scenes.length,\n      total,\n    });\n\n    return { scenes, total };\n  }\n\n  // Placeholder transform - will be implemented in Task 3\n  private transformRow(row: any): NormalizedScene {\n    return row as NormalizedScene;\n  }\n}\n</code></pre> <p>Step 2: Verify file compiles</p> <p>Run: <code>cd server &amp;&amp; npx tsc --noEmit</code> Expected: No errors</p> <p>Step 3: Commit</p> <pre><code>git add server/services/SceneQueryBuilder.ts\ngit commit -m \"feat: add base query structure with FROM/JOIN clauses\"\n</code></pre>"},{"location":"plans/2025-12-09-sql-native-scene-queries/#task-3-implement-row-transformation","title":"Task 3: Implement Row Transformation","text":"<p>Files: - Modify: <code>server/services/SceneQueryBuilder.ts</code></p> <p>Step 1: Write test for row transformation</p> <p>Create test file <code>server/tests/services/SceneQueryBuilder.test.ts</code>:</p> <pre><code>import { describe, it, expect } from \"vitest\";\n\n// We'll test the transform logic directly once exported\ndescribe(\"SceneQueryBuilder\", () =&gt; {\n  describe(\"transformRow\", () =&gt; {\n    it(\"should transform a database row to NormalizedScene\", () =&gt; {\n      const row = {\n        id: \"123\",\n        title: \"Test Scene\",\n        code: \"ABC123\",\n        date: \"2024-01-15\",\n        studioId: \"studio_1\",\n        stashRating100: 85,\n        duration: 3600,\n        organized: 1,\n        details: \"Test details\",\n        filePath: \"/path/to/file.mp4\",\n        fileBitRate: 8000000,\n        fileFrameRate: 29.97,\n        fileWidth: 1920,\n        fileHeight: 1080,\n        fileVideoCodec: \"h264\",\n        fileAudioCodec: \"aac\",\n        fileSize: BigInt(2147483648),\n        pathScreenshot: \"/screenshot.jpg\",\n        pathPreview: \"/preview.mp4\",\n        pathSprite: \"/sprite.jpg\",\n        pathVtt: \"/thumbs.vtt\",\n        pathChaptersVtt: null,\n        pathStream: \"/stream.mp4\",\n        pathCaption: null,\n        stashOCounter: 5,\n        stashPlayCount: 10,\n        stashPlayDuration: 7200.5,\n        stashCreatedAt: \"2024-01-15T10:30:00Z\",\n        stashUpdatedAt: \"2024-06-20T15:45:00Z\",\n        userRating: 90,\n        userFavorite: 1,\n        userPlayCount: 3,\n        userPlayDuration: 1800.0,\n        userLastPlayedAt: \"2024-06-19T20:00:00Z\",\n        userOCount: 2,\n        userResumeTime: 600.5,\n        userOHistory: '[\"2024-06-18T21:00:00Z\",\"2024-06-19T20:30:00Z\"]',\n        userPlayHistory: \"[]\",\n      };\n\n      // Import will be added once we export the transform function\n      // For now, just verify the test structure\n      expect(row.id).toBe(\"123\");\n      expect(row.userFavorite).toBe(1);\n    });\n\n    it(\"should handle null user data gracefully\", () =&gt; {\n      const row = {\n        id: \"456\",\n        title: \"Scene Without User Data\",\n        userRating: null,\n        userFavorite: null,\n        userPlayCount: null,\n        userLastPlayedAt: null,\n        userOCount: null,\n        userResumeTime: null,\n        userOHistory: null,\n        userPlayHistory: null,\n      };\n\n      // User data should default to safe values\n      expect(row.userFavorite).toBeNull();\n    });\n  });\n});\n</code></pre> <p>Step 2: Run test to verify it passes (basic structure)</p> <p>Run: <code>cd server &amp;&amp; npm test -- --run tests/services/SceneQueryBuilder.test.ts</code> Expected: PASS</p> <p>Step 3: Implement full transformRow method</p> <p>Replace the placeholder <code>transformRow</code> in <code>SceneQueryBuilder.ts</code>:</p> <pre><code>  /**\n   * Transform a raw database row into a NormalizedScene\n   */\n  private transformRow(row: any): NormalizedScene {\n    // Parse JSON fields\n    const oHistory = this.parseJsonArray(row.userOHistory);\n    const playHistory = this.parseJsonArray(row.userPlayHistory);\n\n    // Determine last_o_at from o_history\n    const lastOAt = oHistory.length &gt; 0 ? oHistory[oHistory.length - 1] : null;\n\n    return {\n      id: row.id,\n      title: row.title || null,\n      code: row.code || null,\n      date: row.date || null,\n      details: row.details || null,\n      director: null, // Not stored in CachedScene\n      urls: [], // Not stored in CachedScene\n      organized: row.organized === 1,\n      interactive: false, // Not stored in CachedScene\n      interactive_speed: null,\n      created_at: row.stashCreatedAt || null,\n      updated_at: row.stashUpdatedAt || null,\n\n      // User data - prefer Peek user data over Stash data\n      rating: row.userRating != null ? Math.round(row.userRating / 20) : null,\n      rating100: row.userRating ?? null,\n      favorite: row.userFavorite === 1,\n      o_counter: row.userOCount ?? row.stashOCounter ?? 0,\n      play_count: row.userPlayCount ?? row.stashPlayCount ?? 0,\n      play_duration: row.userPlayDuration ?? row.stashPlayDuration ?? 0,\n      resume_time: row.userResumeTime ?? 0,\n      play_history: playHistory,\n      o_history: oHistory.map((ts: string) =&gt; new Date(ts)),\n      last_played_at: row.userLastPlayedAt || null,\n      last_o_at: lastOAt,\n\n      // File data - build from individual columns\n      files: [\n        {\n          id: row.id,\n          path: row.filePath || \"\",\n          size: row.fileSize?.toString() || \"0\",\n          duration: row.duration || 0,\n          video_codec: row.fileVideoCodec || null,\n          audio_codec: row.fileAudioCodec || null,\n          width: row.fileWidth || 0,\n          height: row.fileHeight || 0,\n          frame_rate: row.fileFrameRate || 0,\n          bit_rate: row.fileBitRate || 0,\n          created_at: row.stashCreatedAt || null,\n          updated_at: row.stashUpdatedAt || null,\n        },\n      ],\n\n      // Paths\n      paths: {\n        screenshot: row.pathScreenshot || null,\n        preview: row.pathPreview || null,\n        stream: row.pathStream || null,\n        webp: null,\n        vtt: row.pathVtt || null,\n        sprite: row.pathSprite || null,\n        funscript: null,\n        interactive_heatmap: null,\n        caption: row.pathCaption || null,\n        chapters_vtt: row.pathChaptersVtt || null,\n      },\n\n      // Relations - populated separately after query\n      studio: null,\n      performers: [],\n      tags: [],\n      groups: [],\n      galleries: [],\n      scene_markers: [],\n      stash_ids: [],\n      sceneStreams: [],\n    };\n  }\n\n  /**\n   * Safely parse a JSON array string\n   */\n  private parseJsonArray(json: string | null): string[] {\n    if (!json) return [];\n    try {\n      const parsed = JSON.parse(json);\n      return Array.isArray(parsed) ? parsed : [];\n    } catch {\n      return [];\n    }\n  }\n</code></pre> <p>Step 4: Verify file compiles</p> <p>Run: <code>cd server &amp;&amp; npx tsc --noEmit</code> Expected: No errors</p> <p>Step 5: Commit</p> <pre><code>git add server/services/SceneQueryBuilder.ts server/tests/services/SceneQueryBuilder.test.ts\ngit commit -m \"feat: implement row transformation to NormalizedScene\"\n</code></pre>"},{"location":"plans/2025-12-09-sql-native-scene-queries/#task-4-implement-exclusion-filter","title":"Task 4: Implement Exclusion Filter","text":"<p>Files: - Modify: <code>server/services/SceneQueryBuilder.ts</code></p> <p>Step 1: Add exclusion filter method</p> <p>Add this method to <code>SceneQueryBuilder</code>:</p> <pre><code>  /**\n   * Build exclusion filter clause\n   * Excludes scenes by ID (from user restrictions)\n   */\n  private buildExclusionFilter(excludedIds: Set&lt;string&gt;): FilterClause {\n    if (!excludedIds || excludedIds.size === 0) {\n      return { sql: \"\", params: [] };\n    }\n\n    // For large exclusion sets, use a subquery approach\n    // SQLite handles IN clauses well up to ~1000 items\n    const ids = Array.from(excludedIds);\n\n    if (ids.length &lt;= 500) {\n      // Direct IN clause for smaller sets\n      const placeholders = ids.map(() =&gt; \"?\").join(\", \");\n      return {\n        sql: `s.id NOT IN (${placeholders})`,\n        params: ids,\n      };\n    }\n\n    // For larger sets, we'll need to use a different approach\n    // This is a pragmatic limit - if you have &gt;500 exclusions,\n    // consider pre-computing a materialized view\n    const placeholders = ids.slice(0, 500).map(() =&gt; \"?\").join(\", \");\n    logger.warn(\"Exclusion set truncated to 500 items\", {\n      originalSize: ids.length,\n    });\n    return {\n      sql: `s.id NOT IN (${placeholders})`,\n      params: ids.slice(0, 500),\n    };\n  }\n</code></pre> <p>Step 2: Update execute() to use exclusion filter</p> <p>Update the <code>execute</code> method to include exclusions:</p> <pre><code>  async execute(options: SceneQueryOptions): Promise&lt;SceneQueryResult&gt; {\n    const startTime = Date.now();\n    const { userId, page, perPage, excludedSceneIds } = options;\n\n    // Build FROM clause\n    const fromClause = this.buildFromClause(userId);\n\n    // Build WHERE clauses\n    const whereClauses: FilterClause[] = [this.buildBaseWhere()];\n\n    // Add exclusion filter\n    const exclusionFilter = this.buildExclusionFilter(excludedSceneIds || new Set());\n    if (exclusionFilter.sql) {\n      whereClauses.push(exclusionFilter);\n    }\n\n    // Combine WHERE clauses\n    const whereSQL = whereClauses.map((c) =&gt; c.sql).filter(Boolean).join(\" AND \");\n    const whereParams = whereClauses.flatMap((c) =&gt; c.params);\n\n    // Build full query\n    const offset = (page - 1) * perPage;\n    const sql = `\n      SELECT ${this.SELECT_COLUMNS}\n      ${fromClause.sql}\n      WHERE ${whereSQL}\n      ORDER BY s.stashCreatedAt DESC\n      LIMIT ? OFFSET ?\n    `;\n\n    const params = [...fromClause.params, ...whereParams, perPage, offset];\n\n    logger.info(\"SceneQueryBuilder.execute\", {\n      whereClauseCount: whereClauses.length,\n      excludedCount: excludedSceneIds?.size || 0,\n      paramCount: params.length,\n    });\n\n    // Execute query\n    const rows = await prisma.$queryRawUnsafe&lt;any[]&gt;(sql, ...params);\n\n    // Count query\n    const countSql = `\n      SELECT COUNT(DISTINCT s.id) as total\n      ${fromClause.sql}\n      WHERE ${whereSQL}\n    `;\n    const countParams = [...fromClause.params, ...whereParams];\n    const countResult = await prisma.$queryRawUnsafe&lt;{ total: number }[]&gt;(\n      countSql,\n      ...countParams\n    );\n    const total = Number(countResult[0]?.total || 0);\n\n    const scenes = rows.map((row) =&gt; this.transformRow(row));\n\n    logger.info(\"SceneQueryBuilder.execute complete\", {\n      queryTimeMs: Date.now() - startTime,\n      resultCount: scenes.length,\n      total,\n    });\n\n    return { scenes, total };\n  }\n</code></pre> <p>Step 3: Verify file compiles</p> <p>Run: <code>cd server &amp;&amp; npx tsc --noEmit</code> Expected: No errors</p> <p>Step 4: Commit</p> <pre><code>git add server/services/SceneQueryBuilder.ts\ngit commit -m \"feat: add exclusion filter to SceneQueryBuilder\"\n</code></pre>"},{"location":"plans/2025-12-09-sql-native-scene-queries/#task-5-implement-entity-filters-performers","title":"Task 5: Implement Entity Filters (Performers)","text":"<p>Files: - Modify: <code>server/services/SceneQueryBuilder.ts</code></p> <p>Step 1: Add performer filter method</p> <pre><code>  /**\n   * Build performer filter clause\n   * Supports INCLUDES, INCLUDES_ALL, EXCLUDES modifiers\n   */\n  private buildPerformerFilter(\n    filter: { value: string[]; modifier?: string } | undefined\n  ): FilterClause {\n    if (!filter || !filter.value || filter.value.length === 0) {\n      return { sql: \"\", params: [] };\n    }\n\n    const { value: ids, modifier = \"INCLUDES\" } = filter;\n    const placeholders = ids.map(() =&gt; \"?\").join(\", \");\n\n    switch (modifier) {\n      case \"INCLUDES\":\n        // Scene has ANY of these performers\n        return {\n          sql: `s.id IN (SELECT sceneId FROM ScenePerformer WHERE performerId IN (${placeholders}))`,\n          params: ids,\n        };\n\n      case \"INCLUDES_ALL\":\n        // Scene has ALL of these performers\n        return {\n          sql: `s.id IN (\n            SELECT sceneId FROM ScenePerformer\n            WHERE performerId IN (${placeholders})\n            GROUP BY sceneId\n            HAVING COUNT(DISTINCT performerId) = ?\n          )`,\n          params: [...ids, ids.length],\n        };\n\n      case \"EXCLUDES\":\n        // Scene has NONE of these performers\n        return {\n          sql: `s.id NOT IN (SELECT sceneId FROM ScenePerformer WHERE performerId IN (${placeholders}))`,\n          params: ids,\n        };\n\n      default:\n        logger.warn(\"Unknown performer filter modifier\", { modifier });\n        return { sql: \"\", params: [] };\n    }\n  }\n</code></pre> <p>Step 2: Update execute() to use performer filter</p> <p>Add to the WHERE clause building section in <code>execute()</code>:</p> <pre><code>    // Add entity filters\n    if (options.filters?.performers) {\n      const performerFilter = this.buildPerformerFilter(options.filters.performers);\n      if (performerFilter.sql) {\n        whereClauses.push(performerFilter);\n      }\n    }\n</code></pre> <p>Step 3: Verify file compiles</p> <p>Run: <code>cd server &amp;&amp; npx tsc --noEmit</code> Expected: No errors</p> <p>Step 4: Commit</p> <pre><code>git add server/services/SceneQueryBuilder.ts\ngit commit -m \"feat: add performer filter to SceneQueryBuilder\"\n</code></pre>"},{"location":"plans/2025-12-09-sql-native-scene-queries/#task-6-implement-entity-filters-tags-studios-groups","title":"Task 6: Implement Entity Filters (Tags, Studios, Groups)","text":"<p>Files: - Modify: <code>server/services/SceneQueryBuilder.ts</code></p> <p>Step 1: Add tag filter method</p> <pre><code>  /**\n   * Build tag filter clause\n   */\n  private buildTagFilter(\n    filter: { value: string[]; modifier?: string } | undefined\n  ): FilterClause {\n    if (!filter || !filter.value || filter.value.length === 0) {\n      return { sql: \"\", params: [] };\n    }\n\n    const { value: ids, modifier = \"INCLUDES\" } = filter;\n    const placeholders = ids.map(() =&gt; \"?\").join(\", \");\n\n    switch (modifier) {\n      case \"INCLUDES\":\n        return {\n          sql: `s.id IN (SELECT sceneId FROM SceneTag WHERE tagId IN (${placeholders}))`,\n          params: ids,\n        };\n\n      case \"INCLUDES_ALL\":\n        return {\n          sql: `s.id IN (\n            SELECT sceneId FROM SceneTag\n            WHERE tagId IN (${placeholders})\n            GROUP BY sceneId\n            HAVING COUNT(DISTINCT tagId) = ?\n          )`,\n          params: [...ids, ids.length],\n        };\n\n      case \"EXCLUDES\":\n        return {\n          sql: `s.id NOT IN (SELECT sceneId FROM SceneTag WHERE tagId IN (${placeholders}))`,\n          params: ids,\n        };\n\n      default:\n        return { sql: \"\", params: [] };\n    }\n  }\n</code></pre> <p>Step 2: Add studio filter method</p> <pre><code>  /**\n   * Build studio filter clause\n   */\n  private buildStudioFilter(\n    filter: { value: string[]; modifier?: string } | undefined\n  ): FilterClause {\n    if (!filter || !filter.value || filter.value.length === 0) {\n      return { sql: \"\", params: [] };\n    }\n\n    const { value: ids, modifier = \"INCLUDES\" } = filter;\n    const placeholders = ids.map(() =&gt; \"?\").join(\", \");\n\n    switch (modifier) {\n      case \"INCLUDES\":\n        return {\n          sql: `s.studioId IN (${placeholders})`,\n          params: ids,\n        };\n\n      case \"EXCLUDES\":\n        return {\n          sql: `(s.studioId IS NULL OR s.studioId NOT IN (${placeholders}))`,\n          params: ids,\n        };\n\n      default:\n        return { sql: \"\", params: [] };\n    }\n  }\n</code></pre> <p>Step 3: Add group filter method</p> <pre><code>  /**\n   * Build group filter clause\n   */\n  private buildGroupFilter(\n    filter: { value: string[]; modifier?: string } | undefined\n  ): FilterClause {\n    if (!filter || !filter.value || filter.value.length === 0) {\n      return { sql: \"\", params: [] };\n    }\n\n    const { value: ids, modifier = \"INCLUDES\" } = filter;\n    const placeholders = ids.map(() =&gt; \"?\").join(\", \");\n\n    switch (modifier) {\n      case \"INCLUDES\":\n        return {\n          sql: `s.id IN (SELECT sceneId FROM SceneGroup WHERE groupId IN (${placeholders}))`,\n          params: ids,\n        };\n\n      case \"INCLUDES_ALL\":\n        return {\n          sql: `s.id IN (\n            SELECT sceneId FROM SceneGroup\n            WHERE groupId IN (${placeholders})\n            GROUP BY sceneId\n            HAVING COUNT(DISTINCT groupId) = ?\n          )`,\n          params: [...ids, ids.length],\n        };\n\n      case \"EXCLUDES\":\n        return {\n          sql: `s.id NOT IN (SELECT sceneId FROM SceneGroup WHERE groupId IN (${placeholders}))`,\n          params: ids,\n        };\n\n      default:\n        return { sql: \"\", params: [] };\n    }\n  }\n</code></pre> <p>Step 4: Update execute() to use all entity filters</p> <p>Add after performer filter in <code>execute()</code>:</p> <pre><code>    if (options.filters?.tags) {\n      const tagFilter = this.buildTagFilter(options.filters.tags);\n      if (tagFilter.sql) {\n        whereClauses.push(tagFilter);\n      }\n    }\n\n    if (options.filters?.studios) {\n      const studioFilter = this.buildStudioFilter(options.filters.studios);\n      if (studioFilter.sql) {\n        whereClauses.push(studioFilter);\n      }\n    }\n\n    if (options.filters?.groups) {\n      const groupFilter = this.buildGroupFilter(options.filters.groups);\n      if (groupFilter.sql) {\n        whereClauses.push(groupFilter);\n      }\n    }\n</code></pre> <p>Step 5: Verify file compiles</p> <p>Run: <code>cd server &amp;&amp; npx tsc --noEmit</code> Expected: No errors</p> <p>Step 6: Commit</p> <pre><code>git add server/services/SceneQueryBuilder.ts\ngit commit -m \"feat: add tag, studio, group filters to SceneQueryBuilder\"\n</code></pre>"},{"location":"plans/2025-12-09-sql-native-scene-queries/#task-7-implement-user-data-filters","title":"Task 7: Implement User Data Filters","text":"<p>Files: - Modify: <code>server/services/SceneQueryBuilder.ts</code></p> <p>Step 1: Add favorite filter</p> <pre><code>  /**\n   * Build favorite filter clause\n   */\n  private buildFavoriteFilter(favorite: boolean | undefined): FilterClause {\n    if (favorite === undefined) {\n      return { sql: \"\", params: [] };\n    }\n\n    if (favorite) {\n      return { sql: \"r.favorite = 1\", params: [] };\n    } else {\n      return { sql: \"(r.favorite = 0 OR r.favorite IS NULL)\", params: [] };\n    }\n  }\n</code></pre> <p>Step 2: Add rating filter</p> <pre><code>  /**\n   * Build rating filter clause\n   */\n  private buildRatingFilter(\n    filter: { value?: number; value2?: number; modifier?: string } | undefined\n  ): FilterClause {\n    if (!filter || filter.value === undefined) {\n      return { sql: \"\", params: [] };\n    }\n\n    const { value, value2, modifier = \"GREATER_THAN\" } = filter;\n    const col = \"COALESCE(r.rating, 0)\";\n\n    switch (modifier) {\n      case \"EQUALS\":\n        return { sql: `${col} = ?`, params: [value] };\n\n      case \"NOT_EQUALS\":\n        return { sql: `${col} != ?`, params: [value] };\n\n      case \"GREATER_THAN\":\n        return { sql: `${col} &gt; ?`, params: [value] };\n\n      case \"LESS_THAN\":\n        return { sql: `${col} &lt; ?`, params: [value] };\n\n      case \"BETWEEN\":\n        if (value2 === undefined) {\n          return { sql: `${col} &gt;= ?`, params: [value] };\n        }\n        return { sql: `${col} BETWEEN ? AND ?`, params: [value, value2] };\n\n      case \"NOT_BETWEEN\":\n        if (value2 === undefined) {\n          return { sql: `${col} &lt; ?`, params: [value] };\n        }\n        return { sql: `(${col} &lt; ? OR ${col} &gt; ?)`, params: [value, value2] };\n\n      default:\n        return { sql: \"\", params: [] };\n    }\n  }\n</code></pre> <p>Step 3: Add play_count and o_counter filters</p> <pre><code>  /**\n   * Build play count filter clause\n   */\n  private buildPlayCountFilter(\n    filter: { value?: number; value2?: number; modifier?: string } | undefined\n  ): FilterClause {\n    if (!filter || filter.value === undefined) {\n      return { sql: \"\", params: [] };\n    }\n\n    const { value, value2, modifier = \"GREATER_THAN\" } = filter;\n    const col = \"COALESCE(w.playCount, 0)\";\n\n    switch (modifier) {\n      case \"EQUALS\":\n        return { sql: `${col} = ?`, params: [value] };\n      case \"NOT_EQUALS\":\n        return { sql: `${col} != ?`, params: [value] };\n      case \"GREATER_THAN\":\n        return { sql: `${col} &gt; ?`, params: [value] };\n      case \"LESS_THAN\":\n        return { sql: `${col} &lt; ?`, params: [value] };\n      case \"BETWEEN\":\n        return value2 !== undefined\n          ? { sql: `${col} BETWEEN ? AND ?`, params: [value, value2] }\n          : { sql: `${col} &gt;= ?`, params: [value] };\n      default:\n        return { sql: \"\", params: [] };\n    }\n  }\n\n  /**\n   * Build o_counter filter clause\n   */\n  private buildOCounterFilter(\n    filter: { value?: number; value2?: number; modifier?: string } | undefined\n  ): FilterClause {\n    if (!filter || filter.value === undefined) {\n      return { sql: \"\", params: [] };\n    }\n\n    const { value, value2, modifier = \"GREATER_THAN\" } = filter;\n    const col = \"COALESCE(w.oCount, 0)\";\n\n    switch (modifier) {\n      case \"EQUALS\":\n        return { sql: `${col} = ?`, params: [value] };\n      case \"NOT_EQUALS\":\n        return { sql: `${col} != ?`, params: [value] };\n      case \"GREATER_THAN\":\n        return { sql: `${col} &gt; ?`, params: [value] };\n      case \"LESS_THAN\":\n        return { sql: `${col} &lt; ?`, params: [value] };\n      case \"BETWEEN\":\n        return value2 !== undefined\n          ? { sql: `${col} BETWEEN ? AND ?`, params: [value, value2] }\n          : { sql: `${col} &gt;= ?`, params: [value] };\n      default:\n        return { sql: \"\", params: [] };\n    }\n  }\n</code></pre> <p>Step 4: Update execute() to use user data filters</p> <p>Add after entity filters in <code>execute()</code>:</p> <pre><code>    // User data filters\n    const favoriteFilter = this.buildFavoriteFilter(options.filters?.favorite);\n    if (favoriteFilter.sql) {\n      whereClauses.push(favoriteFilter);\n    }\n\n    if (options.filters?.rating100) {\n      const ratingFilter = this.buildRatingFilter(options.filters.rating100);\n      if (ratingFilter.sql) {\n        whereClauses.push(ratingFilter);\n      }\n    }\n\n    if (options.filters?.play_count) {\n      const playCountFilter = this.buildPlayCountFilter(options.filters.play_count);\n      if (playCountFilter.sql) {\n        whereClauses.push(playCountFilter);\n      }\n    }\n\n    if (options.filters?.o_counter) {\n      const oCounterFilter = this.buildOCounterFilter(options.filters.o_counter);\n      if (oCounterFilter.sql) {\n        whereClauses.push(oCounterFilter);\n      }\n    }\n</code></pre> <p>Step 5: Verify file compiles</p> <p>Run: <code>cd server &amp;&amp; npx tsc --noEmit</code> Expected: No errors</p> <p>Step 6: Commit</p> <pre><code>git add server/services/SceneQueryBuilder.ts\ngit commit -m \"feat: add user data filters (favorite, rating, play_count, o_counter)\"\n</code></pre>"},{"location":"plans/2025-12-09-sql-native-scene-queries/#task-8-implement-sort-clause-builder","title":"Task 8: Implement Sort Clause Builder","text":"<p>Files: - Modify: <code>server/services/SceneQueryBuilder.ts</code></p> <p>Step 1: Add sort clause builder</p> <pre><code>  /**\n   * Build ORDER BY clause\n   */\n  private buildSortClause(\n    sort: string,\n    direction: \"ASC\" | \"DESC\",\n    randomSeed?: number\n  ): string {\n    const dir = direction === \"ASC\" ? \"ASC\" : \"DESC\";\n\n    // Map sort field names to SQL expressions\n    const sortMap: Record&lt;string, string&gt; = {\n      // Scene metadata\n      created_at: `s.stashCreatedAt ${dir}`,\n      updated_at: `s.stashUpdatedAt ${dir}`,\n      date: `s.date ${dir}`,\n      title: `s.title ${dir}`,\n      duration: `s.duration ${dir}`,\n      filesize: `s.fileSize ${dir}`,\n      bitrate: `s.fileBitRate ${dir}`,\n      framerate: `s.fileFrameRate ${dir}`,\n\n      // Stash ratings (not user ratings)\n      rating: `s.rating100 ${dir}`,\n\n      // User data - prefer user values\n      last_played_at: `w.lastPlayedAt ${dir}`,\n      play_count: `COALESCE(w.playCount, 0) ${dir}`,\n      play_duration: `COALESCE(w.playDuration, 0) ${dir}`,\n      o_counter: `COALESCE(w.oCount, 0) ${dir}`,\n      user_rating: `COALESCE(r.rating, 0) ${dir}`,\n      resume_time: `COALESCE(w.resumeTime, 0) ${dir}`,\n\n      // Random with deterministic seed for stable pagination\n      random: `((CAST(substr(s.id, 1, 8) AS INTEGER) * 1103515245 + ${randomSeed || 12345}) % 2147483647) ${dir}`,\n    };\n\n    const sortExpr = sortMap[sort] || sortMap[\"created_at\"];\n\n    // Add secondary sort by id for stable ordering\n    return `${sortExpr}, s.id ${dir}`;\n  }\n</code></pre> <p>Step 2: Update execute() to use dynamic sorting</p> <p>Replace the hardcoded ORDER BY in <code>execute()</code>:</p> <pre><code>    // Build sort clause\n    const sortClause = this.buildSortClause(\n      options.sort,\n      options.sortDirection,\n      options.randomSeed\n    );\n\n    // Build full query\n    const offset = (page - 1) * perPage;\n    const sql = `\n      SELECT ${this.SELECT_COLUMNS}\n      ${fromClause.sql}\n      WHERE ${whereSQL}\n      ORDER BY ${sortClause}\n      LIMIT ? OFFSET ?\n    `;\n</code></pre> <p>Step 3: Verify file compiles</p> <p>Run: <code>cd server &amp;&amp; npx tsc --noEmit</code> Expected: No errors</p> <p>Step 4: Commit</p> <pre><code>git add server/services/SceneQueryBuilder.ts\ngit commit -m \"feat: add dynamic sort clause builder with random seed support\"\n</code></pre>"},{"location":"plans/2025-12-09-sql-native-scene-queries/#task-9-implement-id-filter-and-metadata-filters","title":"Task 9: Implement ID Filter and Metadata Filters","text":"<p>Files: - Modify: <code>server/services/SceneQueryBuilder.ts</code></p> <p>Step 1: Add ID filter</p> <pre><code>  /**\n   * Build ID filter clause (for specific scene IDs)\n   */\n  private buildIdFilter(\n    filter: { value: string[]; modifier?: string } | string[] | undefined\n  ): FilterClause {\n    // Handle both array and object formats\n    const ids = Array.isArray(filter) ? filter : filter?.value;\n    if (!ids || ids.length === 0) {\n      return { sql: \"\", params: [] };\n    }\n\n    const modifier = Array.isArray(filter) ? \"INCLUDES\" : filter?.modifier || \"INCLUDES\";\n    const placeholders = ids.map(() =&gt; \"?\").join(\", \");\n\n    switch (modifier) {\n      case \"INCLUDES\":\n        return { sql: `s.id IN (${placeholders})`, params: ids };\n      case \"EXCLUDES\":\n        return { sql: `s.id NOT IN (${placeholders})`, params: ids };\n      default:\n        return { sql: `s.id IN (${placeholders})`, params: ids };\n    }\n  }\n</code></pre> <p>Step 2: Add duration filter</p> <pre><code>  /**\n   * Build duration filter clause\n   */\n  private buildDurationFilter(\n    filter: { value?: number; value2?: number; modifier?: string } | undefined\n  ): FilterClause {\n    if (!filter || filter.value === undefined) {\n      return { sql: \"\", params: [] };\n    }\n\n    const { value, value2, modifier = \"GREATER_THAN\" } = filter;\n    const col = \"COALESCE(s.duration, 0)\";\n\n    switch (modifier) {\n      case \"EQUALS\":\n        return { sql: `${col} = ?`, params: [value] };\n      case \"NOT_EQUALS\":\n        return { sql: `${col} != ?`, params: [value] };\n      case \"GREATER_THAN\":\n        return { sql: `${col} &gt; ?`, params: [value] };\n      case \"LESS_THAN\":\n        return { sql: `${col} &lt; ?`, params: [value] };\n      case \"BETWEEN\":\n        return value2 !== undefined\n          ? { sql: `${col} BETWEEN ? AND ?`, params: [value, value2] }\n          : { sql: `${col} &gt;= ?`, params: [value] };\n      default:\n        return { sql: \"\", params: [] };\n    }\n  }\n</code></pre> <p>Step 3: Add resolution filter</p> <pre><code>  /**\n   * Build resolution filter clause\n   */\n  private buildResolutionFilter(\n    filter: { value?: string; modifier?: string } | undefined\n  ): FilterClause {\n    if (!filter || !filter.value) {\n      return { sql: \"\", params: [] };\n    }\n\n    // Resolution values: \"144p\", \"240p\", \"360p\", \"480p\", \"720p\", \"1080p\", \"4k\", \"5k\", \"6k\", \"8k\"\n    const resolutionMap: Record&lt;string, number&gt; = {\n      \"144p\": 144,\n      \"240p\": 240,\n      \"360p\": 360,\n      \"480p\": 480,\n      \"540p\": 540,\n      \"720p\": 720,\n      \"1080p\": 1080,\n      \"1440p\": 1440,\n      \"4k\": 2160,\n      \"5k\": 2880,\n      \"6k\": 3240,\n      \"8k\": 4320,\n    };\n\n    const height = resolutionMap[filter.value.toLowerCase()];\n    if (!height) {\n      return { sql: \"\", params: [] };\n    }\n\n    const { modifier = \"EQUALS\" } = filter;\n    const col = \"COALESCE(s.fileHeight, 0)\";\n\n    switch (modifier) {\n      case \"EQUALS\":\n        return { sql: `${col} = ?`, params: [height] };\n      case \"GREATER_THAN\":\n        return { sql: `${col} &gt; ?`, params: [height] };\n      case \"LESS_THAN\":\n        return { sql: `${col} &lt; ?`, params: [height] };\n      default:\n        return { sql: `${col} &gt;= ?`, params: [height] };\n    }\n  }\n</code></pre> <p>Step 4: Update execute() to use all filters</p> <p>Add at the beginning of filter building in <code>execute()</code>:</p> <pre><code>    // ID filter\n    if (options.filters?.ids) {\n      const idFilter = this.buildIdFilter(options.filters.ids);\n      if (idFilter.sql) {\n        whereClauses.push(idFilter);\n      }\n    }\n\n    // Metadata filters\n    if (options.filters?.duration) {\n      const durationFilter = this.buildDurationFilter(options.filters.duration);\n      if (durationFilter.sql) {\n        whereClauses.push(durationFilter);\n      }\n    }\n\n    if (options.filters?.resolution) {\n      const resolutionFilter = this.buildResolutionFilter(options.filters.resolution);\n      if (resolutionFilter.sql) {\n        whereClauses.push(resolutionFilter);\n      }\n    }\n</code></pre> <p>Step 5: Verify file compiles</p> <p>Run: <code>cd server &amp;&amp; npx tsc --noEmit</code> Expected: No errors</p> <p>Step 6: Commit</p> <pre><code>git add server/services/SceneQueryBuilder.ts\ngit commit -m \"feat: add ID, duration, and resolution filters\"\n</code></pre>"},{"location":"plans/2025-12-09-sql-native-scene-queries/#task-10-implement-relation-population","title":"Task 10: Implement Relation Population","text":"<p>Files: - Modify: <code>server/services/SceneQueryBuilder.ts</code></p> <p>Step 1: Add relation population method</p> <pre><code>  /**\n   * Populate scene relations (performers, tags, studio, groups, galleries)\n   * Called after main query with just the scene IDs we need\n   */\n  async populateRelations(scenes: NormalizedScene[]): Promise&lt;void&gt; {\n    if (scenes.length === 0) return;\n\n    const sceneIds = scenes.map((s) =&gt; s.id);\n    const studioIds = scenes.map((s) =&gt; s.studioId).filter(Boolean) as string[];\n\n    // Batch load all relations in parallel\n    const [performers, tags, groups, galleries, studios] = await Promise.all([\n      prisma.scenePerformer.findMany({\n        where: { sceneId: { in: sceneIds } },\n        include: { performer: true },\n      }),\n      prisma.sceneTag.findMany({\n        where: { sceneId: { in: sceneIds } },\n        include: { tag: true },\n      }),\n      prisma.sceneGroup.findMany({\n        where: { sceneId: { in: sceneIds } },\n        include: { group: true },\n      }),\n      prisma.sceneGallery.findMany({\n        where: { sceneId: { in: sceneIds } },\n        include: { gallery: true },\n      }),\n      studioIds.length &gt; 0\n        ? prisma.cachedStudio.findMany({\n            where: { id: { in: studioIds } },\n          })\n        : Promise.resolve([]),\n    ]);\n\n    // Build lookup maps\n    const performersByScene = new Map&lt;string, any[]&gt;();\n    for (const sp of performers) {\n      const list = performersByScene.get(sp.sceneId) || [];\n      list.push(this.transformCachedPerformer(sp.performer));\n      performersByScene.set(sp.sceneId, list);\n    }\n\n    const tagsByScene = new Map&lt;string, any[]&gt;();\n    for (const st of tags) {\n      const list = tagsByScene.get(st.sceneId) || [];\n      list.push(this.transformCachedTag(st.tag));\n      tagsByScene.set(st.sceneId, list);\n    }\n\n    const groupsByScene = new Map&lt;string, any[]&gt;();\n    for (const sg of groups) {\n      const list = groupsByScene.get(sg.sceneId) || [];\n      list.push({\n        ...this.transformCachedGroup(sg.group),\n        scene_index: sg.sceneIndex,\n      });\n      groupsByScene.set(sg.sceneId, list);\n    }\n\n    const galleriesByScene = new Map&lt;string, any[]&gt;();\n    for (const sg of galleries) {\n      const list = galleriesByScene.get(sg.sceneId) || [];\n      list.push(this.transformCachedGallery(sg.gallery));\n      galleriesByScene.set(sg.sceneId, list);\n    }\n\n    const studiosById = new Map&lt;string, any&gt;();\n    for (const studio of studios) {\n      studiosById.set(studio.id, this.transformCachedStudio(studio));\n    }\n\n    // Populate scenes\n    for (const scene of scenes) {\n      scene.performers = performersByScene.get(scene.id) || [];\n      scene.tags = tagsByScene.get(scene.id) || [];\n      scene.groups = groupsByScene.get(scene.id) || [];\n      scene.galleries = galleriesByScene.get(scene.id) || [];\n      if (scene.studioId) {\n        scene.studio = studiosById.get(scene.studioId) || null;\n      }\n    }\n  }\n\n  // Helper transforms for cached entities\n  private transformCachedPerformer(p: any): any {\n    return {\n      id: p.id,\n      name: p.name,\n      disambiguation: p.disambiguation,\n      gender: p.gender,\n      image_path: p.imagePath,\n      favorite: p.favorite,\n      rating100: p.rating100,\n    };\n  }\n\n  private transformCachedTag(t: any): any {\n    return {\n      id: t.id,\n      name: t.name,\n      image_path: t.imagePath,\n      favorite: t.favorite,\n    };\n  }\n\n  private transformCachedStudio(s: any): any {\n    return {\n      id: s.id,\n      name: s.name,\n      image_path: s.imagePath,\n      favorite: s.favorite,\n      parent_studio: s.parentId ? { id: s.parentId } : null,\n    };\n  }\n\n  private transformCachedGroup(g: any): any {\n    return {\n      id: g.id,\n      name: g.name,\n      front_image_path: g.frontImagePath,\n      back_image_path: g.backImagePath,\n    };\n  }\n\n  private transformCachedGallery(g: any): any {\n    return {\n      id: g.id,\n      title: g.title,\n      cover: g.coverPath ? { paths: { thumbnail: g.coverPath } } : null,\n    };\n  }\n</code></pre> <p>Step 2: Add studioId to SELECT columns and transformRow</p> <p>Update <code>SELECT_COLUMNS</code> to include <code>s.studioId</code> (if not already present).</p> <p>Update <code>transformRow</code> to include: <pre><code>    // Store studioId for later population\n    const scene: any = {\n      // ... existing fields ...\n      studioId: row.studioId, // Temporary field for population\n    };\n</code></pre></p> <p>Step 3: Update execute() to populate relations by default</p> <p>At the end of <code>execute()</code>, before returning:</p> <pre><code>    // Populate relations\n    await this.populateRelations(scenes);\n\n    logger.info(\"SceneQueryBuilder.execute complete\", {\n      queryTimeMs: Date.now() - startTime,\n      resultCount: scenes.length,\n      total,\n    });\n\n    return { scenes, total };\n</code></pre> <p>Step 4: Verify file compiles</p> <p>Run: <code>cd server &amp;&amp; npx tsc --noEmit</code> Expected: No errors</p> <p>Step 5: Commit</p> <pre><code>git add server/services/SceneQueryBuilder.ts\ngit commit -m \"feat: add relation population for performers, tags, studio, groups\"\n</code></pre>"},{"location":"plans/2025-12-09-sql-native-scene-queries/#task-11-integration-test-basic-query","title":"Task 11: Integration Test - Basic Query","text":"<p>Files: - Create: <code>server/tests/services/SceneQueryBuilder.integration.test.ts</code></p> <p>Step 1: Create integration test</p> <pre><code>import { describe, it, expect, beforeAll } from \"vitest\";\nimport { sceneQueryBuilder } from \"../../services/SceneQueryBuilder.js\";\n\n// Skip if no database connection\nconst describeWithDb = process.env.DATABASE_URL ? describe : describe.skip;\n\ndescribeWithDb(\"SceneQueryBuilder Integration\", () =&gt; {\n  beforeAll(() =&gt; {\n    // Ensure database is available\n  });\n\n  it(\"should execute a basic query without filters\", async () =&gt; {\n    const result = await sceneQueryBuilder.execute({\n      userId: 1,\n      sort: \"created_at\",\n      sortDirection: \"DESC\",\n      page: 1,\n      perPage: 10,\n    });\n\n    expect(result).toHaveProperty(\"scenes\");\n    expect(result).toHaveProperty(\"total\");\n    expect(Array.isArray(result.scenes)).toBe(true);\n    expect(result.scenes.length).toBeLessThanOrEqual(10);\n  });\n\n  it(\"should apply exclusions correctly\", async () =&gt; {\n    // Get some scene IDs first\n    const initial = await sceneQueryBuilder.execute({\n      userId: 1,\n      sort: \"created_at\",\n      sortDirection: \"DESC\",\n      page: 1,\n      perPage: 5,\n    });\n\n    if (initial.scenes.length &lt; 2) {\n      console.log(\"Skipping exclusion test - not enough scenes\");\n      return;\n    }\n\n    const excludeId = initial.scenes[0].id;\n\n    const withExclusion = await sceneQueryBuilder.execute({\n      userId: 1,\n      excludedSceneIds: new Set([excludeId]),\n      sort: \"created_at\",\n      sortDirection: \"DESC\",\n      page: 1,\n      perPage: 5,\n    });\n\n    const excludedIds = withExclusion.scenes.map((s) =&gt; s.id);\n    expect(excludedIds).not.toContain(excludeId);\n  });\n\n  it(\"should paginate correctly\", async () =&gt; {\n    const page1 = await sceneQueryBuilder.execute({\n      userId: 1,\n      sort: \"created_at\",\n      sortDirection: \"DESC\",\n      page: 1,\n      perPage: 5,\n    });\n\n    const page2 = await sceneQueryBuilder.execute({\n      userId: 1,\n      sort: \"created_at\",\n      sortDirection: \"DESC\",\n      page: 2,\n      perPage: 5,\n    });\n\n    // Pages should have different scenes\n    const page1Ids = new Set(page1.scenes.map((s) =&gt; s.id));\n    const page2Ids = page2.scenes.map((s) =&gt; s.id);\n\n    for (const id of page2Ids) {\n      expect(page1Ids.has(id)).toBe(false);\n    }\n  });\n\n  it(\"should return consistent results with random sort and seed\", async () =&gt; {\n    const seed = 12345;\n\n    const result1 = await sceneQueryBuilder.execute({\n      userId: 1,\n      sort: \"random\",\n      sortDirection: \"DESC\",\n      page: 1,\n      perPage: 10,\n      randomSeed: seed,\n    });\n\n    const result2 = await sceneQueryBuilder.execute({\n      userId: 1,\n      sort: \"random\",\n      sortDirection: \"DESC\",\n      page: 1,\n      perPage: 10,\n      randomSeed: seed,\n    });\n\n    // Same seed should give same order\n    expect(result1.scenes.map((s) =&gt; s.id)).toEqual(\n      result2.scenes.map((s) =&gt; s.id)\n    );\n  });\n});\n</code></pre> <p>Step 2: Run integration tests</p> <p>Run: <code>cd server &amp;&amp; npm test -- --run tests/services/SceneQueryBuilder.integration.test.ts</code> Expected: PASS (or skip if no database)</p> <p>Step 3: Commit</p> <pre><code>git add server/tests/services/SceneQueryBuilder.integration.test.ts\ngit commit -m \"test: add SceneQueryBuilder integration tests\"\n</code></pre>"},{"location":"plans/2025-12-09-sql-native-scene-queries/#task-12-wire-up-to-findscenes-controller","title":"Task 12: Wire Up to findScenes Controller","text":"<p>Files: - Modify: <code>server/controllers/library/scenes.ts</code></p> <p>Step 1: Import SceneQueryBuilder</p> <p>Add at the top of the file:</p> <pre><code>import { sceneQueryBuilder } from \"../../services/SceneQueryBuilder.js\";\n</code></pre> <p>Step 2: Add feature flag</p> <p>Add near the top of the file:</p> <pre><code>// Feature flag for SQL query builder\nconst USE_SQL_QUERY_BUILDER = process.env.USE_SQL_QUERY_BUILDER !== \"false\";\n</code></pre> <p>Step 3: Update findScenes to use SceneQueryBuilder</p> <p>Find the <code>findScenes</code> function and add a new code path before the existing logic:</p> <pre><code>export const findScenes = async (req: AuthenticatedRequest, res: Response) =&gt; {\n  const userId = req.user?.id;\n  if (!userId) {\n    return res.status(401).json({ error: \"Unauthorized\" });\n  }\n\n  const startTime = Date.now();\n\n  try {\n    const {\n      filter,\n      scene_filter,\n      ids: requestedIds,\n    } = req.body as {\n      filter?: { page?: number; per_page?: number; sort?: string; direction?: string };\n      scene_filter?: PeekSceneFilter;\n      ids?: string[];\n    };\n\n    // NEW: Use SQL query builder if enabled\n    if (USE_SQL_QUERY_BUILDER) {\n      logger.info(\"findScenes: using SQL query builder path\");\n\n      // Get excluded scene IDs\n      const excludedIds = await userRestrictionService.getExcludedSceneIds(\n        userId,\n        false\n      );\n\n      // Build filters object\n      const filters: PeekSceneFilter = { ...scene_filter };\n      if (requestedIds &amp;&amp; requestedIds.length &gt; 0) {\n        filters.ids = { value: requestedIds, modifier: \"INCLUDES\" };\n      }\n\n      // Execute query\n      const result = await sceneQueryBuilder.execute({\n        userId,\n        filters,\n        excludedSceneIds: excludedIds,\n        sort: filter?.sort || \"created_at\",\n        sortDirection: (filter?.direction?.toUpperCase() as \"ASC\" | \"DESC\") || \"DESC\",\n        page: filter?.page || 1,\n        perPage: filter?.per_page || 40,\n        randomSeed: userId, // Stable random per user\n      });\n\n      // Add streamability info\n      const scenes = addStreamabilityInfo(result.scenes);\n\n      logger.info(\"findScenes complete (SQL path)\", {\n        totalTimeMs: Date.now() - startTime,\n        resultCount: scenes.length,\n        total: result.total,\n      });\n\n      return res.json({\n        findScenes: {\n          count: result.total,\n          scenes,\n        },\n      });\n    }\n\n    // EXISTING: Original code path (keep as fallback)\n    // ... rest of existing findScenes implementation ...\n</code></pre> <p>Step 4: Verify file compiles</p> <p>Run: <code>cd server &amp;&amp; npx tsc --noEmit</code> Expected: No errors</p> <p>Step 5: Commit</p> <pre><code>git add server/controllers/library/scenes.ts\ngit commit -m \"feat: wire SceneQueryBuilder to findScenes with feature flag\"\n</code></pre>"},{"location":"plans/2025-12-09-sql-native-scene-queries/#task-13-wire-up-to-carousel-controller","title":"Task 13: Wire Up to Carousel Controller","text":"<p>Files: - Modify: <code>server/controllers/carousel.ts</code></p> <p>Step 1: Import SceneQueryBuilder</p> <pre><code>import { sceneQueryBuilder } from \"../services/SceneQueryBuilder.js\";\n</code></pre> <p>Step 2: Add feature flag</p> <pre><code>const USE_SQL_QUERY_BUILDER = process.env.USE_SQL_QUERY_BUILDER !== \"false\";\n</code></pre> <p>Step 3: Update executeCarouselQuery</p> <p>Replace or add new code path to <code>executeCarouselQuery</code>:</p> <pre><code>export async function executeCarouselQuery(\n  userId: number,\n  rules: PeekSceneFilter,\n  sort: string,\n  direction: string\n): Promise&lt;NormalizedScene[]&gt; {\n  const startTime = Date.now();\n\n  // NEW: Use SQL query builder if enabled\n  if (USE_SQL_QUERY_BUILDER) {\n    logger.info(\"executeCarouselQuery: using SQL query builder path\");\n\n    // Get exclusions\n    const excludedIds = await userRestrictionService.getExcludedSceneIds(\n      userId,\n      false\n    );\n\n    // Execute query\n    const result = await sceneQueryBuilder.execute({\n      userId,\n      filters: rules,\n      excludedSceneIds: excludedIds,\n      sort,\n      sortDirection: direction.toUpperCase() as \"ASC\" | \"DESC\",\n      page: 1,\n      perPage: CAROUSEL_SCENE_LIMIT,\n      // Use different seed per carousel load for variety\n      randomSeed: userId + Date.now(),\n    });\n\n    const scenes = addStreamabilityInfo(result.scenes);\n\n    logger.info(\"executeCarouselQuery complete (SQL path)\", {\n      totalTimeMs: Date.now() - startTime,\n      resultCount: scenes.length,\n    });\n\n    return scenes;\n  }\n\n  // EXISTING: Original code path\n  // ... rest of existing implementation ...\n}\n</code></pre> <p>Step 4: Verify file compiles</p> <p>Run: <code>cd server &amp;&amp; npx tsc --noEmit</code> Expected: No errors</p> <p>Step 5: Commit</p> <pre><code>git add server/controllers/carousel.ts\ngit commit -m \"feat: wire SceneQueryBuilder to carousel queries with feature flag\"\n</code></pre>"},{"location":"plans/2025-12-09-sql-native-scene-queries/#task-14-end-to-end-testing","title":"Task 14: End-to-End Testing","text":"<p>Files: - None (manual testing)</p> <p>Step 1: Rebuild and restart server</p> <p>Run: <code>docker-compose up --build -d</code></p> <p>Step 2: Check logs for SQL query builder usage</p> <p>Run: <code>docker-compose logs -f peek-server</code> Expected: Should see \"using SQL query builder path\" messages</p> <p>Step 3: Test homepage load time</p> <p>Open browser, navigate to homepage, check: - Network tab: API response times should be &lt;1s per carousel - Server logs: Query times should be &lt;200ms</p> <p>Step 4: Test browse page with filters</p> <p>Navigate to Scenes, apply filters: - Filter by performer - Filter by tag - Filter by favorite - Sort by random</p> <p>Each should respond in &lt;500ms.</p> <p>Step 5: Commit verification notes</p> <pre><code>git add -A\ngit commit -m \"test: verify SQL query builder integration works end-to-end\"\n</code></pre>"},{"location":"plans/2025-12-09-sql-native-scene-queries/#task-15-remove-feature-flag-final","title":"Task 15: Remove Feature Flag (Final)","text":"<p>Files: - Modify: <code>server/controllers/library/scenes.ts</code> - Modify: <code>server/controllers/carousel.ts</code></p> <p>Step 1: Remove feature flag checks</p> <p>In both files, remove the <code>USE_SQL_QUERY_BUILDER</code> constant and the conditional branching. Keep only the SQL query builder path.</p> <p>Step 2: Remove dead code</p> <p>Remove the old in-memory filtering code paths that are no longer used.</p> <p>Step 3: Verify everything still compiles</p> <p>Run: <code>cd server &amp;&amp; npx tsc --noEmit</code> Expected: No errors</p> <p>Step 4: Run all tests</p> <p>Run: <code>cd server &amp;&amp; npm test</code> Expected: All tests pass</p> <p>Step 5: Final commit</p> <pre><code>git add -A\ngit commit -m \"refactor: remove feature flag, SQL query builder is now the default\"\n</code></pre>"},{"location":"plans/2025-12-09-sql-native-scene-queries/#summary","title":"Summary","text":"Task Description Estimated Time 1 Create types and interface 5 min 2 Base query structure 10 min 3 Row transformation 15 min 4 Exclusion filter 10 min 5 Performer filter 10 min 6 Tag/Studio/Group filters 15 min 7 User data filters 15 min 8 Sort clause builder 10 min 9 ID and metadata filters 10 min 10 Relation population 20 min 11 Integration tests 15 min 12 Wire to findScenes 10 min 13 Wire to carousel 10 min 14 End-to-end testing 15 min 15 Remove feature flag 10 min <p>Total: ~170 minutes (~3 hours)</p>"},{"location":"plans/2025-12-09-sql-native-scene-queries/#success-criteria","title":"Success Criteria","text":"<ul> <li> Homepage loads in &lt;2s (currently 30-40s)</li> <li> Browse with filters responds in &lt;500ms (currently 5-15s)</li> <li> Random sort pagination is stable (same seed = same order)</li> <li> All existing tests pass</li> <li> No regressions in filtering behavior</li> </ul>"},{"location":"plans/2025-12-09-sqlite-performance-brainstorm/","title":"Brainstorm: Peek SQLite Performance Architecture","text":""},{"location":"plans/2025-12-09-sqlite-performance-brainstorm/#project-overview","title":"Project Overview","text":"<p>Peek Stash Browser is a web application for browsing and streaming media from Stash (a self-hosted media organizer). It runs as a Docker container with: - Frontend: React 19, Vite - Backend: Node.js/Express, TypeScript, Prisma 6, SQLite - Video: FFmpeg for HLS transcoding</p>"},{"location":"plans/2025-12-09-sqlite-performance-brainstorm/#the-scaling-journey-so-far","title":"The Scaling Journey So Far","text":"<p>Original problem: Peek cached all Stash entities in-memory using JavaScript Maps. This failed at ~50k scenes due to Node.js string limits (~512MB) when parsing GraphQL responses.</p> <p>Solution implemented: SQLite entity cache that syncs from Stash: - Paginated sync fetches entities in batches of 5000 - Stores scenes, performers, tags, studios in normalized tables with junction tables - SceneQueryBuilder generates raw SQL to push filtering/sorting/pagination to the database - Has proper indexes on all filterable/sortable columns</p> <p>Current state: - Sync works correctly - 22k scenes stored in SQLite - SQL queries are correct (verified via EXPLAIN QUERY PLAN - uses indexes) - But queries take 8-18 seconds instead of &lt;500ms</p>"},{"location":"plans/2025-12-09-sqlite-performance-brainstorm/#the-performance-problem","title":"The Performance Problem","text":"<p>Server logs show the raw SQLite query time is the bottleneck:</p> <pre><code>SceneQueryBuilder.execute complete {\n  \"queryTimeMs\": 18641,\n  \"breakdown\": {\n    \"queryMs\": 18574,  // &lt;-- The SQL query itself takes 18 seconds\n    \"countMs\": 31,\n    \"transformMs\": 1,\n    \"relationsMs\": 35\n  }\n}\n</code></pre> <p>This isn't Node.js processing overhead - it's SQLite I/O.</p>"},{"location":"plans/2025-12-09-sqlite-performance-brainstorm/#architecture-details","title":"Architecture Details","text":"<p>Database location: SQLite file on a Windows Docker bind mount <pre><code># docker-compose.yml\nvolumes:\n  - ${PEEK_DATA_DIR:-C:/Users/charl/.peek-data}:/app/data  # Contains peek-stash-browser.db\n</code></pre></p> <p>ORM: Prisma 6 with <code>$queryRawUnsafe</code> for the SceneQueryBuilder</p> <p>Comparison point: Stash itself runs Go + SQLite in Docker with bind mounts and queries are fast. Key differences: - Go uses mattn/go-sqlite3 (CGO native bindings) - Prisma uses a separate Rust-based query engine binary - Stash queries their own schema; Peek queries a synced copy</p>"},{"location":"plans/2025-12-09-sqlite-performance-brainstorm/#what-needs-brainstorming","title":"What Needs Brainstorming","text":"<ol> <li> <p>Root cause confirmation: Is this definitively a bind mount I/O issue, or could Prisma/query structure be contributing?</p> </li> <li> <p>Prisma alternatives: Would better-sqlite3 (synchronous native bindings) perform better? Trade-offs?</p> </li> <li> <p>SQLite tuning: PRAGMA settings that could help:</p> </li> <li>WAL mode vs journal mode</li> <li>Cache size</li> <li>mmap_size</li> <li> <p>synchronous settings</p> </li> <li> <p>Volume/storage alternatives:</p> </li> <li>Docker named volumes vs bind mounts</li> <li>SQLite in a tmpfs with periodic flush to disk</li> <li>Database file inside container (loses persistence)</li> <li> <p>Run Node server natively on Windows instead of Docker</p> </li> <li> <p>Architecture alternatives:</p> </li> <li>Client-server database (PostgreSQL) instead of embedded SQLite</li> <li>In-memory cache backed by SQLite (query memory, persist to disk)</li> <li>LRU cache layer in front of SQLite</li> <li> <p>Different query patterns (denormalized tables, materialized views)</p> </li> <li> <p>Hybrid approaches:</p> </li> <li>Keep scene IDs + minimal metadata in memory, full data in SQLite</li> <li>Pre-compute filtered result sets</li> <li>Background refresh instead of on-demand queries</li> </ol>"},{"location":"plans/2025-12-09-sqlite-performance-brainstorm/#constraints","title":"Constraints","text":"<ul> <li>Must work in Docker: FFmpeg dependency requires it</li> <li>Must scale to 100k+ scenes: The original in-memory approach hit a wall at 50k</li> <li>Must survive restarts: Can't re-sync 100k scenes from Stash every startup (takes 10+ minutes)</li> <li>Single-user deployment typical: Multi-node/Redis overkill for most users</li> <li>Developer runs Windows: Production likely Linux, but dev experience matters</li> </ul>"},{"location":"plans/2025-12-09-sqlite-performance-brainstorm/#key-files-to-reference","title":"Key Files to Reference","text":"<ul> <li><code>server/services/SceneQueryBuilder.ts</code> - Raw SQL query builder (1000+ lines)</li> <li><code>server/services/CachedEntityQueryService.ts</code> - Prisma-based entity queries</li> <li><code>server/prisma/schema.prisma</code> - Database schema with indexes</li> <li><code>docker-compose.yml</code> - Volume configuration</li> <li><code>docs/design/cache-scalability-brainstorm.md</code> - Original design exploration</li> <li><code>docs/design/cache-scalability-plan.md</code> - Implementation plan we followed</li> </ul>"},{"location":"plans/2025-12-09-sqlite-performance-brainstorm/#success-criteria","title":"Success Criteria","text":"<ul> <li>Scene browse/carousel queries complete in &lt;500ms for 100k scene library</li> <li>Stable architecture we can build features on without performance anxiety</li> <li>Clear understanding of trade-offs for chosen approach</li> </ul>"},{"location":"plans/2025-12-09-sqlite-performance-brainstorm/#questions-to-answer","title":"Questions to Answer","text":"<ol> <li>What's the most likely root cause of the 8-18 second query times?</li> <li>What's the fastest path to acceptable performance with minimal architectural change?</li> <li>If we need bigger changes, what's the right long-term architecture?</li> <li>Are there quick wins (PRAGMA settings, connection pooling) worth trying first?</li> </ol>"},{"location":"plans/2025-12-09-sqlite-performance-design/","title":"Design: SQLite Performance on Windows Docker","text":""},{"location":"plans/2025-12-09-sqlite-performance-design/#problem","title":"Problem","text":"<p>SQLite queries in Peek took 8-18 seconds on Windows Docker Desktop, making the app unusable for development. Target was &lt;500ms.</p>"},{"location":"plans/2025-12-09-sqlite-performance-design/#root-cause","title":"Root Cause","text":"<p>Docker bind mounts on Windows go through WSL2's 9P filesystem protocol, which has extremely poor I/O performance for database workloads. SQLite's temp B-tree operations for sorting hit this especially hard.</p> <p>Benchmark results:</p> Storage Location Query Time Windows bind mount 7,000-18,000 ms Docker named volume 55-115 ms Container /tmp 68 ms <p>The 100x+ performance difference is entirely I/O, not query structure or Prisma overhead.</p>"},{"location":"plans/2025-12-09-sqlite-performance-design/#solution","title":"Solution","text":"<p>Use Docker named volumes on Windows, bind mounts on Linux/Unraid.</p> <p>Files changed: - <code>docker-compose.yml</code> - Uses bind mount (production default, fast on Linux) - <code>docker-compose.windows.yml</code> - Override that uses named volume for Windows dev</p> <p>Usage:</p> <pre><code># Linux/Unraid (production)\ndocker-compose up -d\n\n# Windows (development)\ndocker-compose -f docker-compose.yml -f docker-compose.windows.yml up -d\n</code></pre>"},{"location":"plans/2025-12-09-sqlite-performance-design/#why-this-works","title":"Why This Works","text":"<ul> <li>Linux/Unraid: Bind mounts use native filesystem, no performance penalty</li> <li>Windows: Named volumes live in WSL2's ext4 filesystem, bypassing 9P protocol</li> </ul>"},{"location":"plans/2025-12-09-sqlite-performance-design/#migration-for-windows-users","title":"Migration for Windows Users","text":"<p>One-time setup to copy existing data into the named volume:</p> <pre><code>docker volume create peek-stash-browser_peek-data\ndocker run --rm \\\n  -v peek-stash-browser_peek-data:/data \\\n  -v \"C:/Users/YOU/.peek-data:/source:ro\" \\\n  alpine cp -av /source/. /data/\n</code></pre>"},{"location":"plans/2025-12-09-sqlite-performance-design/#trade-offs","title":"Trade-offs","text":"Aspect Bind Mount Named Volume Performance (Windows) Poor Excellent Performance (Linux) Excellent Excellent File access Direct folder access Need <code>docker cp</code> Backup Simple file copy Volume backup tools Unraid compatibility Native appdata path Works but non-standard"},{"location":"plans/2025-12-09-sqlite-performance-design/#alternatives-considered","title":"Alternatives Considered","text":"<ol> <li>SQLite PRAGMA tuning - Would not help; problem is I/O layer, not SQLite config</li> <li>Replace Prisma with better-sqlite3 - Would not help; raw sqlite3 CLI had same issue</li> <li>PostgreSQL - Overkill for single-user app, adds deployment complexity</li> <li>In-memory DB with periodic flush - Risk of data loss, complex implementation</li> </ol>"},{"location":"plans/2025-12-09-sqlite-performance-design/#success-criteria","title":"Success Criteria","text":"<ul> <li> Queries complete in &lt;500ms on Windows dev environment</li> <li> No change required for Linux/Unraid production users</li> <li> Existing data can be migrated</li> </ul>"},{"location":"plans/2025-12-10-sqlite-architecture-refactor/","title":"SQLite Architecture Refactor Implementation Plan","text":"<p>For Claude: REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.</p> <p>Goal: Refactor from incremental migrations to a clean single migration with table renames (Cached* -&gt; Stash*), add missing junction tables for tags, remove denormalized counts, standardize on rating100, and rename pathMapping.ts to stashUrlProxy.ts.</p> <p>Architecture: Squash 6 existing cache migrations into one clean migration that creates all Stash* tables, junction tables, and FTS5 search. Update all services to reference new table names. Normalize counts (computed via JOINs instead of stored). Keep URL proxy utility but rename it for clarity.</p> <p>Tech Stack: Prisma 6, SQLite, TypeScript, Vitest, Express</p>"},{"location":"plans/2025-12-10-sqlite-architecture-refactor/#session-1-schema-migration","title":"Session 1: Schema + Migration","text":""},{"location":"plans/2025-12-10-sqlite-architecture-refactor/#task-1-delete-old-cache-migrations","title":"Task 1: Delete Old Cache Migrations","text":"<p>Files: - Delete: <code>server/prisma/migrations/20251208160610_add_cached_entities/</code> - Delete: <code>server/prisma/migrations/20251208160700_add_fts5_search/</code> - Delete: <code>server/prisma/migrations/20251209000000_eliminate_json_blob/</code> - Delete: <code>server/prisma/migrations/20251209100000_remove_junction_fk_constraints/</code> - Delete: <code>server/prisma/migrations/20251209150000_add_entity_tags_and_gallery_performers/</code> - Delete: <code>server/prisma/migrations/20251210180000_add_missing_entity_count_fields/</code></p> <p>Step 1: Delete the migration directories</p> <pre><code>rm -rf server/prisma/migrations/20251208160610_add_cached_entities\nrm -rf server/prisma/migrations/20251208160700_add_fts5_search\nrm -rf server/prisma/migrations/20251209000000_eliminate_json_blob\nrm -rf server/prisma/migrations/20251209100000_remove_junction_fk_constraints\nrm -rf server/prisma/migrations/20251209150000_add_entity_tags_and_gallery_performers\nrm -rf server/prisma/migrations/20251210180000_add_missing_entity_count_fields\n</code></pre> <p>Step 2: Verify deletions</p> <p>Run: <code>ls server/prisma/migrations/</code> Expected: Only <code>0_baseline/</code> and <code>20251126202944_add_user_carousel/</code> remain</p> <p>Step 3: Commit</p> <pre><code>git add -A\ngit commit -m \"chore: remove incremental cache migrations for squash\"\n</code></pre>"},{"location":"plans/2025-12-10-sqlite-architecture-refactor/#task-2-update-prisma-schema-rename-tables","title":"Task 2: Update Prisma Schema - Rename Tables","text":"<p>Files: - Modify: <code>server/prisma/schema.prisma</code></p> <p>Step 1: Rename CachedScene to StashScene</p> <p>Find all occurrences of <code>CachedScene</code> and replace with <code>StashScene</code>: - Model name: <code>model CachedScene</code> -&gt; <code>model StashScene</code> - Relations in junction tables: <code>CachedScene</code> -&gt; <code>StashScene</code></p> <p>Step 2: Rename CachedPerformer to StashPerformer</p> <p>Find all occurrences of <code>CachedPerformer</code> and replace with <code>StashPerformer</code>.</p> <p>Step 3: Rename CachedStudio to StashStudio</p> <p>Find all occurrences of <code>CachedStudio</code> and replace with <code>StashStudio</code>.</p> <p>Step 4: Rename CachedTag to StashTag</p> <p>Find all occurrences of <code>CachedTag</code> and replace with <code>StashTag</code>.</p> <p>Step 5: Rename CachedGroup to StashGroup</p> <p>Find all occurrences of <code>CachedGroup</code> and replace with <code>StashGroup</code>.</p> <p>Step 6: Rename CachedGallery to StashGallery</p> <p>Find all occurrences of <code>CachedGallery</code> and replace with <code>StashGallery</code>.</p> <p>Step 7: Rename CachedImage to StashImage</p> <p>Find all occurrences of <code>CachedImage</code> and replace with <code>StashImage</code>.</p> <p>Step 8: Validate schema syntax</p> <p>Run: <code>cd server &amp;&amp; npx prisma validate</code> Expected: \"The Prisma schema is valid.\"</p> <p>Step 9: Commit</p> <pre><code>git add server/prisma/schema.prisma\ngit commit -m \"refactor: rename Cached* tables to Stash* prefix\"\n</code></pre>"},{"location":"plans/2025-12-10-sqlite-architecture-refactor/#task-3-update-prisma-schema-add-tag-junction-tables","title":"Task 3: Update Prisma Schema - Add Tag Junction Tables","text":"<p>Files: - Modify: <code>server/prisma/schema.prisma</code></p> <p>Step 1: Add PerformerTag junction table</p> <p>Add after GalleryPerformer model:</p> <pre><code>model PerformerTag {\n    performerId     String\n    tagId           String\n    performer       StashPerformer @relation(fields: [performerId], references: [id], onDelete: Cascade)\n    tag             StashTag       @relation(fields: [tagId], references: [id], onDelete: Cascade)\n\n    @@id([performerId, tagId])\n    @@index([tagId])\n}\n</code></pre> <p>Step 2: Add StudioTag junction table</p> <pre><code>model StudioTag {\n    studioId        String\n    tagId           String\n    studio          StashStudio    @relation(fields: [studioId], references: [id], onDelete: Cascade)\n    tag             StashTag       @relation(fields: [tagId], references: [id], onDelete: Cascade)\n\n    @@id([studioId, tagId])\n    @@index([tagId])\n}\n</code></pre> <p>Step 3: Add GalleryTag junction table</p> <pre><code>model GalleryTag {\n    galleryId       String\n    tagId           String\n    gallery         StashGallery   @relation(fields: [galleryId], references: [id], onDelete: Cascade)\n    tag             StashTag       @relation(fields: [tagId], references: [id], onDelete: Cascade)\n\n    @@id([galleryId, tagId])\n    @@index([tagId])\n}\n</code></pre> <p>Step 4: Add GroupTag junction table</p> <pre><code>model GroupTag {\n    groupId         String\n    tagId           String\n    group           StashGroup     @relation(fields: [groupId], references: [id], onDelete: Cascade)\n    tag             StashTag       @relation(fields: [tagId], references: [id], onDelete: Cascade)\n\n    @@id([groupId, tagId])\n    @@index([tagId])\n}\n</code></pre> <p>Step 5: Add relations to StashPerformer</p> <p>In <code>StashPerformer</code> model, add: <pre><code>    tags            PerformerTag[]\n</code></pre></p> <p>Step 6: Add relations to StashStudio</p> <p>In <code>StashStudio</code> model, add: <pre><code>    tags            StudioTag[]\n</code></pre></p> <p>Step 7: Add relations to StashGallery</p> <p>In <code>StashGallery</code> model, add: <pre><code>    tags            GalleryTag[]\n</code></pre></p> <p>Step 8: Add relations to StashGroup</p> <p>In <code>StashGroup</code> model, add: <pre><code>    tags            GroupTag[]\n</code></pre></p> <p>Step 9: Add relations to StashTag</p> <p>In <code>StashTag</code> model, add: <pre><code>    performers      PerformerTag[]\n    studios         StudioTag[]\n    galleries       GalleryTag[]\n    groups          GroupTag[]\n</code></pre></p> <p>Step 10: Validate schema syntax</p> <p>Run: <code>cd server &amp;&amp; npx prisma validate</code> Expected: \"The Prisma schema is valid.\"</p> <p>Step 11: Commit</p> <pre><code>git add server/prisma/schema.prisma\ngit commit -m \"feat: add tag junction tables (PerformerTag, StudioTag, GalleryTag, GroupTag)\"\n</code></pre>"},{"location":"plans/2025-12-10-sqlite-architecture-refactor/#task-4-update-prisma-schema-remove-denormalized-count-fields","title":"Task 4: Update Prisma Schema - Remove Denormalized Count Fields","text":"<p>Files: - Modify: <code>server/prisma/schema.prisma</code></p> <p>Step 1: Remove count fields from StashPerformer</p> <p>Remove these lines from <code>StashPerformer</code>: <pre><code>    sceneCount      Int       @default(0)\n    imageCount      Int       @default(0)\n    galleryCount    Int       @default(0)\n    groupCount      Int       @default(0)\n</code></pre></p> <p>Also remove the index: <pre><code>    @@index([sceneCount])\n</code></pre></p> <p>Step 2: Remove count fields from StashStudio</p> <p>Remove these lines from <code>StashStudio</code>: <pre><code>    sceneCount      Int       @default(0)\n    imageCount      Int       @default(0)\n    galleryCount    Int       @default(0)\n    performerCount  Int       @default(0)\n    groupCount      Int       @default(0)\n</code></pre></p> <p>Also remove the index: <pre><code>    @@index([sceneCount])\n</code></pre></p> <p>Step 3: Remove count fields from StashTag</p> <p>Remove these lines from <code>StashTag</code>: <pre><code>    sceneCount      Int       @default(0)\n    imageCount      Int       @default(0)\n    galleryCount    Int       @default(0)\n    performerCount  Int       @default(0)\n    studioCount     Int       @default(0)\n    groupCount      Int       @default(0)\n    sceneMarkerCount Int      @default(0)\n</code></pre></p> <p>Also remove the index: <pre><code>    @@index([sceneCount])\n</code></pre></p> <p>Step 4: Remove count fields from StashGroup</p> <p>Remove these lines from <code>StashGroup</code>: <pre><code>    sceneCount      Int       @default(0)\n    performerCount  Int       @default(0)\n</code></pre></p> <p>Also remove the index: <pre><code>    @@index([sceneCount])\n</code></pre></p> <p>Step 5: Remove count field from StashGallery</p> <p>Remove this line from <code>StashGallery</code>: <pre><code>    imageCount      Int       @default(0)\n</code></pre></p> <p>Also remove the index: <pre><code>    @@index([imageCount])\n</code></pre></p> <p>Step 6: Validate schema syntax</p> <p>Run: <code>cd server &amp;&amp; npx prisma validate</code> Expected: \"The Prisma schema is valid.\"</p> <p>Step 7: Commit</p> <pre><code>git add server/prisma/schema.prisma\ngit commit -m \"refactor: remove denormalized count fields (will compute via JOINs)\"\n</code></pre>"},{"location":"plans/2025-12-10-sqlite-architecture-refactor/#task-5-update-prisma-schema-remove-tagids-json-fields","title":"Task 5: Update Prisma Schema - Remove tagIds JSON Fields","text":"<p>Files: - Modify: <code>server/prisma/schema.prisma</code></p> <p>Step 1: Remove tagIds from StashPerformer</p> <p>Remove this line from <code>StashPerformer</code>: <pre><code>    tagIds          String?                          // JSON array of tag IDs\n</code></pre></p> <p>Step 2: Remove tagIds from StashStudio</p> <p>Remove this line from <code>StashStudio</code>: <pre><code>    tagIds          String?                          // JSON array of tag IDs\n</code></pre></p> <p>Step 3: Remove tagIds from StashGroup</p> <p>Remove this line from <code>StashGroup</code>: <pre><code>    tagIds          String?                          // JSON array of tag IDs\n</code></pre></p> <p>Step 4: Remove tagIds from StashGallery</p> <p>Remove this line from <code>StashGallery</code>: <pre><code>    tagIds          String?                          // JSON array of tag IDs\n</code></pre></p> <p>Step 5: Validate schema syntax</p> <p>Run: <code>cd server &amp;&amp; npx prisma validate</code> Expected: \"The Prisma schema is valid.\"</p> <p>Step 6: Commit</p> <pre><code>git add server/prisma/schema.prisma\ngit commit -m \"refactor: remove tagIds JSON columns (replaced by junction tables)\"\n</code></pre>"},{"location":"plans/2025-12-10-sqlite-architecture-refactor/#task-6-update-prisma-schema-remove-deprecated-data-field","title":"Task 6: Update Prisma Schema - Remove Deprecated data Field","text":"<p>Files: - Modify: <code>server/prisma/schema.prisma</code></p> <p>Step 1: Remove data field from all Stash* models</p> <p>Remove from StashScene, StashPerformer, StashStudio, StashTag, StashGroup, StashGallery, StashImage: <pre><code>    data            String    @default(\"{}\")         // DEPRECATED: JSON blob\n</code></pre></p> <p>Step 2: Validate schema syntax</p> <p>Run: <code>cd server &amp;&amp; npx prisma validate</code> Expected: \"The Prisma schema is valid.\"</p> <p>Step 3: Commit</p> <pre><code>git add server/prisma/schema.prisma\ngit commit -m \"refactor: remove deprecated data JSON blob field\"\n</code></pre>"},{"location":"plans/2025-12-10-sqlite-architecture-refactor/#task-7-create-squashed-migration-file","title":"Task 7: Create Squashed Migration File","text":"<p>Files: - Create: <code>server/prisma/migrations/20251211000000_stash_entities/migration.sql</code></p> <p>Step 1: Create migration directory</p> <pre><code>mkdir -p server/prisma/migrations/20251211000000_stash_entities\n</code></pre> <p>Step 2: Write the complete migration SQL</p> <p>Create <code>server/prisma/migrations/20251211000000_stash_entities/migration.sql</code> with all table definitions:</p> <pre><code>-- CreateTable: StashScene\nCREATE TABLE \"StashScene\" (\n    \"id\" TEXT NOT NULL PRIMARY KEY,\n    \"stashInstanceId\" TEXT,\n    \"title\" TEXT,\n    \"code\" TEXT,\n    \"date\" TEXT,\n    \"studioId\" TEXT,\n    \"rating100\" INTEGER,\n    \"duration\" INTEGER,\n    \"organized\" BOOLEAN NOT NULL DEFAULT false,\n    \"details\" TEXT,\n    \"filePath\" TEXT,\n    \"fileBitRate\" INTEGER,\n    \"fileFrameRate\" REAL,\n    \"fileWidth\" INTEGER,\n    \"fileHeight\" INTEGER,\n    \"fileVideoCodec\" TEXT,\n    \"fileAudioCodec\" TEXT,\n    \"fileSize\" BIGINT,\n    \"pathScreenshot\" TEXT,\n    \"pathPreview\" TEXT,\n    \"pathSprite\" TEXT,\n    \"pathVtt\" TEXT,\n    \"pathChaptersVtt\" TEXT,\n    \"pathStream\" TEXT,\n    \"pathCaption\" TEXT,\n    \"streams\" TEXT,\n    \"oCounter\" INTEGER NOT NULL DEFAULT 0,\n    \"playCount\" INTEGER NOT NULL DEFAULT 0,\n    \"playDuration\" REAL NOT NULL DEFAULT 0,\n    \"stashCreatedAt\" DATETIME,\n    \"stashUpdatedAt\" DATETIME,\n    \"syncedAt\" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,\n    \"deletedAt\" DATETIME\n);\n\n-- CreateTable: StashPerformer\nCREATE TABLE \"StashPerformer\" (\n    \"id\" TEXT NOT NULL PRIMARY KEY,\n    \"stashInstanceId\" TEXT,\n    \"name\" TEXT NOT NULL,\n    \"disambiguation\" TEXT,\n    \"gender\" TEXT,\n    \"birthdate\" TEXT,\n    \"favorite\" BOOLEAN NOT NULL DEFAULT false,\n    \"rating100\" INTEGER,\n    \"details\" TEXT,\n    \"aliasList\" TEXT,\n    \"country\" TEXT,\n    \"ethnicity\" TEXT,\n    \"hairColor\" TEXT,\n    \"eyeColor\" TEXT,\n    \"heightCm\" INTEGER,\n    \"weightKg\" INTEGER,\n    \"measurements\" TEXT,\n    \"tattoos\" TEXT,\n    \"piercings\" TEXT,\n    \"careerLength\" TEXT,\n    \"deathDate\" TEXT,\n    \"url\" TEXT,\n    \"imagePath\" TEXT,\n    \"stashCreatedAt\" DATETIME,\n    \"stashUpdatedAt\" DATETIME,\n    \"syncedAt\" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,\n    \"deletedAt\" DATETIME\n);\n\n-- CreateTable: StashStudio\nCREATE TABLE \"StashStudio\" (\n    \"id\" TEXT NOT NULL PRIMARY KEY,\n    \"stashInstanceId\" TEXT,\n    \"name\" TEXT NOT NULL,\n    \"parentId\" TEXT,\n    \"favorite\" BOOLEAN NOT NULL DEFAULT false,\n    \"rating100\" INTEGER,\n    \"details\" TEXT,\n    \"url\" TEXT,\n    \"imagePath\" TEXT,\n    \"stashCreatedAt\" DATETIME,\n    \"stashUpdatedAt\" DATETIME,\n    \"syncedAt\" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,\n    \"deletedAt\" DATETIME\n);\n\n-- CreateTable: StashTag\nCREATE TABLE \"StashTag\" (\n    \"id\" TEXT NOT NULL PRIMARY KEY,\n    \"stashInstanceId\" TEXT,\n    \"name\" TEXT NOT NULL,\n    \"favorite\" BOOLEAN NOT NULL DEFAULT false,\n    \"description\" TEXT,\n    \"aliases\" TEXT,\n    \"parentIds\" TEXT,\n    \"imagePath\" TEXT,\n    \"stashCreatedAt\" DATETIME,\n    \"stashUpdatedAt\" DATETIME,\n    \"syncedAt\" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,\n    \"deletedAt\" DATETIME\n);\n\n-- CreateTable: StashGroup\nCREATE TABLE \"StashGroup\" (\n    \"id\" TEXT NOT NULL PRIMARY KEY,\n    \"stashInstanceId\" TEXT,\n    \"name\" TEXT NOT NULL,\n    \"date\" TEXT,\n    \"studioId\" TEXT,\n    \"rating100\" INTEGER,\n    \"duration\" INTEGER,\n    \"director\" TEXT,\n    \"synopsis\" TEXT,\n    \"urls\" TEXT,\n    \"frontImagePath\" TEXT,\n    \"backImagePath\" TEXT,\n    \"stashCreatedAt\" DATETIME,\n    \"stashUpdatedAt\" DATETIME,\n    \"syncedAt\" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,\n    \"deletedAt\" DATETIME\n);\n\n-- CreateTable: StashGallery\nCREATE TABLE \"StashGallery\" (\n    \"id\" TEXT NOT NULL PRIMARY KEY,\n    \"stashInstanceId\" TEXT,\n    \"title\" TEXT,\n    \"date\" TEXT,\n    \"studioId\" TEXT,\n    \"rating100\" INTEGER,\n    \"details\" TEXT,\n    \"url\" TEXT,\n    \"code\" TEXT,\n    \"folderPath\" TEXT,\n    \"coverPath\" TEXT,\n    \"stashCreatedAt\" DATETIME,\n    \"stashUpdatedAt\" DATETIME,\n    \"syncedAt\" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,\n    \"deletedAt\" DATETIME\n);\n\n-- CreateTable: StashImage\nCREATE TABLE \"StashImage\" (\n    \"id\" TEXT NOT NULL PRIMARY KEY,\n    \"stashInstanceId\" TEXT,\n    \"title\" TEXT,\n    \"date\" TEXT,\n    \"studioId\" TEXT,\n    \"rating100\" INTEGER,\n    \"oCounter\" INTEGER NOT NULL DEFAULT 0,\n    \"organized\" BOOLEAN NOT NULL DEFAULT false,\n    \"filePath\" TEXT,\n    \"width\" INTEGER,\n    \"height\" INTEGER,\n    \"fileSize\" BIGINT,\n    \"pathThumbnail\" TEXT,\n    \"pathPreview\" TEXT,\n    \"pathImage\" TEXT,\n    \"stashCreatedAt\" DATETIME,\n    \"stashUpdatedAt\" DATETIME,\n    \"syncedAt\" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,\n    \"deletedAt\" DATETIME\n);\n\n-- CreateTable: ScenePerformer\nCREATE TABLE \"ScenePerformer\" (\n    \"sceneId\" TEXT NOT NULL,\n    \"performerId\" TEXT NOT NULL,\n\n    PRIMARY KEY (\"sceneId\", \"performerId\"),\n    CONSTRAINT \"ScenePerformer_sceneId_fkey\" FOREIGN KEY (\"sceneId\") REFERENCES \"StashScene\" (\"id\") ON DELETE CASCADE ON UPDATE CASCADE,\n    CONSTRAINT \"ScenePerformer_performerId_fkey\" FOREIGN KEY (\"performerId\") REFERENCES \"StashPerformer\" (\"id\") ON DELETE CASCADE ON UPDATE CASCADE\n);\n\n-- CreateTable: SceneTag\nCREATE TABLE \"SceneTag\" (\n    \"sceneId\" TEXT NOT NULL,\n    \"tagId\" TEXT NOT NULL,\n\n    PRIMARY KEY (\"sceneId\", \"tagId\"),\n    CONSTRAINT \"SceneTag_sceneId_fkey\" FOREIGN KEY (\"sceneId\") REFERENCES \"StashScene\" (\"id\") ON DELETE CASCADE ON UPDATE CASCADE,\n    CONSTRAINT \"SceneTag_tagId_fkey\" FOREIGN KEY (\"tagId\") REFERENCES \"StashTag\" (\"id\") ON DELETE CASCADE ON UPDATE CASCADE\n);\n\n-- CreateTable: SceneGroup\nCREATE TABLE \"SceneGroup\" (\n    \"sceneId\" TEXT NOT NULL,\n    \"groupId\" TEXT NOT NULL,\n    \"sceneIndex\" INTEGER,\n\n    PRIMARY KEY (\"sceneId\", \"groupId\"),\n    CONSTRAINT \"SceneGroup_sceneId_fkey\" FOREIGN KEY (\"sceneId\") REFERENCES \"StashScene\" (\"id\") ON DELETE CASCADE ON UPDATE CASCADE,\n    CONSTRAINT \"SceneGroup_groupId_fkey\" FOREIGN KEY (\"groupId\") REFERENCES \"StashGroup\" (\"id\") ON DELETE CASCADE ON UPDATE CASCADE\n);\n\n-- CreateTable: SceneGallery\nCREATE TABLE \"SceneGallery\" (\n    \"sceneId\" TEXT NOT NULL,\n    \"galleryId\" TEXT NOT NULL,\n\n    PRIMARY KEY (\"sceneId\", \"galleryId\"),\n    CONSTRAINT \"SceneGallery_sceneId_fkey\" FOREIGN KEY (\"sceneId\") REFERENCES \"StashScene\" (\"id\") ON DELETE CASCADE ON UPDATE CASCADE,\n    CONSTRAINT \"SceneGallery_galleryId_fkey\" FOREIGN KEY (\"galleryId\") REFERENCES \"StashGallery\" (\"id\") ON DELETE CASCADE ON UPDATE CASCADE\n);\n\n-- CreateTable: ImagePerformer\nCREATE TABLE \"ImagePerformer\" (\n    \"imageId\" TEXT NOT NULL,\n    \"performerId\" TEXT NOT NULL,\n\n    PRIMARY KEY (\"imageId\", \"performerId\"),\n    CONSTRAINT \"ImagePerformer_imageId_fkey\" FOREIGN KEY (\"imageId\") REFERENCES \"StashImage\" (\"id\") ON DELETE CASCADE ON UPDATE CASCADE,\n    CONSTRAINT \"ImagePerformer_performerId_fkey\" FOREIGN KEY (\"performerId\") REFERENCES \"StashPerformer\" (\"id\") ON DELETE CASCADE ON UPDATE CASCADE\n);\n\n-- CreateTable: ImageTag\nCREATE TABLE \"ImageTag\" (\n    \"imageId\" TEXT NOT NULL,\n    \"tagId\" TEXT NOT NULL,\n\n    PRIMARY KEY (\"imageId\", \"tagId\"),\n    CONSTRAINT \"ImageTag_imageId_fkey\" FOREIGN KEY (\"imageId\") REFERENCES \"StashImage\" (\"id\") ON DELETE CASCADE ON UPDATE CASCADE,\n    CONSTRAINT \"ImageTag_tagId_fkey\" FOREIGN KEY (\"tagId\") REFERENCES \"StashTag\" (\"id\") ON DELETE CASCADE ON UPDATE CASCADE\n);\n\n-- CreateTable: ImageGallery\nCREATE TABLE \"ImageGallery\" (\n    \"imageId\" TEXT NOT NULL,\n    \"galleryId\" TEXT NOT NULL,\n\n    PRIMARY KEY (\"imageId\", \"galleryId\"),\n    CONSTRAINT \"ImageGallery_imageId_fkey\" FOREIGN KEY (\"imageId\") REFERENCES \"StashImage\" (\"id\") ON DELETE CASCADE ON UPDATE CASCADE,\n    CONSTRAINT \"ImageGallery_galleryId_fkey\" FOREIGN KEY (\"galleryId\") REFERENCES \"StashGallery\" (\"id\") ON DELETE CASCADE ON UPDATE CASCADE\n);\n\n-- CreateTable: GalleryPerformer\nCREATE TABLE \"GalleryPerformer\" (\n    \"galleryId\" TEXT NOT NULL,\n    \"performerId\" TEXT NOT NULL,\n\n    PRIMARY KEY (\"galleryId\", \"performerId\"),\n    CONSTRAINT \"GalleryPerformer_galleryId_fkey\" FOREIGN KEY (\"galleryId\") REFERENCES \"StashGallery\" (\"id\") ON DELETE CASCADE ON UPDATE CASCADE,\n    CONSTRAINT \"GalleryPerformer_performerId_fkey\" FOREIGN KEY (\"performerId\") REFERENCES \"StashPerformer\" (\"id\") ON DELETE CASCADE ON UPDATE CASCADE\n);\n\n-- CreateTable: PerformerTag\nCREATE TABLE \"PerformerTag\" (\n    \"performerId\" TEXT NOT NULL,\n    \"tagId\" TEXT NOT NULL,\n\n    PRIMARY KEY (\"performerId\", \"tagId\"),\n    CONSTRAINT \"PerformerTag_performerId_fkey\" FOREIGN KEY (\"performerId\") REFERENCES \"StashPerformer\" (\"id\") ON DELETE CASCADE ON UPDATE CASCADE,\n    CONSTRAINT \"PerformerTag_tagId_fkey\" FOREIGN KEY (\"tagId\") REFERENCES \"StashTag\" (\"id\") ON DELETE CASCADE ON UPDATE CASCADE\n);\n\n-- CreateTable: StudioTag\nCREATE TABLE \"StudioTag\" (\n    \"studioId\" TEXT NOT NULL,\n    \"tagId\" TEXT NOT NULL,\n\n    PRIMARY KEY (\"studioId\", \"tagId\"),\n    CONSTRAINT \"StudioTag_studioId_fkey\" FOREIGN KEY (\"studioId\") REFERENCES \"StashStudio\" (\"id\") ON DELETE CASCADE ON UPDATE CASCADE,\n    CONSTRAINT \"StudioTag_tagId_fkey\" FOREIGN KEY (\"tagId\") REFERENCES \"StashTag\" (\"id\") ON DELETE CASCADE ON UPDATE CASCADE\n);\n\n-- CreateTable: GalleryTag\nCREATE TABLE \"GalleryTag\" (\n    \"galleryId\" TEXT NOT NULL,\n    \"tagId\" TEXT NOT NULL,\n\n    PRIMARY KEY (\"galleryId\", \"tagId\"),\n    CONSTRAINT \"GalleryTag_galleryId_fkey\" FOREIGN KEY (\"galleryId\") REFERENCES \"StashGallery\" (\"id\") ON DELETE CASCADE ON UPDATE CASCADE,\n    CONSTRAINT \"GalleryTag_tagId_fkey\" FOREIGN KEY (\"tagId\") REFERENCES \"StashTag\" (\"id\") ON DELETE CASCADE ON UPDATE CASCADE\n);\n\n-- CreateTable: GroupTag\nCREATE TABLE \"GroupTag\" (\n    \"groupId\" TEXT NOT NULL,\n    \"tagId\" TEXT NOT NULL,\n\n    PRIMARY KEY (\"groupId\", \"tagId\"),\n    CONSTRAINT \"GroupTag_groupId_fkey\" FOREIGN KEY (\"groupId\") REFERENCES \"StashGroup\" (\"id\") ON DELETE CASCADE ON UPDATE CASCADE,\n    CONSTRAINT \"GroupTag_tagId_fkey\" FOREIGN KEY (\"tagId\") REFERENCES \"StashTag\" (\"id\") ON DELETE CASCADE ON UPDATE CASCADE\n);\n\n-- CreateTable: SyncState\nCREATE TABLE \"SyncState\" (\n    \"id\" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n    \"stashInstanceId\" TEXT,\n    \"entityType\" TEXT NOT NULL,\n    \"lastFullSync\" DATETIME,\n    \"lastIncrementalSync\" DATETIME,\n    \"lastSyncCount\" INTEGER NOT NULL DEFAULT 0,\n    \"lastSyncDurationMs\" INTEGER,\n    \"lastError\" TEXT,\n    \"totalEntities\" INTEGER NOT NULL DEFAULT 0\n);\n\n-- CreateTable: SyncSettings\nCREATE TABLE \"SyncSettings\" (\n    \"id\" INTEGER NOT NULL PRIMARY KEY DEFAULT 1,\n    \"syncIntervalMinutes\" INTEGER NOT NULL DEFAULT 60,\n    \"enableScanSubscription\" BOOLEAN NOT NULL DEFAULT true,\n    \"enablePluginWebhook\" BOOLEAN NOT NULL DEFAULT false,\n    \"updatedAt\" DATETIME NOT NULL\n);\n\n-- CreateIndex: StashScene indexes\nCREATE INDEX \"StashScene_studioId_idx\" ON \"StashScene\"(\"studioId\");\nCREATE INDEX \"StashScene_date_idx\" ON \"StashScene\"(\"date\");\nCREATE INDEX \"StashScene_stashCreatedAt_idx\" ON \"StashScene\"(\"stashCreatedAt\");\nCREATE INDEX \"StashScene_stashUpdatedAt_idx\" ON \"StashScene\"(\"stashUpdatedAt\");\nCREATE INDEX \"StashScene_rating100_idx\" ON \"StashScene\"(\"rating100\");\nCREATE INDEX \"StashScene_duration_idx\" ON \"StashScene\"(\"duration\");\nCREATE INDEX \"StashScene_deletedAt_idx\" ON \"StashScene\"(\"deletedAt\");\nCREATE INDEX \"StashScene_oCounter_idx\" ON \"StashScene\"(\"oCounter\");\nCREATE INDEX \"StashScene_playCount_idx\" ON \"StashScene\"(\"playCount\");\nCREATE INDEX \"StashScene_browse_idx\" ON \"StashScene\"(\"deletedAt\", \"stashCreatedAt\" DESC);\nCREATE INDEX \"StashScene_browse_updated_idx\" ON \"StashScene\"(\"deletedAt\", \"stashUpdatedAt\" DESC);\nCREATE INDEX \"StashScene_browse_date_idx\" ON \"StashScene\"(\"deletedAt\", \"date\" DESC);\nCREATE INDEX \"StashScene_browse_title_idx\" ON \"StashScene\"(\"deletedAt\", \"title\");\nCREATE INDEX \"StashScene_browse_duration_idx\" ON \"StashScene\"(\"deletedAt\", \"duration\" DESC);\n\n-- CreateIndex: StashPerformer indexes\nCREATE INDEX \"StashPerformer_name_idx\" ON \"StashPerformer\"(\"name\");\nCREATE INDEX \"StashPerformer_gender_idx\" ON \"StashPerformer\"(\"gender\");\nCREATE INDEX \"StashPerformer_favorite_idx\" ON \"StashPerformer\"(\"favorite\");\nCREATE INDEX \"StashPerformer_rating100_idx\" ON \"StashPerformer\"(\"rating100\");\nCREATE INDEX \"StashPerformer_stashUpdatedAt_idx\" ON \"StashPerformer\"(\"stashUpdatedAt\");\nCREATE INDEX \"StashPerformer_deletedAt_idx\" ON \"StashPerformer\"(\"deletedAt\");\n\n-- CreateIndex: StashStudio indexes\nCREATE INDEX \"StashStudio_name_idx\" ON \"StashStudio\"(\"name\");\nCREATE INDEX \"StashStudio_parentId_idx\" ON \"StashStudio\"(\"parentId\");\nCREATE INDEX \"StashStudio_favorite_idx\" ON \"StashStudio\"(\"favorite\");\nCREATE INDEX \"StashStudio_rating100_idx\" ON \"StashStudio\"(\"rating100\");\nCREATE INDEX \"StashStudio_stashUpdatedAt_idx\" ON \"StashStudio\"(\"stashUpdatedAt\");\nCREATE INDEX \"StashStudio_deletedAt_idx\" ON \"StashStudio\"(\"deletedAt\");\n\n-- CreateIndex: StashTag indexes\nCREATE INDEX \"StashTag_name_idx\" ON \"StashTag\"(\"name\");\nCREATE INDEX \"StashTag_favorite_idx\" ON \"StashTag\"(\"favorite\");\nCREATE INDEX \"StashTag_stashUpdatedAt_idx\" ON \"StashTag\"(\"stashUpdatedAt\");\nCREATE INDEX \"StashTag_deletedAt_idx\" ON \"StashTag\"(\"deletedAt\");\n\n-- CreateIndex: StashGroup indexes\nCREATE INDEX \"StashGroup_name_idx\" ON \"StashGroup\"(\"name\");\nCREATE INDEX \"StashGroup_date_idx\" ON \"StashGroup\"(\"date\");\nCREATE INDEX \"StashGroup_studioId_idx\" ON \"StashGroup\"(\"studioId\");\nCREATE INDEX \"StashGroup_rating100_idx\" ON \"StashGroup\"(\"rating100\");\nCREATE INDEX \"StashGroup_stashUpdatedAt_idx\" ON \"StashGroup\"(\"stashUpdatedAt\");\nCREATE INDEX \"StashGroup_deletedAt_idx\" ON \"StashGroup\"(\"deletedAt\");\n\n-- CreateIndex: StashGallery indexes\nCREATE INDEX \"StashGallery_title_idx\" ON \"StashGallery\"(\"title\");\nCREATE INDEX \"StashGallery_date_idx\" ON \"StashGallery\"(\"date\");\nCREATE INDEX \"StashGallery_studioId_idx\" ON \"StashGallery\"(\"studioId\");\nCREATE INDEX \"StashGallery_rating100_idx\" ON \"StashGallery\"(\"rating100\");\nCREATE INDEX \"StashGallery_stashUpdatedAt_idx\" ON \"StashGallery\"(\"stashUpdatedAt\");\nCREATE INDEX \"StashGallery_deletedAt_idx\" ON \"StashGallery\"(\"deletedAt\");\n\n-- CreateIndex: StashImage indexes\nCREATE INDEX \"StashImage_studioId_idx\" ON \"StashImage\"(\"studioId\");\nCREATE INDEX \"StashImage_date_idx\" ON \"StashImage\"(\"date\");\nCREATE INDEX \"StashImage_rating100_idx\" ON \"StashImage\"(\"rating100\");\nCREATE INDEX \"StashImage_stashUpdatedAt_idx\" ON \"StashImage\"(\"stashUpdatedAt\");\nCREATE INDEX \"StashImage_deletedAt_idx\" ON \"StashImage\"(\"deletedAt\");\n\n-- CreateIndex: Junction table indexes\nCREATE INDEX \"ScenePerformer_performerId_idx\" ON \"ScenePerformer\"(\"performerId\");\nCREATE INDEX \"SceneTag_tagId_idx\" ON \"SceneTag\"(\"tagId\");\nCREATE INDEX \"SceneGroup_groupId_idx\" ON \"SceneGroup\"(\"groupId\");\nCREATE INDEX \"SceneGallery_galleryId_idx\" ON \"SceneGallery\"(\"galleryId\");\nCREATE INDEX \"ImagePerformer_performerId_idx\" ON \"ImagePerformer\"(\"performerId\");\nCREATE INDEX \"ImageTag_tagId_idx\" ON \"ImageTag\"(\"tagId\");\nCREATE INDEX \"ImageGallery_galleryId_idx\" ON \"ImageGallery\"(\"galleryId\");\nCREATE INDEX \"GalleryPerformer_performerId_idx\" ON \"GalleryPerformer\"(\"performerId\");\nCREATE INDEX \"PerformerTag_tagId_idx\" ON \"PerformerTag\"(\"tagId\");\nCREATE INDEX \"StudioTag_tagId_idx\" ON \"StudioTag\"(\"tagId\");\nCREATE INDEX \"GalleryTag_tagId_idx\" ON \"GalleryTag\"(\"tagId\");\nCREATE INDEX \"GroupTag_tagId_idx\" ON \"GroupTag\"(\"tagId\");\n\n-- CreateIndex: SyncState unique constraint\nCREATE UNIQUE INDEX \"SyncState_stashInstanceId_entityType_key\" ON \"SyncState\"(\"stashInstanceId\", \"entityType\");\n\n-- FTS5 Virtual Table for scene search\nCREATE VIRTUAL TABLE IF NOT EXISTS scene_fts USING fts5(\n    id,\n    title,\n    details,\n    code,\n    content='StashScene',\n    content_rowid='rowid'\n);\n\n-- FTS5 Triggers for automatic sync\nCREATE TRIGGER IF NOT EXISTS scene_fts_insert AFTER INSERT ON StashScene BEGIN\n    INSERT INTO scene_fts(rowid, id, title, details, code)\n    VALUES (NEW.rowid, NEW.id, NEW.title, NEW.details, NEW.code);\nEND;\n\nCREATE TRIGGER IF NOT EXISTS scene_fts_delete AFTER DELETE ON StashScene BEGIN\n    INSERT INTO scene_fts(scene_fts, rowid, id, title, details, code)\n    VALUES ('delete', OLD.rowid, OLD.id, OLD.title, OLD.details, OLD.code);\nEND;\n\nCREATE TRIGGER IF NOT EXISTS scene_fts_update AFTER UPDATE ON StashScene BEGIN\n    INSERT INTO scene_fts(scene_fts, rowid, id, title, details, code)\n    VALUES ('delete', OLD.rowid, OLD.id, OLD.title, OLD.details, OLD.code);\n    INSERT INTO scene_fts(rowid, id, title, details, code)\n    VALUES (NEW.rowid, NEW.id, NEW.title, NEW.details, NEW.code);\nEND;\n</code></pre> <p>Step 3: Verify migration file exists</p> <p>Run: <code>ls -la server/prisma/migrations/20251211000000_stash_entities/</code> Expected: migration.sql file present</p> <p>Step 4: Commit</p> <pre><code>git add server/prisma/migrations/20251211000000_stash_entities/\ngit commit -m \"feat: add squashed stash_entities migration\"\n</code></pre>"},{"location":"plans/2025-12-10-sqlite-architecture-refactor/#task-8-verify-prisma-schema-consistency","title":"Task 8: Verify Prisma Schema Consistency","text":"<p>Files: - Test: <code>server/prisma/schema.prisma</code></p> <p>Step 1: Format schema</p> <p>Run: <code>cd server &amp;&amp; npx prisma format</code> Expected: Schema formatted successfully</p> <p>Step 2: Validate schema</p> <p>Run: <code>cd server &amp;&amp; npx prisma validate</code> Expected: \"The Prisma schema is valid.\"</p> <p>Step 3: Generate Prisma client</p> <p>Run: <code>cd server &amp;&amp; npx prisma generate</code> Expected: \"Generated Prisma Client\"</p> <p>Step 4: Commit any formatting changes</p> <pre><code>git add server/prisma/schema.prisma\ngit commit -m \"style: format prisma schema\" --allow-empty\n</code></pre>"},{"location":"plans/2025-12-10-sqlite-architecture-refactor/#session-2-server-code-refactor","title":"Session 2: Server Code Refactor","text":""},{"location":"plans/2025-12-10-sqlite-architecture-refactor/#task-9-rename-pathmappingts-to-stashurlproxyts","title":"Task 9: Rename pathMapping.ts to stashUrlProxy.ts","text":"<p>Files: - Rename: <code>server/utils/pathMapping.ts</code> -&gt; <code>server/utils/stashUrlProxy.ts</code> - Modify: <code>server/controllers/playlist.ts</code> - Modify: <code>server/controllers/library/galleries.ts</code> - Modify: <code>server/controllers/library/images.ts</code> - Modify: <code>server/services/StashCacheManager.ts</code> - Modify: <code>server/services/__tests__/StashSyncService.integration.test.ts</code></p> <p>Step 1: Rename the file</p> <pre><code>git mv server/utils/pathMapping.ts server/utils/stashUrlProxy.ts\n</code></pre> <p>Step 2: Update import in server/controllers/playlist.ts</p> <p>Find: <pre><code>import { transformScene } from \"../utils/pathMapping.js\";\n</code></pre></p> <p>Replace: <pre><code>import { transformScene } from \"../utils/stashUrlProxy.js\";\n</code></pre></p> <p>Step 3: Update import in server/controllers/library/galleries.ts</p> <p>Find: <pre><code>import { transformGallery } from \"../../utils/pathMapping.js\";\n</code></pre></p> <p>Replace: <pre><code>import { transformGallery } from \"../../utils/stashUrlProxy.js\";\n</code></pre></p> <p>Step 4: Update import in server/controllers/library/images.ts</p> <p>Find: <pre><code>import { transformImage } from \"../../utils/pathMapping.js\";\n</code></pre></p> <p>Replace: <pre><code>import { transformImage } from \"../../utils/stashUrlProxy.js\";\n</code></pre></p> <p>Step 5: Update import in server/services/StashCacheManager.ts</p> <p>Find: <pre><code>import { ... } from \"../utils/pathMapping.js\";\n</code></pre></p> <p>Replace: <pre><code>import { ... } from \"../utils/stashUrlProxy.js\";\n</code></pre></p> <p>Step 6: Update import in StashSyncService.integration.test.ts</p> <p>Find: <pre><code>import { ... } from \"../../utils/pathMapping.js\";\n</code></pre></p> <p>Replace: <pre><code>import { ... } from \"../../utils/stashUrlProxy.js\";\n</code></pre></p> <p>Step 7: Search for any other references</p> <p>Run: <code>cd server &amp;&amp; grep -r \"pathMapping\" --include=\"*.ts\" --include=\"*.js\"</code> Expected: No results (all imports updated)</p> <p>Step 8: Verify TypeScript compiles</p> <p>Run: <code>cd server &amp;&amp; npx tsc --noEmit</code> Expected: No errors</p> <p>Step 9: Commit</p> <pre><code>git add -A\ngit commit -m \"refactor: rename pathMapping.ts to stashUrlProxy.ts\"\n</code></pre>"},{"location":"plans/2025-12-10-sqlite-architecture-refactor/#task-10-update-cachedentityqueryservice-rename-to-stashentityservice","title":"Task 10: Update CachedEntityQueryService - Rename to StashEntityService","text":"<p>Files: - Rename: <code>server/services/CachedEntityQueryService.ts</code> -&gt; <code>server/services/StashEntityService.ts</code> - Modify: All files that import CachedEntityQueryService</p> <p>Step 1: Rename the file</p> <pre><code>git mv server/services/CachedEntityQueryService.ts server/services/StashEntityService.ts\n</code></pre> <p>Step 2: Update class name and export in the renamed file</p> <p>Find: <pre><code>class CachedEntityQueryService {\n</code></pre></p> <p>Replace: <pre><code>class StashEntityService {\n</code></pre></p> <p>Find: <pre><code>export const cachedEntityQueryService = new CachedEntityQueryService();\n</code></pre></p> <p>Replace: <pre><code>export const stashEntityService = new StashEntityService();\n</code></pre></p> <p>Step 3: Update all table references in StashEntityService.ts</p> <p>Replace all occurrences: - <code>CachedScene</code> -&gt; <code>StashScene</code> - <code>CachedPerformer</code> -&gt; <code>StashPerformer</code> - <code>CachedStudio</code> -&gt; <code>StashStudio</code> - <code>CachedTag</code> -&gt; <code>StashTag</code> - <code>CachedGroup</code> -&gt; <code>StashGroup</code> - <code>CachedGallery</code> -&gt; <code>StashGallery</code> - <code>CachedImage</code> -&gt; <code>StashImage</code> - <code>cachedScene</code> -&gt; <code>stashScene</code> - <code>cachedPerformer</code> -&gt; <code>stashPerformer</code> - <code>cachedStudio</code> -&gt; <code>stashStudio</code> - <code>cachedTag</code> -&gt; <code>stashTag</code> - <code>cachedGroup</code> -&gt; <code>stashGroup</code> - <code>cachedGallery</code> -&gt; <code>stashGallery</code> - <code>cachedImage</code> -&gt; <code>stashImage</code></p> <p>Step 4: Update imports across codebase</p> <p>Search and replace in all .ts files: <pre><code>// Old\nimport { cachedEntityQueryService } from \"./CachedEntityQueryService.js\";\nimport { cachedEntityQueryService } from \"../services/CachedEntityQueryService.js\";\n\n// New\nimport { stashEntityService } from \"./StashEntityService.js\";\nimport { stashEntityService } from \"../services/StashEntityService.js\";\n</code></pre></p> <p>Step 5: Verify TypeScript compiles</p> <p>Run: <code>cd server &amp;&amp; npx tsc --noEmit</code> Expected: No errors</p> <p>Step 6: Commit</p> <pre><code>git add -A\ngit commit -m \"refactor: rename CachedEntityQueryService to StashEntityService\"\n</code></pre>"},{"location":"plans/2025-12-10-sqlite-architecture-refactor/#task-11-update-stashsyncservice-table-references","title":"Task 11: Update StashSyncService - Table References","text":"<p>Files: - Modify: <code>server/services/StashSyncService.ts</code></p> <p>Step 1: Update all Prisma table references</p> <p>Replace all occurrences: - <code>prisma.cachedScene</code> -&gt; <code>prisma.stashScene</code> - <code>prisma.cachedPerformer</code> -&gt; <code>prisma.stashPerformer</code> - <code>prisma.cachedStudio</code> -&gt; <code>prisma.stashStudio</code> - <code>prisma.cachedTag</code> -&gt; <code>prisma.stashTag</code> - <code>prisma.cachedGroup</code> -&gt; <code>prisma.stashGroup</code> - <code>prisma.cachedGallery</code> -&gt; <code>prisma.stashGallery</code> - <code>prisma.cachedImage</code> -&gt; <code>prisma.stashImage</code></p> <p>Step 2: Update SQL string references</p> <p>Replace in raw SQL queries: - <code>\"CachedScene\"</code> -&gt; <code>\"StashScene\"</code> - <code>\"CachedPerformer\"</code> -&gt; <code>\"StashPerformer\"</code> - <code>\"CachedStudio\"</code> -&gt; <code>\"StashStudio\"</code> - <code>\"CachedTag\"</code> -&gt; <code>\"StashTag\"</code> - <code>\"CachedGroup\"</code> -&gt; <code>\"StashGroup\"</code> - <code>\"CachedGallery\"</code> -&gt; <code>\"StashGallery\"</code> - <code>\"CachedImage\"</code> -&gt; <code>\"StashImage\"</code></p> <p>Step 3: Remove count field updates</p> <p>Remove any code that updates: - <code>sceneCount</code> - <code>imageCount</code> - <code>galleryCount</code> - <code>groupCount</code> - <code>performerCount</code> - <code>studioCount</code> - <code>sceneMarkerCount</code></p> <p>Step 4: Add tag junction table syncing</p> <p>When syncing performers/studios/groups/galleries, add code to sync their tags to the new junction tables (PerformerTag, StudioTag, GroupTag, GalleryTag).</p> <p>Step 5: Verify TypeScript compiles</p> <p>Run: <code>cd server &amp;&amp; npx tsc --noEmit</code> Expected: No errors</p> <p>Step 6: Commit</p> <pre><code>git add server/services/StashSyncService.ts\ngit commit -m \"refactor: update StashSyncService for new table names and junction tables\"\n</code></pre>"},{"location":"plans/2025-12-10-sqlite-architecture-refactor/#task-12-update-scenequerybuilder-table-references","title":"Task 12: Update SceneQueryBuilder - Table References","text":"<p>Files: - Modify: <code>server/services/SceneQueryBuilder.ts</code></p> <p>Step 1: Update all SQL table references</p> <p>Replace all occurrences: - <code>CachedScene</code> -&gt; <code>StashScene</code> - <code>CachedPerformer</code> -&gt; <code>StashPerformer</code> - <code>CachedStudio</code> -&gt; <code>StashStudio</code> - <code>CachedTag</code> -&gt; <code>StashTag</code> - <code>CachedGroup</code> -&gt; <code>StashGroup</code> - <code>CachedGallery</code> -&gt; <code>StashGallery</code> - <code>CachedImage</code> -&gt; <code>StashImage</code></p> <p>Step 2: Verify TypeScript compiles</p> <p>Run: <code>cd server &amp;&amp; npx tsc --noEmit</code> Expected: No errors</p> <p>Step 3: Commit</p> <pre><code>git add server/services/SceneQueryBuilder.ts\ngit commit -m \"refactor: update SceneQueryBuilder for new table names\"\n</code></pre>"},{"location":"plans/2025-12-10-sqlite-architecture-refactor/#task-13-update-userrestrictionservice-table-references","title":"Task 13: Update UserRestrictionService - Table References","text":"<p>Files: - Modify: <code>server/services/UserRestrictionService.ts</code></p> <p>Step 1: Update all SQL table references</p> <p>Replace all occurrences: - <code>CachedScene</code> -&gt; <code>StashScene</code> - <code>CachedPerformer</code> -&gt; <code>StashPerformer</code> - <code>CachedStudio</code> -&gt; <code>StashStudio</code> - <code>CachedTag</code> -&gt; <code>StashTag</code> - <code>CachedGroup</code> -&gt; <code>StashGroup</code> - <code>CachedGallery</code> -&gt; <code>StashGallery</code> - <code>CachedImage</code> -&gt; <code>StashImage</code></p> <p>Step 2: Verify TypeScript compiles</p> <p>Run: <code>cd server &amp;&amp; npx tsc --noEmit</code> Expected: No errors</p> <p>Step 3: Commit</p> <pre><code>git add server/services/UserRestrictionService.ts\ngit commit -m \"refactor: update UserRestrictionService for new table names\"\n</code></pre>"},{"location":"plans/2025-12-10-sqlite-architecture-refactor/#task-14-update-stashcachemanager-table-references","title":"Task 14: Update StashCacheManager - Table References","text":"<p>Files: - Modify: <code>server/services/StashCacheManager.ts</code></p> <p>Step 1: Update all Prisma table references</p> <p>Replace all occurrences: - <code>prisma.cachedScene</code> -&gt; <code>prisma.stashScene</code> - <code>prisma.cachedPerformer</code> -&gt; <code>prisma.stashPerformer</code> - <code>prisma.cachedStudio</code> -&gt; <code>prisma.stashStudio</code> - <code>prisma.cachedTag</code> -&gt; <code>prisma.stashTag</code> - <code>prisma.cachedGroup</code> -&gt; <code>prisma.stashGroup</code> - <code>prisma.cachedGallery</code> -&gt; <code>prisma.stashGallery</code> - <code>prisma.cachedImage</code> -&gt; <code>prisma.stashImage</code></p> <p>Step 2: Verify TypeScript compiles</p> <p>Run: <code>cd server &amp;&amp; npx tsc --noEmit</code> Expected: No errors</p> <p>Step 3: Commit</p> <pre><code>git add server/services/StashCacheManager.ts\ngit commit -m \"refactor: update StashCacheManager for new table names\"\n</code></pre>"},{"location":"plans/2025-12-10-sqlite-architecture-refactor/#task-15-update-library-controllers-import-changes","title":"Task 15: Update Library Controllers - Import Changes","text":"<p>Files: - Modify: <code>server/controllers/library/scenes.ts</code> - Modify: <code>server/controllers/library/performers.ts</code> - Modify: <code>server/controllers/library/studios.ts</code> - Modify: <code>server/controllers/library/tags.ts</code> - Modify: <code>server/controllers/library/galleries.ts</code> - Modify: <code>server/controllers/library/groups.ts</code> - Modify: <code>server/controllers/library/images.ts</code></p> <p>Step 1: Update imports to use stashEntityService</p> <p>In each file, change: <pre><code>import { cachedEntityQueryService } from \"../../services/CachedEntityQueryService.js\";\n</code></pre> To: <pre><code>import { stashEntityService } from \"../../services/StashEntityService.js\";\n</code></pre></p> <p>Step 2: Update service calls</p> <p>Replace all <code>cachedEntityQueryService.</code> with <code>stashEntityService.</code></p> <p>Step 3: Verify TypeScript compiles</p> <p>Run: <code>cd server &amp;&amp; npx tsc --noEmit</code> Expected: No errors</p> <p>Step 4: Commit</p> <pre><code>git add server/controllers/library/\ngit commit -m \"refactor: update library controllers to use StashEntityService\"\n</code></pre>"},{"location":"plans/2025-12-10-sqlite-architecture-refactor/#task-16-update-other-services-and-controllers","title":"Task 16: Update Other Services and Controllers","text":"<p>Files: - Modify: <code>server/services/FilteredEntityCacheService.ts</code> - Modify: <code>server/services/UserHiddenEntityService.ts</code> - Modify: <code>server/services/UserStatsService.ts</code> - Modify: <code>server/services/SyncScheduler.ts</code> - Modify: <code>server/controllers/sync.ts</code> - Modify: Any other files referencing old names</p> <p>Step 1: Search for all remaining references</p> <p>Run: <code>cd server &amp;&amp; grep -r \"CachedEntityQueryService\\|cachedEntityQueryService\\|CachedScene\\|CachedPerformer\\|CachedStudio\\|CachedTag\\|CachedGroup\\|CachedGallery\\|CachedImage\" --include=\"*.ts\"</code></p> <p>Step 2: Update each file found</p> <p>For each file with old references: - Update imports - Update table/service references</p> <p>Step 3: Verify TypeScript compiles</p> <p>Run: <code>cd server &amp;&amp; npx tsc --noEmit</code> Expected: No errors</p> <p>Step 4: Commit</p> <pre><code>git add -A\ngit commit -m \"refactor: update remaining services for new naming convention\"\n</code></pre>"},{"location":"plans/2025-12-10-sqlite-architecture-refactor/#task-17-update-tests-table-and-service-references","title":"Task 17: Update Tests - Table and Service References","text":"<p>Files: - Modify: <code>server/services/__tests__/CachedEntityQueryService.test.ts</code> -&gt; rename and update - Modify: <code>server/services/__tests__/StashSyncService.integration.test.ts</code> - Modify: <code>server/tests/services/SceneQueryBuilder.test.ts</code> - Modify: <code>server/tests/services/SceneQueryBuilder.integration.test.ts</code> - Modify: Other test files</p> <p>Step 1: Rename CachedEntityQueryService.test.ts</p> <pre><code>git mv server/services/__tests__/CachedEntityQueryService.test.ts server/services/__tests__/StashEntityService.test.ts\n</code></pre> <p>Step 2: Update test file imports and references</p> <p>In the renamed test file: - Update import to use <code>StashEntityService</code> - Update mock table names to <code>StashScene</code>, etc. - Update variable names</p> <p>Step 3: Update other test files</p> <p>Search and update all test files for table name references.</p> <p>Step 4: Run tests</p> <p>Run: <code>cd server &amp;&amp; npm test</code> Expected: All tests pass (or skip integration tests as expected)</p> <p>Step 5: Commit</p> <pre><code>git add -A\ngit commit -m \"test: update tests for new naming convention\"\n</code></pre>"},{"location":"plans/2025-12-10-sqlite-architecture-refactor/#session-3-client-updates","title":"Session 3: Client Updates","text":""},{"location":"plans/2025-12-10-sqlite-architecture-refactor/#task-18-rename-cacheloadingbanner-to-syncprogressbanner","title":"Task 18: Rename CacheLoadingBanner to SyncProgressBanner","text":"<p>Files: - Rename: <code>client/src/components/ui/CacheLoadingBanner.jsx</code> -&gt; <code>client/src/components/ui/SyncProgressBanner.jsx</code> - Modify: All files that import CacheLoadingBanner</p> <p>Step 1: Rename the file</p> <pre><code>git mv client/src/components/ui/CacheLoadingBanner.jsx client/src/components/ui/SyncProgressBanner.jsx\n</code></pre> <p>Step 2: Update component name and default export</p> <p>In the renamed file, change: <pre><code>const CacheLoadingBanner = ({ message, className = \"\" }) =&gt; {\n</code></pre> To: <pre><code>const SyncProgressBanner = ({ message, className = \"\" }) =&gt; {\n</code></pre></p> <p>And: <pre><code>export default CacheLoadingBanner;\n</code></pre> To: <pre><code>export default SyncProgressBanner;\n</code></pre></p> <p>Step 3: Update default message text</p> <p>Change: <pre><code>{message || \"Server is loading cache, please wait...\"}\n</code></pre> To: <pre><code>{message || \"Syncing library, please wait...\"}\n</code></pre></p> <p>Change: <pre><code>This may take a minute on first startup. Checking every 5 seconds...\n</code></pre> To: <pre><code>This may take a minute on first sync. Checking every 5 seconds...\n</code></pre></p> <p>Step 4: Search for imports and update</p> <p>Run: <code>cd client &amp;&amp; grep -r \"CacheLoadingBanner\" --include=\"*.jsx\" --include=\"*.tsx\" --include=\"*.js\"</code></p> <p>Update each import found: <pre><code>// Old\nimport CacheLoadingBanner from \"../components/ui/CacheLoadingBanner\";\n// New\nimport SyncProgressBanner from \"../components/ui/SyncProgressBanner\";\n</code></pre></p> <p>And update JSX usage: <pre><code>// Old\n&lt;CacheLoadingBanner /&gt;\n// New\n&lt;SyncProgressBanner /&gt;\n</code></pre></p> <p>Step 5: Verify client builds</p> <p>Run: <code>cd client &amp;&amp; npm run build</code> Expected: Build succeeds</p> <p>Step 6: Commit</p> <pre><code>git add -A\ngit commit -m \"refactor: rename CacheLoadingBanner to SyncProgressBanner\"\n</code></pre>"},{"location":"plans/2025-12-10-sqlite-architecture-refactor/#task-19-update-client-terminology-cache-to-library","title":"Task 19: Update Client Terminology - Cache to Library","text":"<p>Files: - Modify: <code>client/src/components/settings/ServerStatsSection.jsx</code> - Modify: <code>client/src/pages/*.jsx</code> (pages that reference \"cache\") - Modify: Any other client files with \"cache\" terminology</p> <p>Step 1: Search for \"cache\" in user-facing strings</p> <p>Run: <code>cd client &amp;&amp; grep -rn \"cache\\|Cache\" --include=\"*.jsx\" --include=\"*.tsx\" --include=\"*.js\"</code></p> <p>Step 2: Update terminology in each file</p> <p>Replace user-facing strings: - \"cache\" -&gt; \"library\" (lowercase) - \"Cache\" -&gt; \"Library\" (capitalized) - \"loading cache\" -&gt; \"syncing library\" - \"refresh cache\" -&gt; \"sync library\" - \"cache ready\" -&gt; \"library ready\"</p> <p>Do NOT replace: - Variable names (keep internal code naming) - Technical comments - API endpoint names</p> <p>Step 3: Verify client builds</p> <p>Run: <code>cd client &amp;&amp; npm run build</code> Expected: Build succeeds</p> <p>Step 4: Commit</p> <pre><code>git add -A\ngit commit -m \"refactor: update client terminology from cache to library\"\n</code></pre>"},{"location":"plans/2025-12-10-sqlite-architecture-refactor/#task-20-run-linting-and-fix-issues","title":"Task 20: Run Linting and Fix Issues","text":"<p>Files: - All modified server files - All modified client files</p> <p>Step 1: Run server linting</p> <p>Run: <code>cd server &amp;&amp; npm run lint</code> Expected: No errors (fix any that appear)</p> <p>Step 2: Run client linting</p> <p>Run: <code>cd client &amp;&amp; npm run lint</code> Expected: No errors (fix any that appear)</p> <p>Step 3: Commit any lint fixes</p> <pre><code>git add -A\ngit commit -m \"style: fix linting issues\" --allow-empty\n</code></pre>"},{"location":"plans/2025-12-10-sqlite-architecture-refactor/#session-4-testing-and-documentation","title":"Session 4: Testing and Documentation","text":""},{"location":"plans/2025-12-10-sqlite-architecture-refactor/#task-21-delete-local-database-and-test-fresh-install","title":"Task 21: Delete Local Database and Test Fresh Install","text":"<p>Files: - Delete: <code>server/prisma/peek.db</code> (local development database)</p> <p>Step 1: Stop the application</p> <pre><code>docker-compose down\n</code></pre> <p>Step 2: Delete local database</p> <pre><code>rm -f server/prisma/peek.db server/prisma/peek.db-journal\n</code></pre> <p>Step 3: Start fresh</p> <pre><code>docker-compose up --build\n</code></pre> <p>Step 4: Verify migrations run</p> <p>Check logs for: \"Applied migration: 20251211000000_stash_entities\"</p> <p>Step 5: Verify app starts correctly</p> <p>Open http://localhost:5173 and verify the setup wizard appears (fresh install).</p>"},{"location":"plans/2025-12-10-sqlite-architecture-refactor/#task-22-run-all-tests","title":"Task 22: Run All Tests","text":"<p>Files: - All test files</p> <p>Step 1: Run server tests</p> <p>Run: <code>cd server &amp;&amp; npm test</code> Expected: All non-skipped tests pass</p> <p>Step 2: Run client tests</p> <p>Run: <code>cd client &amp;&amp; npm test</code> Expected: All tests pass</p> <p>Step 3: Fix any failing tests</p> <p>If tests fail, update them to match new naming/structure.</p> <p>Step 4: Commit test fixes</p> <pre><code>git add -A\ngit commit -m \"test: fix tests for refactored schema\" --allow-empty\n</code></pre>"},{"location":"plans/2025-12-10-sqlite-architecture-refactor/#task-23-update-readme-documentation","title":"Task 23: Update README Documentation","text":"<p>Files: - Modify: <code>README.md</code> - Modify: <code>CLAUDE.md</code> (if needed)</p> <p>Step 1: Update any cache references in README</p> <p>Search for \"cache\" in README.md and update user-facing terminology to \"library\" where appropriate.</p> <p>Step 2: Update CLAUDE.md if terminology changed</p> <p>Search for outdated terminology and update.</p> <p>Step 3: Commit</p> <pre><code>git add README.md CLAUDE.md\ngit commit -m \"docs: update terminology in documentation\" --allow-empty\n</code></pre>"},{"location":"plans/2025-12-10-sqlite-architecture-refactor/#task-24-final-verification-and-cleanup","title":"Task 24: Final Verification and Cleanup","text":"<p>Files: - All project files</p> <p>Step 1: Search for any remaining old references</p> <p>Run from project root: <pre><code>grep -r \"CachedScene\\|CachedPerformer\\|CachedStudio\\|CachedTag\\|CachedGroup\\|CachedGallery\\|CachedImage\\|CachedEntityQueryService\\|cachedEntityQueryService\\|pathMapping\" --include=\"*.ts\" --include=\"*.tsx\" --include=\"*.js\" --include=\"*.jsx\" server/ client/\n</code></pre></p> <p>Expected: No results</p> <p>Step 2: Verify Docker build works</p> <p>Run: <code>docker-compose build</code> Expected: Build succeeds</p> <p>Step 3: Full application test</p> <p>Run: <code>docker-compose up -d</code> - Verify API endpoints respond - Verify sync runs - Verify scene list loads - Verify performer list loads - Verify search works</p> <p>Step 4: Commit any final fixes</p> <pre><code>git add -A\ngit commit -m \"chore: final cleanup for schema refactor\" --allow-empty\n</code></pre>"},{"location":"plans/2025-12-10-sqlite-architecture-refactor/#summary","title":"Summary","text":"<p>Total Tasks: 24</p> <p>Breaking Changes: - Database tables renamed (Cached* -&gt; Stash*) - <code>pathMapping.ts</code> renamed to <code>stashUrlProxy.ts</code> - <code>CachedEntityQueryService</code> renamed to <code>StashEntityService</code> - Denormalized count fields removed (computed via JOINs now) - <code>tagIds</code> JSON fields removed (use junction tables) - <code>data</code> JSON blob field removed</p> <p>Migration Strategy: - All 6 incremental migrations squashed into single <code>20251211000000_stash_entities</code> migration - Users with existing databases will need to either:   1. Delete database and re-sync (recommended for beta users)   2. Wait for data migration script (if needed for production)</p> <p>Testing: - Run all unit tests - Run fresh install test - Run full application test with Docker</p>"},{"location":"plans/MULTI_INSTANCE_STASH/","title":"Multiple Stash Instances - Implementation Plan","text":"<p>Status: Deferred Created: 2025-11-25 Last Updated: 2025-11-25</p>"},{"location":"plans/MULTI_INSTANCE_STASH/#overview","title":"Overview","text":"<p>This document outlines the implementation plan for supporting multiple Stash server instances in Peek, allowing users to aggregate content from multiple Stash libraries into a unified browsing experience.</p>"},{"location":"plans/MULTI_INSTANCE_STASH/#current-state-commit-1-complete","title":"Current State (Commit 1 Complete)","text":"<ul> <li><code>StashInstance</code> model exists in database with UUID primary key</li> <li><code>StashInstanceManager</code> service manages connections</li> <li>Single instance enforcement in place (<code>configs.length &gt; 1</code> throws error)</li> <li>Auto-migration from env vars to database on first startup</li> <li>Setup wizard allows configuring first Stash instance</li> <li>Server Settings shows current instance (read-only)</li> </ul>"},{"location":"plans/MULTI_INSTANCE_STASH/#key-challenges","title":"Key Challenges","text":""},{"location":"plans/MULTI_INSTANCE_STASH/#1-entity-id-collisions","title":"1. Entity ID Collisions","text":"<p>Stash uses auto-increment integer IDs per-instance. Scene ID <code>123</code> from Instance A is completely different from Scene ID <code>123</code> from Instance B.</p> <p>Options: - Composite key: Store <code>instanceId</code> + <code>sceneId</code> as separate columns (cleaner, preferred) - Prefixed ID: Concatenate as <code>{instanceId}_{sceneId}</code> string (simpler but messier)</p> <p>Decision: Use separate <code>instanceId</code> column for cleaner database architecture.</p>"},{"location":"plans/MULTI_INSTANCE_STASH/#2-entity-deduplication","title":"2. Entity Deduplication","text":"<p>The same performer/studio/tag may exist across multiple Stash instances: - Same performer with different local IDs - StashDB integration provides a common identifier (<code>stash_ids</code> field) - Need strategy to merge or deduplicate entities</p> <p>Considerations: - StashDB IDs can serve as deduplication key - If same StashDB ID exists on multiple instances, which one \"wins\"? - May need a \"primary\" instance concept for conflict resolution - Performers without StashDB IDs cannot be deduplicated automatically</p>"},{"location":"plans/MULTI_INSTANCE_STASH/#3-filtering-across-instances","title":"3. Filtering Across Instances","text":"<p>Current filtering assumes single instance: - Tag filters reference tag IDs - Performer filters reference performer IDs - How do we filter when same logical entity has different IDs per instance?</p> <p>Options: - Filter by StashDB ID where available - Filter by name matching (fuzzy, less reliable) - Keep filters instance-scoped (simpler but less unified)</p>"},{"location":"plans/MULTI_INSTANCE_STASH/#4-affected-entity-types","title":"4. Affected Entity Types","text":"<p>All Stash entities need instance tracking: - Scenes - Performers - Studios - Tags - Galleries - Groups - Images</p> <p>Each needs <code>instanceId</code> added to normalized types and cache storage.</p>"},{"location":"plans/MULTI_INSTANCE_STASH/#5-proxy-and-streaming","title":"5. Proxy and Streaming","text":"<p>Must route requests to correct instance: - Image proxy needs to know which instance to fetch from - Video streaming needs to use correct instance's file paths - Already have <code>getBaseUrl(instanceId)</code> and <code>getApiKey(instanceId)</code> methods</p>"},{"location":"plans/MULTI_INSTANCE_STASH/#6-user-data-mapping","title":"6. User Data Mapping","text":"<p>Current user data (ratings, watch history, favorites) uses Stash entity IDs: - <code>WatchHistory.sceneId</code> references a scene - <code>SceneRating.sceneId</code> references a scene - Need composite key or migration strategy</p>"},{"location":"plans/MULTI_INSTANCE_STASH/#implementation-phases","title":"Implementation Phases","text":""},{"location":"plans/MULTI_INSTANCE_STASH/#phase-1-backend-multi-instance-support","title":"Phase 1: Backend Multi-Instance Support","text":"<ol> <li>Remove single-instance enforcement in StashInstanceManager</li> <li>Add <code>instanceId</code> to normalized types (NormalizedScene, NormalizedPerformer, etc.)</li> <li>Update StashCacheManager to fetch from all instances and merge</li> <li>Update cache key strategy to use <code>instanceId:entityId</code> composite</li> <li>Add instance CRUD endpoints:</li> <li><code>GET /api/setup/stash-instances</code> - List all</li> <li><code>POST /api/setup/stash-instance</code> - Create (admin only)</li> <li><code>PUT /api/setup/stash-instance/:id</code> - Update</li> <li><code>DELETE /api/setup/stash-instance/:id</code> - Delete</li> <li>Trigger cache rebuild after any instance change</li> </ol>"},{"location":"plans/MULTI_INSTANCE_STASH/#phase-2-entity-identification-refactor","title":"Phase 2: Entity Identification Refactor","text":"<ol> <li>Update all controllers to handle composite entity references</li> <li>Update proxy controller to route to correct instance</li> <li>Update video controller to stream from correct instance</li> <li>Update user data tables to include instanceId in composite keys</li> <li>Create migration for existing user data</li> </ol>"},{"location":"plans/MULTI_INSTANCE_STASH/#phase-3-deduplication-system","title":"Phase 3: Deduplication System","text":"<ol> <li>Research StashDB ID availability in Stash GraphQL schema</li> <li>Implement deduplication logic:</li> <li>Fetch StashDB IDs for all entities</li> <li>Group entities by StashDB ID</li> <li>Designate primary instance for conflicts</li> <li>Update UI to show deduplicated entities</li> <li>Handle entities without StashDB IDs (keep separate)</li> </ol>"},{"location":"plans/MULTI_INSTANCE_STASH/#phase-4-ui-updates","title":"Phase 4: UI Updates","text":"<ol> <li>Update StashInstanceSection for full CRUD:</li> <li>List all instances with status indicators</li> <li>Add Instance button with connection test</li> <li>Edit instance (name, URL, API key)</li> <li>Delete instance with confirmation</li> <li>Enable/disable toggle per instance</li> <li>Update filters to work across instances</li> <li>Show instance badge on entities (optional, for debugging)</li> </ol>"},{"location":"plans/MULTI_INSTANCE_STASH/#database-schema-changes","title":"Database Schema Changes","text":"<pre><code>// Already exists\nmodel StashInstance {\n  id        String   @id @default(uuid())\n  name      String\n  url       String\n  apiKey    String\n  enabled   Boolean  @default(true)\n  priority  Int      @default(0)\n  createdAt DateTime @default(now())\n  updatedAt DateTime @updatedAt\n}\n\n// Needs update - add instanceId to composite unique\nmodel WatchHistory {\n  id          Int      @id @default(autoincrement())\n  userId      Int\n  instanceId  String   // NEW\n  sceneId     String\n  // ... other fields\n\n  @@unique([userId, instanceId, sceneId])\n}\n\nmodel SceneRating {\n  id          Int      @id @default(autoincrement())\n  userId      Int\n  instanceId  String   // NEW\n  sceneId     String\n  // ... other fields\n\n  @@unique([userId, instanceId, sceneId])\n}\n\n// Similar changes for PerformerRating, StudioRating, etc.\n</code></pre>"},{"location":"plans/MULTI_INSTANCE_STASH/#normalized-type-changes","title":"Normalized Type Changes","text":"<pre><code>interface NormalizedScene {\n  id: string;\n  instanceId: string;  // NEW - which Stash instance this came from\n  // ... existing fields\n}\n\ninterface NormalizedPerformer {\n  id: string;\n  instanceId: string;  // NEW\n  stashDbId?: string;  // NEW - for deduplication\n  // ... existing fields\n}\n</code></pre>"},{"location":"plans/MULTI_INSTANCE_STASH/#api-response-changes","title":"API Response Changes","text":"<p>Entities returned from API will include <code>instanceId</code>:</p> <pre><code>{\n  \"id\": \"12345\",\n  \"instanceId\": \"8dcbd5b1-73c1-4d1c-b3ce-0924c336e59f\",\n  \"title\": \"Scene Title\",\n  ...\n}\n</code></pre>"},{"location":"plans/MULTI_INSTANCE_STASH/#open-questions","title":"Open Questions","text":"<ol> <li>Should deduplication be automatic or user-controlled?</li> <li>Automatic based on StashDB ID?</li> <li> <p>Let users manually merge entities?</p> </li> <li> <p>How to handle conflicting metadata?</p> </li> <li>Same performer, different bios on different instances</li> <li> <p>Which instance's data takes precedence?</p> </li> <li> <p>Performance impact of multi-instance cache?</p> </li> <li>Cache size doubles/triples with multiple instances</li> <li> <p>Refresh time increases proportionally</p> </li> <li> <p>Should users be able to filter by instance?</p> </li> <li>\"Show only scenes from Instance A\"</li> <li>Useful for debugging, maybe not for regular use</li> </ol>"},{"location":"plans/MULTI_INSTANCE_STASH/#alternatives-considered","title":"Alternatives Considered","text":""},{"location":"plans/MULTI_INSTANCE_STASH/#alternative-1-single-stash-instance-only","title":"Alternative 1: Single Stash Instance Only","text":"<p>Keep the current single-instance design. Users with multiple Stash servers would need to consolidate into one Stash instance.</p> <p>Pros: Simpler, no ID collision issues Cons: Limits use cases, some users have legitimate multi-instance setups</p>"},{"location":"plans/MULTI_INSTANCE_STASH/#alternative-2-instance-scoped-everything","title":"Alternative 2: Instance-Scoped Everything","text":"<p>Keep instances completely separate - user switches between instances like switching accounts.</p> <p>Pros: No collision issues, simpler implementation Cons: No unified library view, poor UX for users who want to see everything together</p>"},{"location":"plans/MULTI_INSTANCE_STASH/#alternative-3-external-aggregation","title":"Alternative 3: External Aggregation","text":"<p>Recommend users use Stash's built-in library merging features instead.</p> <p>Pros: No Peek changes needed Cons: May not exist, shifts burden to user</p>"},{"location":"plans/MULTI_INSTANCE_STASH/#estimated-effort","title":"Estimated Effort","text":"<ul> <li>Phase 1: 1-2 days</li> <li>Phase 2: 2-3 days</li> <li>Phase 3: 2-3 days</li> <li>Phase 4: 1-2 days</li> </ul> <p>Total: ~1 week of focused development</p>"},{"location":"plans/MULTI_INSTANCE_STASH/#dependencies","title":"Dependencies","text":"<ul> <li>Understanding of StashDB ID structure in Stash GraphQL</li> <li>Testing with multiple actual Stash instances</li> <li>User feedback on deduplication preferences</li> </ul>"},{"location":"plans/MULTI_INSTANCE_STASH/#references","title":"References","text":"<ul> <li>Stash GraphQL Schema</li> <li>StashDB Integration Docs</li> <li>Commit 1: <code>291b428</code> - Single instance database storage</li> </ul>"},{"location":"reference/faq/","title":"Frequently Asked Questions","text":"<p>Common questions about Peek Stash Browser.</p>"},{"location":"reference/faq/#general","title":"General","text":""},{"location":"reference/faq/#what-is-peek","title":"What is Peek?","text":"<p>Peek is a modern web application for browsing and streaming Stash media content with real-time HLS transcoding. It provides a fast, responsive interface with adaptive quality streaming.</p>"},{"location":"reference/faq/#how-is-peek-different-from-stash","title":"How is Peek different from Stash?","text":"<p>Peek is a browser/player focused on video playback, while Stash is a comprehensive media organizer. Peek:</p> <ul> <li>Focuses on smooth video playback with adaptive streaming</li> <li>Provides a simplified, browsing-focused interface</li> <li>Uses real-time transcoding for universal compatibility</li> <li>Complements Stash rather than replacing it</li> </ul>"},{"location":"reference/faq/#does-peek-modify-my-stash-library","title":"Does Peek modify my Stash library?","text":"<p>No. Peek is read-only. It connects to Stash's GraphQL API to read data but never modifies your library, files, or metadata.</p>"},{"location":"reference/faq/#installation","title":"Installation","text":""},{"location":"reference/faq/#what-platforms-are-supported","title":"What platforms are supported?","text":"<ul> <li>unRAID: Community Applications or manual Docker install</li> <li>Docker: Any platform supporting Docker</li> <li>Development: Node.js 18+ on Windows/Mac/Linux</li> </ul>"},{"location":"reference/faq/#do-i-need-a-separate-database-server","title":"Do I need a separate database server?","text":"<p>No. Peek uses embedded SQLite. No PostgreSQL, MySQL, or other database server needed.</p>"},{"location":"reference/faq/#can-i-run-peek-and-stash-on-the-same-server","title":"Can I run Peek and Stash on the same server?","text":"<p>Yes. They run as separate containers and don't conflict.</p>"},{"location":"reference/faq/#video-playback","title":"Video Playback","text":""},{"location":"reference/faq/#why-does-transcoding-take-so-long","title":"Why does transcoding take so long?","text":"<p>Transcoding is CPU-intensive. Performance depends on:</p> <ul> <li>Server CPU power</li> <li>Storage I/O speed (SSD vs HDD vs network)</li> <li>Original video codec and resolution</li> <li>Target quality selected</li> </ul> <p>For best performance, use local SSD storage and allocate 2-4 CPU cores.</p>"},{"location":"reference/faq/#can-i-play-videos-directly-without-transcoding","title":"Can I play videos directly without transcoding?","text":"<p>Yes! Direct play is available when your browser supports the video codec. Use the quality selector and choose Direct to play the original file without transcoding.</p> <p>When to use Direct: - Fastest playback (no transcoding delay) - Highest quality (original file) - Browser supports the video format</p> <p>When to use transcoding: - Browser doesn't support the format - Want adaptive quality (switch between 720p/480p/360p) - Slower network connections</p>"},{"location":"reference/faq/#can-i-download-the-original-video-file","title":"Can I download the original video file?","text":"<p>Not yet. Video downloads are planned for a future release. Currently, you can only stream videos through Peek's player.</p>"},{"location":"reference/faq/#configuration","title":"Configuration","text":""},{"location":"reference/faq/#where-are-my-settings-stored","title":"Where are my settings stored?","text":"<ul> <li>User preferences: SQLite database in <code>/app/data/peek-db.db</code></li> <li>Server config: Environment variables</li> <li>Temp files: <code>/app/data/hls-cache/</code> (auto-cleaned)</li> </ul>"},{"location":"reference/faq/#how-do-i-backup-my-data","title":"How do I backup my data?","text":"<pre><code># Backup SQLite database\ndocker exec peek-stash-browser sqlite3 /app/data/peek-db.db \".backup /app/data/backup.db\"\n\n# Copy backup out of container\ndocker cp peek-stash-browser:/app/data/backup.db ./peek-backup.db\n</code></pre>"},{"location":"reference/faq/#can-i-customize-the-theme","title":"Can I customize the theme?","text":"<p>Yes! Peek includes several built-in themes and a custom theme editor.</p> <p>Built-in Themes: - Light Mode - Dark Mode (default) - Deep Purple - The Hub</p> <p>Custom Theme Editor: 1. Go to Settings \u2192 My Settings 2. Scroll to Custom Themes section 3. Create your own theme by choosing colors 4. Customize fonts, backgrounds, text colors, and more 5. Save and apply your custom theme</p> <p>Toggle between themes using the theme icon in the navigation bar.</p>"},{"location":"reference/faq/#performance","title":"Performance","text":""},{"location":"reference/faq/#how-many-concurrent-streams-can-peek-handle","title":"How many concurrent streams can Peek handle?","text":"<p>Depends on server CPU:</p> <ul> <li>2 CPU cores: 1-2 streams at 720p</li> <li>4 CPU cores: 3-4 streams at 720p</li> <li>6+ CPU cores: 5+ streams at 720p</li> </ul> <p>Lower qualities (480p, 360p) require less CPU and support more concurrent streams.</p>"},{"location":"reference/faq/#why-is-my-media-loading-slowly","title":"Why is my media loading slowly?","text":"<p>Check storage speed:</p> <pre><code>docker exec peek-stash-browser dd if=/app/media/test.mp4 of=/dev/null bs=1M count=100\n</code></pre> <p>If &lt; 50 MB/s, media is likely on: - Network share (SMB/NFS) - Move to local storage - Slow HDD - Upgrade to SSD - USB drive - Use internal storage</p>"},{"location":"reference/faq/#how-much-disk-space-does-peek-need","title":"How much disk space does Peek need?","text":"<ul> <li>App data: ~100 MB (database, config)</li> <li>Temp files: ~50-100 MB per quality per minute of video</li> <li>Recommendation: 5-10 GB for temp storage on busy servers</li> </ul> <p>Temp files are automatically cleaned up after 30 minutes.</p>"},{"location":"reference/faq/#troubleshooting","title":"Troubleshooting","text":""},{"location":"reference/faq/#videos-wont-play","title":"Videos won't play","text":"<ol> <li>Check FFmpeg is installed: <code>docker exec peek-stash-browser ffmpeg -version</code></li> <li>Verify path mapping is correct</li> <li>Check file permissions on media</li> <li>Review backend logs for errors</li> </ol> <p>See: Troubleshooting Guide</p>"},{"location":"reference/faq/#cant-connect-to-stash","title":"Can't connect to Stash","text":"<ol> <li>Verify <code>STASH_URL</code> is correct and accessible from container</li> <li>Check Stash API key is valid</li> <li>Test connectivity: <code>docker exec peek-stash-browser curl http://stash:9999/graphql</code></li> </ol>"},{"location":"reference/faq/#login-doesnt-work","title":"Login doesn't work","text":"<ul> <li>Check cookies are enabled</li> <li>Verify <code>JWT_SECRET</code> is set</li> <li>Try incognito mode</li> <li>Clear browser cache</li> </ul>"},{"location":"reference/faq/#features","title":"Features","text":""},{"location":"reference/faq/#how-do-playlists-work","title":"How do playlists work?","text":"<p>Playlists are fully available! Create custom playlists of your favorite scenes.</p> <p>Creating a Playlist: 1. Click Playlists in the navigation 2. Click Create Playlist 3. Enter a name and description 4. Click Create</p> <p>Adding Scenes: - Click the + icon on any scene card - Select the playlist to add it to - Or go to a scene's detail page and click Add to Playlist</p> <p>Playing Playlists: - Click a playlist to view its scenes - Click Play to start from the beginning - Use Shuffle to randomize playback order - Use Repeat (all or one) for continuous playback - Reorder scenes by dragging them in edit mode</p> <p>Learn More</p> <p>See the Complete Playlists Guide for detailed instructions on managing and playing playlists.</p>"},{"location":"reference/faq/#does-peek-track-watch-history","title":"Does Peek track watch history?","text":"<p>Yes! Peek automatically tracks your viewing progress and lets you resume playback from where you left off.</p> <p>Features: - Automatic progress tracking during playback - Resume from any device (synced to your user account) - \"Continue Watching\" section on home page - Progress bars on scene cards - Clear history for individual scenes or all at once</p> <p>Learn More</p> <p>See the Watch History Guide for complete details on managing your watch history.</p>"},{"location":"reference/faq/#can-i-use-keyboard-navigation","title":"Can I use keyboard navigation?","text":"<p>Yes! Peek supports complete keyboard navigation, perfect for TV remotes or wireless keyboards.</p> <p>Key features: - Arrow keys navigate scene grids and lists - Enter to select/play - Video player keyboard shortcuts (Space, arrows, F for fullscreen) - Playlist controls (N for next, P for previous) - TV Mode optimized for couch browsing</p> <p>Learn More</p> <p>See the Keyboard Navigation Guide for all keyboard shortcuts and TV mode setup.</p>"},{"location":"reference/faq/#can-i-use-peek-on-mobile","title":"Can I use Peek on mobile?","text":"<p>Yes. The web interface is responsive and works on mobile browsers. A dedicated mobile app is not currently planned.</p>"},{"location":"reference/faq/#does-peek-support-hardware-transcoding","title":"Does Peek support hardware transcoding?","text":"<p>Not yet. Hardware-accelerated transcoding (GPU) is planned for a future release to improve performance and reduce CPU usage.</p>"},{"location":"reference/faq/#can-i-use-peek-without-stash","title":"Can I use Peek without Stash?","text":"<p>No. Peek requires a Stash server for media library management and metadata. Peek is designed as a companion to Stash, not a replacement.</p>"},{"location":"reference/faq/#security","title":"Security","text":""},{"location":"reference/faq/#is-peek-secure","title":"Is Peek secure?","text":"<p>Peek includes: - JWT authentication - Bcrypt password hashing - Read-only media access - Session management</p> <p>Important: Change the default admin password immediately!</p>"},{"location":"reference/faq/#should-i-expose-peek-to-the-internet","title":"Should I expose Peek to the internet?","text":"<p>No. Peek is designed for local network use. For remote access: - Use VPN - Use reverse proxy with authentication layer - Don't expose directly to internet</p>"},{"location":"reference/faq/#support","title":"Support","text":""},{"location":"reference/faq/#where-can-i-get-help","title":"Where can I get help?","text":"<ul> <li>Documentation: https://carrotwaxr.github.io/peek-stash-browser</li> <li>GitHub Issues: Bug reports and feature requests</li> <li>Stash Discord: #third-party-integrations channel</li> </ul>"},{"location":"reference/faq/#how-do-i-report-a-bug","title":"How do I report a bug?","text":"<ol> <li>Search existing issues first</li> <li>Gather logs and error messages</li> <li>Create detailed issue on GitHub</li> <li>Include: version, platform, steps to reproduce</li> </ol> <p>See: GitHub Issues</p>"},{"location":"reference/faq/#can-i-contribute","title":"Can I contribute?","text":"<p>Yes! Contributions are welcome: - Code improvements - Bug fixes - Documentation - Translations (future)</p> <p>See: GitHub Issues</p>"},{"location":"reference/faq/#next-steps","title":"Next Steps","text":"<ul> <li>Installation - Install Peek</li> <li>Watch History - Resume playback from where you left off</li> <li>Keyboard Navigation - Complete keyboard shortcuts and TV mode</li> <li>Playlists - Create and manage custom playlists</li> <li>Troubleshooting - Fix common issues</li> </ul>"},{"location":"reference/troubleshooting/","title":"Troubleshooting","text":"<p>Common issues and solutions for Peek Stash Browser.</p>"},{"location":"reference/troubleshooting/#installation-setup","title":"Installation &amp; Setup","text":""},{"location":"reference/troubleshooting/#container-wont-start","title":"Container Won't Start","text":"<p>Check logs first:</p> <pre><code>docker logs peek-stash-browser\n</code></pre> <p>Common causes:</p> <ul> <li>Missing required environment variables (<code>STASH_URL</code>, <code>STASH_API_KEY</code>)</li> <li>Invalid <code>STASH_URL</code> (not accessible from container)</li> <li>Port conflicts (6969 already in use)</li> <li>Missing volume mappings</li> </ul> <p>Solution:</p> <pre><code># Stop container\ndocker stop peek-stash-browser\n\n# Remove container\ndocker rm peek-stash-browser\n\n# Recreate with correct configuration\n# (use your template or docker-compose)\n</code></pre>"},{"location":"reference/troubleshooting/#cant-connect-to-stash","title":"Can't Connect to Stash","text":"<p>Test connectivity from container:</p> <pre><code>docker exec peek-stash-browser curl -X POST http://your-stash-ip:9999/graphql \\\n  -H \"Content-Type: application/json\" \\\n  -H \"ApiKey: your-api-key-12345\" \\\n  -d '{\n    \"query\": \"query FindTags { findTags(filter: { per_page: 1 }) { count tags { id name } } }\"\n  }'\n</code></pre> <p>Solutions:</p> <ul> <li>Verify <code>STASH_URL</code> is correct and accessible</li> <li>Check Stash API key is valid (Settings \u2192 Security \u2192 API Key)</li> <li>Ensure Stash GraphQL endpoint is enabled</li> <li>Check firewall rules between containers</li> </ul>"},{"location":"reference/troubleshooting/#video-playback","title":"Video Playback","text":""},{"location":"reference/troubleshooting/#videos-wont-play","title":"Videos Won't Play","text":"<ol> <li>Check FFmpeg: <code>docker exec peek-stash-browser ffmpeg -version</code></li> <li>Check file permissions: <code>docker exec peek-stash-browser ls -la /app/media</code></li> <li>Verify path mapping: Go to Settings \u2192 Path Mappings and use \"Test Path\" button</li> <li>Check media is mounted: <code>docker exec peek-stash-browser ls /app/media</code></li> <li>Check backend logs: <code>docker logs peek-stash-browser</code></li> </ol>"},{"location":"reference/troubleshooting/#slow-transcoding","title":"Slow Transcoding","text":"<p>Check I/O performance:</p> <pre><code>docker exec peek-stash-browser dd if=/app/media/test.mp4 of=/dev/null bs=1M count=100\n</code></pre> <p>Expected: 50+ MB/s for good performance</p> <p>Solutions:</p> <ul> <li>Move media to local storage (not network share)</li> <li>Use SSD for media and temp files</li> <li>Reduce quality preset</li> <li>Allocate more CPU to container</li> </ul>"},{"location":"reference/troubleshooting/#authentication","title":"Authentication","text":""},{"location":"reference/troubleshooting/#cant-login","title":"Can't Login","text":"<ul> <li>Verify username/password</li> <li>Check if cookies are enabled in browser</li> <li>Clear browser cache and cookies</li> <li>Try incognito/private browsing mode</li> </ul>"},{"location":"reference/troubleshooting/#session-expires-immediately","title":"Session Expires Immediately","text":"<ul> <li>Check <code>JWT_SECRET</code> is set</li> <li>Verify <code>SECURE_COOKIES</code> matches your setup (false for HTTP)</li> <li>Clear browser cookies</li> <li>Check system clock is correct</li> </ul>"},{"location":"reference/troubleshooting/#network-performance","title":"Network &amp; Performance","text":""},{"location":"reference/troubleshooting/#slow-page-loading","title":"Slow Page Loading","text":"<ul> <li>Check server CPU/memory usage</li> <li>Clear browser cache</li> <li>Verify network speed</li> <li>Check for console errors (F12 \u2192 Console)</li> </ul>"},{"location":"reference/troubleshooting/#images-not-loading","title":"Images Not Loading","text":"<ul> <li>Check Stash is accessible</li> <li>Verify <code>STASH_URL</code> is correct</li> <li>Check browser console for CORS errors</li> <li>Try clearing cache</li> </ul>"},{"location":"reference/troubleshooting/#database","title":"Database","text":""},{"location":"reference/troubleshooting/#database-locked-error","title":"Database Locked Error","text":"<pre><code># Stop container\ndocker stop peek-stash-browser\n\n# Remove lock file\ndocker run --rm -v peek-data:/app/data busybox rm /app/data/peek-db.db-wal\n\n# Restart container\ndocker start peek-stash-browser\n</code></pre>"},{"location":"reference/troubleshooting/#reset-database","title":"Reset Database","text":"<p>This Deletes All Data</p> <p>This will delete all users, preferences, and playlists.</p> <pre><code>docker stop peek-stash-browser\ndocker run --rm -v peek-data:/app/data busybox rm /app/data/peek-db.db\ndocker start peek-stash-browser\n</code></pre>"},{"location":"reference/troubleshooting/#logs-debugging","title":"Logs &amp; Debugging","text":""},{"location":"reference/troubleshooting/#viewing-logs","title":"Viewing Logs","text":"<pre><code># All logs\ndocker logs peek-stash-browser\n\n# Follow logs (live)\ndocker logs -f peek-stash-browser\n\n# Last 100 lines\ndocker logs --tail 100 peek-stash-browser\n</code></pre>"},{"location":"reference/troubleshooting/#enable-debug-logging","title":"Enable Debug Logging","text":"<p>Add to environment variables:</p> <pre><code>LOG_LEVEL=debug\n</code></pre>"},{"location":"reference/troubleshooting/#browser-console","title":"Browser Console","text":"<p>Check browser console for frontend errors:</p> <ol> <li>Press F12 to open DevTools</li> <li>Click Console tab</li> <li>Look for red errors</li> <li>Copy error messages when reporting issues</li> </ol>"},{"location":"reference/troubleshooting/#common-error-messages","title":"Common Error Messages","text":""},{"location":"reference/troubleshooting/#ffmpeg-not-found","title":"\"FFmpeg not found\"","text":"<p>Solution: FFmpeg should be included in the official image. If you see this error: - Pull the latest image: <code>docker pull carrotwaxr/peek-stash-browser:latest</code> - Rebuild your container with the latest image</p>"},{"location":"reference/troubleshooting/#path-not-found-or-path-related-errors","title":"\"Path not found\" or path-related errors","text":"<p>Solution: Check your path mappings: 1. Go to Settings \u2192 Path Mappings in Peek 2. Click Test Path for each mapping 3. Verify paths are accessible 4. Make sure media volumes are mounted to your container</p>"},{"location":"reference/troubleshooting/#session-not-found","title":"\"Session not found\"","text":"<p>Solution: Session expired (30 min timeout). Refresh page and try again.</p>"},{"location":"reference/troubleshooting/#unauthorized","title":"\"Unauthorized\"","text":"<p>Solution: Token expired. Logout and login again.</p>"},{"location":"reference/troubleshooting/#getting-help","title":"Getting Help","text":""},{"location":"reference/troubleshooting/#before-asking-for-help","title":"Before Asking for Help","text":"<ol> <li>Check this troubleshooting guide</li> <li>Search existing GitHub Issues</li> <li>Check browser console for errors</li> <li>Gather logs and error messages</li> </ol>"},{"location":"reference/troubleshooting/#creating-a-bug-report","title":"Creating a Bug Report","text":"<p>Include:</p> <ul> <li>Peek version: Check Settings \u2192 About</li> <li>Platform: unRAID / Docker / Development</li> <li>Browser: Chrome 120 / Firefox 121 / etc.</li> <li>Stash version: Your Stash server version</li> <li>Error logs: Backend and browser console</li> <li>Steps to reproduce: Detailed steps</li> <li>Screenshots: If applicable</li> </ul>"},{"location":"reference/troubleshooting/#where-to-get-help","title":"Where to Get Help","text":"<ul> <li>GitHub Issues: https://github.com/carrotwaxr/peek-stash-browser/issues</li> <li>Stash Discord: #third-party-integrations channel</li> <li>Documentation: https://carrotwaxr.github.io/peek-stash-browser</li> </ul>"},{"location":"reference/troubleshooting/#next-steps","title":"Next Steps","text":"<ul> <li>FAQ - Frequently asked questions</li> </ul>"},{"location":"user-guide/custom-carousels/","title":"Custom Carousels","text":"<p>Create personalized homepage carousels using a visual query builder. Custom carousels let you define filter rules to automatically curate collections of scenes based on performers, tags, ratings, and more.</p>"},{"location":"user-guide/custom-carousels/#creating-a-custom-carousel","title":"Creating a Custom Carousel","text":"<ol> <li>Navigate to Settings \u2192 Homepage Carousels</li> <li>Click Create Carousel</li> <li>Configure your carousel:</li> <li>Title: Give your carousel a descriptive name</li> <li>Icon: Choose from a selection of icons</li> <li>Filter Rules: Add one or more rules to define which scenes appear</li> <li> <p>Sort: Choose how scenes are ordered (Random, Recently Added, etc.)</p> </li> <li> <p>Click Preview to see matching scenes</p> </li> <li>Click Save once you're satisfied with the preview</li> </ol>"},{"location":"user-guide/custom-carousels/#filter-rules","title":"Filter Rules","text":"<p>Each rule consists of a filter type, comparison operator, and value. All rules must match (AND logic) for a scene to appear in the carousel.</p>"},{"location":"user-guide/custom-carousels/#available-filters","title":"Available Filters","text":"Filter Description Performers Scenes featuring specific performers Tags Scenes with specific tags Studio Scenes from a specific studio Collections Scenes in specific groups/collections Rating Scenes within a rating range (0-100) Duration Scene length in minutes Resolution Video quality (480p, 720p, 1080p, etc.) Play Count Number of times you've watched O Count Your O count for the scene Favorite Scenes Only your favorited scenes Favorite Performers Scenes with your favorite performers Favorite Studios Scenes from your favorite studios Favorite Tags Scenes with your favorite tags Created Date When the scene was added Scene Date The scene's release date Last Played Date When you last watched Performer Age Performer age at time of scene Performer Count Number of performers in scene Bitrate Video bitrate in Mbps Title Contains Text search in scene title Details Contains Text search in scene description"},{"location":"user-guide/custom-carousels/#comparison-operators","title":"Comparison Operators","text":"<p>Different filter types support different operators:</p> <ul> <li>Entity filters (Performers, Tags, etc.): includes any of, includes all of, excludes</li> <li>Numeric filters (Rating, Duration, etc.): between, greater than, less than</li> <li>Boolean filters (Favorites): is true / is false</li> <li>Text filters: contains</li> </ul>"},{"location":"user-guide/custom-carousels/#managing-carousels","title":"Managing Carousels","text":""},{"location":"user-guide/custom-carousels/#reordering","title":"Reordering","text":"<p>Use the up/down arrow buttons next to each carousel to change the display order on your homepage.</p>"},{"location":"user-guide/custom-carousels/#visibility","title":"Visibility","text":"<p>Click the eye icon to show/hide individual carousels. Hidden carousels remain saved but won't appear on the homepage.</p>"},{"location":"user-guide/custom-carousels/#editing","title":"Editing","text":"<p>Click the pencil icon on any custom carousel to modify its rules, title, or icon.</p>"},{"location":"user-guide/custom-carousels/#deleting","title":"Deleting","text":"<p>Click the trash icon to delete a custom carousel. This action cannot be undone.</p>"},{"location":"user-guide/custom-carousels/#limits","title":"Limits","text":"<ul> <li>Maximum of 15 custom carousels per user</li> <li>Each carousel displays up to 12 scenes</li> <li>All filter rules use AND logic (scenes must match all rules)</li> </ul>"},{"location":"user-guide/custom-carousels/#tips","title":"Tips","text":"<ul> <li>Start simple: Begin with one or two rules and add more as needed</li> <li>Use Preview: Always preview before saving to ensure your rules work as expected</li> <li>Random sort: Great for variety - shows different scenes each time you visit</li> <li>Combine with favorites: Create carousels for \"Highly rated scenes with favorite performers\"</li> <li>Content restrictions: Custom carousels respect your hidden items and content restrictions</li> </ul>"},{"location":"user-guide/custom-carousels/#troubleshooting","title":"Troubleshooting","text":""},{"location":"user-guide/custom-carousels/#carousel-shows-no-scenes-found","title":"Carousel shows \"No scenes found\"","text":"<ul> <li>Your filter rules may be too restrictive</li> <li>Try relaxing some rules or using different operators</li> <li>Check that you have scenes matching your criteria</li> </ul>"},{"location":"user-guide/custom-carousels/#carousel-not-appearing-on-homepage","title":"Carousel not appearing on homepage","text":"<ul> <li>Make sure the carousel is enabled (eye icon should be visible, not crossed out)</li> <li>Try refreshing the page</li> <li>Check Settings \u2192 Homepage Carousels to verify it's toggled on</li> </ul>"},{"location":"user-guide/external-player/","title":"External Player","text":"<p>Peek allows you to open scenes in external media players like VLC for enhanced playback features such as hardware acceleration, subtitle support, and advanced playback controls.</p>"},{"location":"user-guide/external-player/#platform-compatibility","title":"Platform Compatibility","text":"Platform Status Notes Android \u2705 Works Opens app chooser for any installed video player iOS \u2705 Works Opens directly in VLC (requires VLC for iOS) Windows (Edge/Chrome) \u2705 Works Requires protocol handler setup (see below) Windows (Firefox) \u26a0\ufe0f Limited May not work due to Firefox's protocol handling macOS \ud83d\udd2c Untested Should work with protocol handler Linux \ud83d\udd2c Untested Should work with protocol handler <p>Help Us Test</p> <p>We need community feedback on platform compatibility. If you test on a platform not marked as \"Works\", please report your results on GitHub so we can update this documentation.</p>"},{"location":"user-guide/external-player/#using-the-external-player-button","title":"Using the External Player Button","text":"<p>On the scene page, you'll find an external player button (external link icon) next to the \"View in Stash\" button. The behavior differs by platform:</p>"},{"location":"user-guide/external-player/#mobile-devices","title":"Mobile Devices","text":"<ul> <li>Android: Tapping the button opens a dialog to choose any installed video player app (VLC, MX Player, etc.)</li> <li>iOS: Tapping the button opens the scene directly in VLC (requires VLC for iOS to be installed)</li> </ul>"},{"location":"user-guide/external-player/#desktop-windowsmaclinux","title":"Desktop (Windows/Mac/Linux)","text":"<p>The button becomes a combo button with two parts:</p> <ol> <li>Main button (external link icon): Opens the scene in VLC</li> <li>Dropdown arrow: Click to reveal additional options:</li> <li>Copy Stream URL: Copies the direct stream URL to your clipboard</li> </ol>"},{"location":"user-guide/external-player/#setting-up-vlc-protocol-handler-desktop","title":"Setting Up VLC Protocol Handler (Desktop)","text":"<p>For the \"Open in VLC\" button to work on desktop, you need to install a protocol handler that registers the <code>vlc://</code> URL scheme with your operating system.</p> <p>Why is this needed? VLC doesn't natively understand <code>vlc://</code> URLs. The protocol handler intercepts these URLs, strips the <code>vlc://</code> prefix, and passes the actual video URL to VLC.</p>"},{"location":"user-guide/external-player/#windows-setup-recommended-method","title":"Windows Setup (Recommended Method)","text":"<p>The most reliable method for Windows is using a registry file with a PowerShell script. This approach handles URL encoding issues that browsers introduce.</p>"},{"location":"user-guide/external-player/#step-1-create-the-registry-file","title":"Step 1: Create the Registry File","text":"<ol> <li>Open Notepad</li> <li>Paste the following content:</li> </ol> <pre><code>Windows Registry Editor Version 5.00\n\n[HKEY_CLASSES_ROOT\\vlc]\n@=\"URL:VLC Protocol\"\n\"URL Protocol\"=\"\"\n\n[HKEY_CLASSES_ROOT\\vlc\\DefaultIcon]\n@=\"C:\\\\Program Files\\\\VideoLAN\\\\VLC\\\\vlc.exe,0\"\n\n[HKEY_CLASSES_ROOT\\vlc\\shell]\n\n[HKEY_CLASSES_ROOT\\vlc\\shell\\open]\n\n[HKEY_CLASSES_ROOT\\vlc\\shell\\open\\command]\n@=\"C:\\\\Windows\\\\System32\\\\WindowsPowerShell\\\\v1.0\\\\powershell.exe -WindowStyle Hidden -Command \\\"&amp; {$url='%1' -replace '^vlc://' -replace '^http//', 'http://' -replace '^https//', 'https://'; Start-Process -FilePath 'C:\\\\Program Files\\\\VideoLAN\\\\VLC\\\\vlc.exe' -ArgumentList $url}\\\"\"\n</code></pre> <ol> <li>Save as <code>vlc-protocol.reg</code> (make sure to select \"All Files\" as the file type)</li> </ol> <p>Adjust VLC Path if Needed</p> <p>If VLC is installed in a different location (e.g., <code>C:\\Program Files (x86)\\VideoLAN\\VLC\\vlc.exe</code>), update both paths in the registry file accordingly.</p>"},{"location":"user-guide/external-player/#step-2-install-the-registry-entries","title":"Step 2: Install the Registry Entries","text":"<ol> <li>Double-click the <code>vlc-protocol.reg</code> file</li> <li>Click \"Yes\" when prompted by User Account Control</li> <li>Click \"Yes\" when asked to confirm adding to the registry</li> <li>You should see \"The keys and values contained in [path] have been successfully added to the registry\"</li> </ol>"},{"location":"user-guide/external-player/#step-3-test-it","title":"Step 3: Test It","text":"<ol> <li>Open Peek in Edge or Chrome</li> <li>Navigate to a scene</li> <li>Click the external player button</li> <li>When prompted, allow the browser to open the VLC handler</li> <li>VLC should open and start playing the video</li> </ol>"},{"location":"user-guide/external-player/#how-the-powershell-script-works","title":"How the PowerShell Script Works","text":"<p>The PowerShell command in the registry performs these transformations:</p> <ol> <li>Removes the <code>vlc://</code> prefix from the URL</li> <li>Fixes <code>http//</code> \u2192 <code>http://</code> (browsers strip the colon for security)</li> <li>Fixes <code>https//</code> \u2192 <code>https://</code></li> <li>Launches VLC with the corrected URL</li> </ol>"},{"location":"user-guide/external-player/#alternative-third-party-protocol-handlers","title":"Alternative: Third-Party Protocol Handlers","text":"<p>These tools may also work, though results vary:</p> <ul> <li>player-protocol - Supports VLC and PotPlayer</li> <li>vlc-protocol - VLC-specific handler</li> </ul>"},{"location":"user-guide/external-player/#macos-setup","title":"macOS Setup","text":"<p>macOS users can try:</p> <ol> <li>Install a protocol handler like player-protocol</li> <li>Or use the \"Copy Stream URL\" fallback method</li> </ol> <p>macOS Testers Needed</p> <p>If you've successfully set up VLC protocol handling on macOS, please share your method on GitHub.</p>"},{"location":"user-guide/external-player/#linux-setup","title":"Linux Setup","text":"<p>Linux users can register protocol handlers via <code>xdg-mime</code> or desktop files. A typical approach:</p> <ol> <li>Create a <code>.desktop</code> file for handling <code>x-scheme-handler/vlc</code></li> <li>Register it with <code>xdg-mime default vlc-handler.desktop x-scheme-handler/vlc</code></li> </ol> <p>Linux Testers Needed</p> <p>If you've successfully set up VLC protocol handling on Linux, please share your method on GitHub.</p>"},{"location":"user-guide/external-player/#copying-the-stream-url-fallback-method","title":"Copying the Stream URL (Fallback Method)","text":"<p>If you don't want to set up a protocol handler, or it's not working on your platform, you can use the \"Copy Stream URL\" option:</p> <ol> <li>Click the dropdown arrow on the external player button</li> <li>Select \"Copy Stream URL\"</li> <li>Open VLC manually</li> <li>Go to Media \u2192 Open Network Stream (Ctrl+N on Windows/Linux, Cmd+N on macOS)</li> <li>Paste the URL and click Play</li> </ol> <p>This method works on all platforms without any additional setup.</p>"},{"location":"user-guide/external-player/#troubleshooting","title":"Troubleshooting","text":""},{"location":"user-guide/external-player/#open-in-vlc-doesnt-work-windows","title":"\"Open in VLC\" doesn't work (Windows)","text":"<ol> <li>Check browser: Try Edge or Chrome instead of Firefox</li> <li>Verify registry: Open <code>regedit</code> and check that <code>HKEY_CLASSES_ROOT\\vlc</code> exists</li> <li>Check VLC path: Ensure the path in the registry matches your VLC installation</li> <li>Use fallback: Copy the stream URL and open it manually in VLC</li> </ol>"},{"location":"user-guide/external-player/#firefox-doesnt-open-vlc-windows","title":"Firefox doesn't open VLC (Windows)","text":"<p>Firefox handles custom protocols differently from Edge/Chrome and may not respect Windows registry protocol handlers. Known workarounds:</p> <ul> <li>Use Edge or Chrome for the \"Open in VLC\" feature</li> <li>Use the \"Copy Stream URL\" fallback method</li> <li>Set <code>network.protocol-handler.expose.vlc</code> to <code>false</code> in <code>about:config</code> (results may vary)</li> </ul> <p>Known Issue</p> <p>Firefox on Windows currently doesn't reliably support the <code>vlc://</code> protocol even with the registry handler installed. We're tracking this issue and welcome any solutions from the community.</p>"},{"location":"user-guide/external-player/#video-wont-play-in-vlc","title":"Video won't play in VLC","text":"<ul> <li>Ensure VLC is up to date (version 3.0 or later recommended)</li> <li>The stream URL goes through Peek's proxy, which should handle authentication automatically</li> <li>Try the \"Copy Stream URL\" method to verify the URL works</li> </ul>"},{"location":"user-guide/external-player/#android-no-app-found-to-handle-the-link","title":"Android: No app found to handle the link","text":"<ul> <li>Install a video player app (VLC, MX Player, etc.)</li> <li>The Android intent system should show a list of compatible apps</li> </ul>"},{"location":"user-guide/external-player/#ios-link-doesnt-open-vlc","title":"iOS: Link doesn't open VLC","text":"<ul> <li>Ensure VLC for iOS is installed from the App Store</li> <li>The <code>vlc-x-callback://</code> scheme is only supported by VLC</li> <li>Other iOS video players are not currently supported</li> </ul>"},{"location":"user-guide/external-player/#technical-details","title":"Technical Details","text":""},{"location":"user-guide/external-player/#url-formats-by-platform","title":"URL Formats by Platform","text":"Platform URL Format Example Android Intent URI <code>intent://host#Intent;action=android.intent.action.VIEW;scheme=https;type=video/mp4;...</code> iOS VLC x-callback <code>vlc-x-callback://x-callback-url/stream?url=...</code> Desktop VLC protocol <code>vlc://https://peek.example.com/api/scene/123/proxy-stream/stream</code>"},{"location":"user-guide/external-player/#stream-url","title":"Stream URL","text":"<p>The stream URL points to Peek's proxy endpoint, not directly to Stash. This ensures:</p> <ul> <li>API keys are not exposed in URLs</li> <li>Authentication is handled by Peek</li> <li>The URL format is: <code>{peek-url}/api/scene/{sceneId}/proxy-stream/stream</code></li> </ul>"},{"location":"user-guide/external-player/#contributing","title":"Contributing","text":"<p>If you've found a solution for a platform or browser that's not working, please:</p> <ol> <li>Open an issue with your platform details</li> <li>Describe the steps you took to get it working</li> <li>We'll update this documentation to help other users</li> </ol>"},{"location":"user-guide/hidden-items/","title":"Hidden Items","text":""},{"location":"user-guide/hidden-items/#overview","title":"Overview","text":"<p>The Hidden Items feature allows you to hide specific content from your personal view without affecting other users. Unlike Content Restrictions (which are admin-controlled), Hidden Items are entirely user-controlled and work for all users including admins.</p> <p>Key Difference from Content Restrictions: - Content Restrictions: Set by admins, restrict what a user CAN see (e.g., exclude certain tags/studios) - Hidden Items: Set by users themselves, hide individual items they don't want to see</p>"},{"location":"user-guide/hidden-items/#how-to-hide-items","title":"How to Hide Items","text":""},{"location":"user-guide/hidden-items/#from-scene-cards","title":"From Scene Cards","text":"<ol> <li>Click the three-dot menu (\u22ee) on any scene card</li> <li>Select \"Hide Scene\"</li> <li>Confirm in the dialog (or check \"Don't ask again\" to skip future confirmations)</li> </ol>"},{"location":"user-guide/hidden-items/#from-entity-cards","title":"From Entity Cards","text":"<p>The same three-dot menu is available on: - Performer cards - Studio cards - Tag cards - Group/Collection cards - Gallery cards</p>"},{"location":"user-guide/hidden-items/#bulk-actions-scenes","title":"Bulk Actions (Scenes)","text":"<ol> <li>Enable multi-select mode by clicking the checkbox icon</li> <li>Select multiple scenes</li> <li>Click \"Hide Selected\" in the bulk action bar</li> </ol>"},{"location":"user-guide/hidden-items/#managing-hidden-items","title":"Managing Hidden Items","text":""},{"location":"user-guide/hidden-items/#viewing-hidden-items","title":"Viewing Hidden Items","text":"<ol> <li>Go to My Settings</li> <li>Scroll to the \"Hidden Items\" section</li> <li>Click View Hidden Items</li> </ol>"},{"location":"user-guide/hidden-items/#restoring-hidden-items","title":"Restoring Hidden Items","text":"<p>From the Hidden Items page: - Click Restore on individual items to unhide them - Click Restore All to restore all hidden items at once - Use the tabs to filter by entity type (Scenes, Performers, Studios, etc.)</p>"},{"location":"user-guide/hidden-items/#dont-ask-again","title":"Don't Ask Again","text":"<p>If you frequently hide items and want to skip the confirmation dialog: 1. Check \"Don't ask me again\" when hiding an item, OR 2. Go to My Settings &gt; Hidden Items section 3. Check \"Don't ask for confirmation when hiding items\"</p> <p>You can toggle this setting on/off at any time.</p>"},{"location":"user-guide/hidden-items/#how-it-works","title":"How It Works","text":""},{"location":"user-guide/hidden-items/#for-regular-users","title":"For Regular Users","text":"<ul> <li>Hidden items are filtered from all views (search, carousels, recommendations)</li> <li>Hidden items persist across sessions and page refreshes</li> <li>Other users are not affected by your hidden items</li> </ul>"},{"location":"user-guide/hidden-items/#for-admin-users","title":"For Admin Users","text":"<ul> <li>Admins can hide content for themselves just like regular users</li> <li>Content Restrictions (INCLUDE/EXCLUDE rules) are bypassed for admins</li> <li>Hidden Items filtering is ALWAYS applied, even for admins</li> <li>This allows admins to maintain full admin access while personalizing their own view</li> </ul>"},{"location":"user-guide/hidden-items/#cascading-behavior","title":"Cascading Behavior","text":"<p>When you hide an entity: - Hiding a Scene: Only that scene is hidden - Hiding a Performer: That performer and scenes where they appear may be affected - Hiding a Studio: That studio and scenes from it may be affected - Hiding a Tag: That tag and related content may be affected</p> <p>Note: The exact cascading behavior depends on your Content Restrictions settings and whether hidden entities are the only content associated with related items.</p>"},{"location":"user-guide/hidden-items/#faq","title":"FAQ","text":""},{"location":"user-guide/hidden-items/#can-i-accidentally-hide-something-important","title":"Can I accidentally hide something important?","text":"<p>You can always restore hidden items from My Settings &gt; View Hidden Items. The Restore All button makes it easy to undo bulk actions.</p>"},{"location":"user-guide/hidden-items/#do-hidden-items-count-toward-my-stats","title":"Do hidden items count toward my stats?","text":"<p>Hidden items are excluded from most views but may still appear in certain statistics or reports.</p>"},{"location":"user-guide/hidden-items/#can-admins-see-what-ive-hidden","title":"Can admins see what I've hidden?","text":"<p>Admins can see that you have hidden items (via database access) but the hidden items feature is designed for personal use. Each user's hidden items are private to them.</p>"},{"location":"user-guide/hidden-items/#what-happens-if-content-ive-hidden-is-updated-in-stash","title":"What happens if content I've hidden is updated in Stash?","text":"<p>Hidden items remain hidden even if the underlying content is modified in Stash. The hiding is based on entity ID, not content characteristics.</p> <p>Document Version: 1.0 Last Updated: 2025-01-21</p>"},{"location":"user-guide/keyboard-navigation/","title":"Keyboard Navigation &amp; TV Mode","text":"<p>Peek provides complete keyboard navigation, making it perfect for TV remotes, wireless keyboards, or couch browsing.</p>"},{"location":"user-guide/keyboard-navigation/#why-keyboard-navigation","title":"Why Keyboard Navigation?","text":"<ul> <li>TV Mode - Use Peek on your TV with just a remote</li> <li>Accessibility - Full keyboard support for users who prefer or require it</li> <li>Efficiency - Navigate faster without reaching for the mouse</li> <li>Couch Browsing - Control everything from your couch with a wireless keyboard</li> </ul>"},{"location":"user-guide/keyboard-navigation/#global-navigation","title":"Global Navigation","text":""},{"location":"user-guide/keyboard-navigation/#primary-navigation-keys","title":"Primary Navigation Keys","text":"Key Action <code>Tab</code> Move to next focusable element <code>Shift+Tab</code> Move to previous focusable element <code>Enter</code> Activate/click the focused element <code>Space</code> Activate buttons (also play/pause in video player) <code>Escape</code> Go back or close modals"},{"location":"user-guide/keyboard-navigation/#arrow-key-navigation","title":"Arrow Key Navigation","text":"<p>Arrow keys navigate through grid layouts and lists:</p> Key Action <code>\u2191</code> Move focus up (in grids and lists) <code>\u2193</code> Move focus down (in grids and lists) <code>\u2190</code> Move focus left (in grids) <code>\u2192</code> Move focus right (in grids) <p>Grid Navigation: - Scene grids automatically respond to arrow keys - Focus moves intelligently between rows and columns - Works on Scenes, Performers, Studios, Tags pages</p> <p>List Navigation: - Arrow up/down navigates vertical lists - Works in playlists, search results, settings</p>"},{"location":"user-guide/keyboard-navigation/#scene-browsing","title":"Scene Browsing","text":""},{"location":"user-guide/keyboard-navigation/#scene-grid-navigation","title":"Scene Grid Navigation","text":"<p>Navigating scene cards:</p> <ol> <li>Use <code>Tab</code> or arrow keys to focus a scene card</li> <li>Press <code>Enter</code> to open the scene detail page</li> <li>Press <code>Escape</code> to go back to the grid</li> </ol> <p>Quick actions on scene cards:</p> Key Action <code>Enter</code> Open scene detail page <code>P</code> Play scene immediately (when focused) <code>+</code> Add to playlist (opens playlist selector) <code>F</code> Toggle favorite (when supported)"},{"location":"user-guide/keyboard-navigation/#scene-detail-page","title":"Scene Detail Page","text":"<p>While viewing scene details:</p> Key Action <code>Space</code> or <code>Enter</code> Play video <code>Escape</code> Return to previous page <code>Tab</code> Navigate between action buttons"},{"location":"user-guide/keyboard-navigation/#video-player-controls","title":"Video Player Controls","text":""},{"location":"user-guide/keyboard-navigation/#playback-controls","title":"Playback Controls","text":"Key Action <code>Space</code> or <code>K</code> Play/Pause <code>\u2190</code> Seek backward 10 seconds <code>\u2192</code> Seek forward 10 seconds <code>Shift+\u2190</code> Seek backward 5 seconds <code>Shift+\u2192</code> Seek forward 5 seconds <code>Home</code> Jump to beginning <code>End</code> Jump to end <code>0-9</code> Jump to 0%-90% of video <p>Examples: - Press <code>5</code> to jump to 50% of the video - Press <code>0</code> to jump to the start - Press <code>9</code> to jump to 90%</p>"},{"location":"user-guide/keyboard-navigation/#volume-controls","title":"Volume Controls","text":"Key Action <code>\u2191</code> Increase volume <code>\u2193</code> Decrease volume <code>M</code> Mute/unmute"},{"location":"user-guide/keyboard-navigation/#display-controls","title":"Display Controls","text":"Key Action <code>F</code> Toggle fullscreen <code>Escape</code> Exit fullscreen <code>T</code> Toggle theater mode (when available)"},{"location":"user-guide/keyboard-navigation/#playlist-playback","title":"Playlist Playback","text":"<p>While playing a playlist:</p> Key Action <code>N</code> or <code>Shift+\u2192</code> Next scene in playlist <code>P</code> or <code>Shift+\u2190</code> Previous scene in playlist <code>S</code> Toggle shuffle <code>R</code> Cycle repeat mode (Off \u2192 All \u2192 One) <code>Escape</code> Exit playlist playback"},{"location":"user-guide/keyboard-navigation/#search-filtering","title":"Search &amp; Filtering","text":""},{"location":"user-guide/keyboard-navigation/#search-box","title":"Search Box","text":"Key Action <code>/</code> or <code>Ctrl+F</code> Focus search box (from anywhere) <code>Escape</code> Clear search and exit search box <code>Enter</code> Submit search / apply filters <code>\u2193</code> Move to search results (from search box)"},{"location":"user-guide/keyboard-navigation/#filter-controls","title":"Filter Controls","text":"<p>While using filters:</p> Key Action <code>Tab</code> Move between filter options <code>Space</code> Toggle checkbox filters <code>Enter</code> Apply filters <code>Escape</code> Close filter panel"},{"location":"user-guide/keyboard-navigation/#playlists","title":"Playlists","text":""},{"location":"user-guide/keyboard-navigation/#playlist-management","title":"Playlist Management","text":"Key Action <code>N</code> Create new playlist (when on Playlists page) <code>Enter</code> Open focused playlist <code>Delete</code> Delete focused playlist (with confirmation)"},{"location":"user-guide/keyboard-navigation/#editing-playlists","title":"Editing Playlists","text":"<p>In edit mode:</p> Key Action <code>Tab</code> Navigate between scenes <code>Delete</code> Remove focused scene from playlist <code>Escape</code> Exit edit mode <code>Enter</code> Save changes <p>Reordering scenes: - Use mouse drag-and-drop for reordering - Keyboard reordering not currently supported</p>"},{"location":"user-guide/keyboard-navigation/#tv-mode","title":"TV Mode","text":""},{"location":"user-guide/keyboard-navigation/#what-is-tv-mode","title":"What is TV Mode?","text":"<p>TV Mode is Peek's interface optimized for TV remotes and couch browsing:</p> <ul> <li>Large Focus Indicators - Easy to see what's selected from across the room</li> <li>Remote-Friendly Navigation - Arrow keys and Enter are all you need</li> <li>Auto-Scroll - Page scrolls to keep focused element visible</li> <li>Simplified Controls - Reduced clutter, bigger buttons</li> </ul>"},{"location":"user-guide/keyboard-navigation/#using-peek-on-tv","title":"Using Peek on TV","text":"<p>Recommended setup:</p> <ol> <li>Connect a computer to your TV (HDMI)</li> <li>Access Peek via web browser on that computer</li> <li>Use a wireless keyboard or TV remote (with keyboard features)</li> <li>Navigate entirely with arrow keys and Enter</li> </ol> <p>Popular remote options: - Amazon Fire TV remote (with Alexa) - Android TV remote apps - Wireless keyboards (Logitech K400, etc.) - Smart TV keyboards - Game controllers (via browser support)</p>"},{"location":"user-guide/keyboard-navigation/#tv-mode-tips","title":"TV Mode Tips","text":"<ol> <li>Use fullscreen browser mode (F11) for immersive experience</li> <li>Enable auto-hide cursor in your OS settings</li> <li>Increase font size in browser settings (Ctrl +)</li> <li>Use dark theme for better viewing in dark rooms</li> <li>Disable screen saver on your PC/TV</li> </ol>"},{"location":"user-guide/keyboard-navigation/#settings-navigation","title":"Settings Navigation","text":""},{"location":"user-guide/keyboard-navigation/#navigating-settings-pages","title":"Navigating Settings Pages","text":"Key Action <code>Tab</code> Move between settings sections <code>Enter</code> Open/edit focused setting <code>Space</code> Toggle switches and checkboxes <code>Escape</code> Cancel without saving"},{"location":"user-guide/keyboard-navigation/#saving-settings","title":"Saving Settings","text":"Key Action <code>Enter</code> Save changes (when focused on Save button) <code>Escape</code> Cancel changes"},{"location":"user-guide/keyboard-navigation/#modal-dialogs","title":"Modal Dialogs","text":""},{"location":"user-guide/keyboard-navigation/#dialog-controls","title":"Dialog Controls","text":"Key Action <code>Enter</code> Confirm action (OK, Save, Submit) <code>Escape</code> Cancel and close dialog <code>Tab</code> Navigate between dialog buttons <p>Examples: - Delete confirmation dialogs - Playlist selector - Add to playlist modal - Login form</p>"},{"location":"user-guide/keyboard-navigation/#accessibility-features","title":"Accessibility Features","text":""},{"location":"user-guide/keyboard-navigation/#focus-indicators","title":"Focus Indicators","text":"<p>Peek shows clear visual focus indicators:</p> <ul> <li>Blue outline around focused elements</li> <li>Highlighted cards when focused in grids</li> <li>Button highlights when focused</li> <li>Scale effect on focused scene cards</li> </ul>"},{"location":"user-guide/keyboard-navigation/#screen-reader-support","title":"Screen Reader Support","text":"<p>Basic screen reader support:</p> <ul> <li>Alt text on images</li> <li>ARIA labels on buttons and controls</li> <li>Semantic HTML for proper navigation</li> <li>Keyboard-accessible everything</li> </ul> <p>Screen Reader Support</p> <p>Screen reader support is improving but may not be perfect. Please report accessibility issues on GitHub.</p>"},{"location":"user-guide/keyboard-navigation/#customizing-keyboard-shortcuts","title":"Customizing Keyboard Shortcuts","text":"<p>Currently not customizable. Keyboard shortcuts are built-in and cannot be changed.</p> <p>Future enhancement: Custom keyboard shortcuts may be added in a future update.</p>"},{"location":"user-guide/keyboard-navigation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"user-guide/keyboard-navigation/#keyboard-navigation-not-working","title":"Keyboard navigation not working","text":"<p>Solution: - Click anywhere in the browser window to focus it - Try pressing <code>Tab</code> to activate focus mode - Check if a modal or dialog is open (press <code>Escape</code>) - Disable browser extensions that may interfere - Try a different browser</p>"},{"location":"user-guide/keyboard-navigation/#focus-indicator-not-visible","title":"Focus indicator not visible","text":"<p>Solution: - Your browser theme may be hiding focus outlines - Try a different theme in Peek (Settings \u2192 My Settings) - Check browser zoom level (Ctrl + 0 to reset) - Report as a bug if it persists</p>"},{"location":"user-guide/keyboard-navigation/#arrow-keys-scroll-page-instead-of-navigating","title":"Arrow keys scroll page instead of navigating","text":"<p>Solution: - Click on the scene grid to focus it first - Use <code>Tab</code> to focus an element, then arrow keys work - Some areas use <code>Tab</code> navigation only</p>"},{"location":"user-guide/keyboard-navigation/#video-player-shortcuts-not-working","title":"Video player shortcuts not working","text":"<p>Solution: - Make sure video player is focused (click on it) - Some shortcuts only work during playback - Check if another app is intercepting keys - Try clicking the video before using shortcuts</p>"},{"location":"user-guide/keyboard-navigation/#tips-for-power-users","title":"Tips for Power Users","text":""},{"location":"user-guide/keyboard-navigation/#speed-navigation","title":"Speed Navigation","text":"<ol> <li>Use <code>/</code> to search instantly from any page</li> <li>Use number keys (0-9) to scrub through videos quickly</li> <li>Press <code>Escape</code> repeatedly to navigate back multiple levels</li> <li>Use <code>Tab + Enter</code> combo for rapid clicking</li> </ol>"},{"location":"user-guide/keyboard-navigation/#couch-potato-mode","title":"Couch Potato Mode","text":"<p>Perfect setup for couch browsing:</p> <ol> <li>Open Peek in fullscreen (F11)</li> <li>Create a \"Favorites\" playlist</li> <li>Start playlist playback</li> <li>Use only these keys:</li> <li><code>Space</code> - Play/Pause</li> <li><code>N</code> - Next video</li> <li><code>P</code> - Previous video</li> <li><code>\u2191/\u2193</code> - Volume</li> <li><code>F</code> - Fullscreen on/off</li> </ol>"},{"location":"user-guide/keyboard-navigation/#workflow-optimization","title":"Workflow Optimization","text":"<p>Browse and queue efficiently:</p> <ol> <li>Navigate scene grid with arrow keys</li> <li>Press <code>+</code> on scenes you want to watch</li> <li>Add all to \"Watch Later\" playlist</li> <li>Open playlist and press Play</li> <li>Lean back and enjoy</li> </ol>"},{"location":"user-guide/keyboard-navigation/#next-steps","title":"Next Steps","text":"<ul> <li>Watch History - Resume playback from where you left off</li> <li>Playlists - Create and manage custom playlists</li> <li>Quick Start Guide - Get started with Peek</li> </ul>"},{"location":"user-guide/playlists/","title":"Playlists","text":"<p>Create and manage custom playlists to organize your favorite scenes.</p>"},{"location":"user-guide/playlists/#creating-a-playlist","title":"Creating a Playlist","text":"<ol> <li>Click Playlists in the navigation menu</li> <li>Click the Create Playlist button</li> <li>Enter a name for your playlist</li> <li>Optionally add a description</li> <li>Click Create</li> </ol> <p>Your new playlist is now ready to use!</p>"},{"location":"user-guide/playlists/#adding-scenes-to-playlists","title":"Adding Scenes to Playlists","text":"<p>There are two ways to add scenes to your playlists:</p>"},{"location":"user-guide/playlists/#from-scene-cards","title":"From Scene Cards","text":"<ol> <li>Find a scene you want to add (on any page with scene cards)</li> <li>Click the + (plus) icon on the scene card</li> <li>Select the playlist you want to add it to</li> <li>The scene is added instantly!</li> </ol>"},{"location":"user-guide/playlists/#from-scene-detail-page","title":"From Scene Detail Page","text":"<ol> <li>Click on a scene to open its detail page</li> <li>Click the Add to Playlist button</li> <li>Select the playlist you want to add it to</li> <li>Done!</li> </ol> <p>Multiple Playlists</p> <p>You can add the same scene to multiple playlists. Great for organizing scenes by different themes or moods!</p>"},{"location":"user-guide/playlists/#managing-your-playlists","title":"Managing Your Playlists","text":""},{"location":"user-guide/playlists/#viewing-playlist-contents","title":"Viewing Playlist Contents","text":"<ol> <li>Click Playlists in the navigation</li> <li>Click on any playlist to see its scenes</li> <li>Scroll through to see all scenes in the playlist</li> </ol>"},{"location":"user-guide/playlists/#editing-playlist-details","title":"Editing Playlist Details","text":"<ol> <li>Open a playlist</li> <li>Click the Edit button (pencil icon)</li> <li>Change the name or description</li> <li>Click Save</li> </ol>"},{"location":"user-guide/playlists/#reordering-scenes","title":"Reordering Scenes","text":"<p>Want to change the playback order?</p> <ol> <li>Open a playlist</li> <li>Click Edit mode</li> <li>Drag and drop scenes to reorder them</li> <li>Click Save when done</li> </ol> <p>The playlist will play scenes in the order you've arranged them.</p>"},{"location":"user-guide/playlists/#removing-scenes","title":"Removing Scenes","text":"<ol> <li>Open a playlist</li> <li>Click Edit mode</li> <li>Click the \u00d7 (remove) icon on any scene</li> <li>Confirm removal</li> <li>Click Save</li> </ol>"},{"location":"user-guide/playlists/#deleting-a-playlist","title":"Deleting a Playlist","text":"<p>Permanent Action</p> <p>Deleting a playlist cannot be undone. The scenes themselves are not deleted, just the playlist.</p> <ol> <li>Open the playlist you want to delete</li> <li>Click the Delete button (trash icon)</li> <li>Confirm deletion</li> <li>The playlist is permanently removed</li> </ol>"},{"location":"user-guide/playlists/#playing-playlists","title":"Playing Playlists","text":""},{"location":"user-guide/playlists/#basic-playback","title":"Basic Playback","text":"<ol> <li>Open a playlist</li> <li>Click the Play button</li> <li>Playback starts with the first scene</li> <li>When a scene ends, the next scene plays automatically</li> </ol>"},{"location":"user-guide/playlists/#shuffle-mode","title":"Shuffle Mode","text":"<p>Randomize the playback order:</p> <ol> <li>Open a playlist</li> <li>Click the Shuffle button (shuffle icon)</li> <li>Playlist will play scenes in random order</li> <li>Click Shuffle again to turn it off</li> </ol> <p>Shuffle Tip</p> <p>Shuffle is perfect for long playlists when you want variety!</p>"},{"location":"user-guide/playlists/#repeat-modes","title":"Repeat Modes","text":"<p>Choose how playback repeats:</p> <p>Repeat Off (default) - Playlist plays once and stops</p> <p>Repeat All - When playlist ends, it starts over from the beginning - Continues until you stop it</p> <p>Repeat One - Current scene repeats continuously - Great for favorite scenes!</p> <p>To change repeat mode: 1. Open a playlist 2. Click the Repeat button 3. Click again to cycle through modes: Off \u2192 All \u2192 One \u2192 Off</p>"},{"location":"user-guide/playlists/#navigation-during-playback","title":"Navigation During Playback","text":"<p>While watching a playlist:</p> <ul> <li>Next Scene: Click the next button or press N</li> <li>Previous Scene: Click the previous button or press P</li> <li>Exit Playlist: Click the back button to return to browsing</li> </ul>"},{"location":"user-guide/playlists/#playlist-tips-tricks","title":"Playlist Tips &amp; Tricks","text":""},{"location":"user-guide/playlists/#organization-ideas","title":"Organization Ideas","text":"<ul> <li>By Performer: Create playlists for your favorite performers</li> <li>By Studio: Group scenes from specific studios</li> <li>By Theme: Organize by categories or tags</li> <li>Watch Later: Save scenes you want to watch later</li> <li>Best Of: Curate your absolute favorites</li> <li>Mood-Based: Create playlists for different moods or occasions</li> </ul>"},{"location":"user-guide/playlists/#quick-access","title":"Quick Access","text":"<p>Your playlists are always accessible from: - The Playlists page (shows all playlists) - Any scene's Add to Playlist menu - The + icon on scene cards</p>"},{"location":"user-guide/playlists/#playlist-size","title":"Playlist Size","text":"<p>There's no limit to how many: - Playlists you can create - Scenes you can add to a playlist - Playlists a single scene can be in</p>"},{"location":"user-guide/playlists/#troubleshooting","title":"Troubleshooting","text":""},{"location":"user-guide/playlists/#scene-wont-add-to-playlist","title":"Scene won't add to playlist","text":"<ul> <li>Make sure you're logged in</li> <li>Check that the playlist still exists</li> <li>Try refreshing the page</li> </ul>"},{"location":"user-guide/playlists/#playlist-wont-play","title":"Playlist won't play","text":"<ul> <li>Verify the playlist has scenes in it</li> <li>Check that you can play individual scenes</li> <li>Make sure your path mappings are configured correctly</li> </ul>"},{"location":"user-guide/playlists/#changes-arent-saving","title":"Changes aren't saving","text":"<ul> <li>Make sure to click Save after editing</li> <li>Check your internet connection</li> <li>Try refreshing and making changes again</li> </ul>"},{"location":"user-guide/playlists/#next-steps","title":"Next Steps","text":"<ul> <li>Watch History - Resume playback from where you left off</li> <li>Keyboard Navigation - Complete keyboard shortcuts and TV mode</li> <li>Troubleshooting - Fix common issues</li> <li>FAQ - Frequently asked questions</li> </ul>"},{"location":"user-guide/watch-history/","title":"Watch History &amp; Resume Playback","text":"<p>Peek automatically tracks your viewing progress and lets you resume playback exactly where you left off.</p>"},{"location":"user-guide/watch-history/#how-watch-history-works","title":"How Watch History Works","text":""},{"location":"user-guide/watch-history/#automatic-tracking","title":"Automatic Tracking","text":"<p>Peek tracks your progress automatically while you watch:</p> <ul> <li>Progress is saved every few seconds during playback</li> <li>No manual action needed - just watch normally</li> <li>Per-user tracking - each user has their own watch history</li> <li>Syncs across devices - resume on any device where you're logged in</li> </ul>"},{"location":"user-guide/watch-history/#what-gets-tracked","title":"What Gets Tracked","text":"<p>For each scene you watch, Peek remembers:</p> <ul> <li>Current position - Exact timestamp where you stopped</li> <li>Total progress - Percentage watched (e.g., 65% complete)</li> <li>Last watched date - When you last viewed this scene</li> <li>Watch count - How many times you've watched it</li> </ul>"},{"location":"user-guide/watch-history/#resume-playback","title":"Resume Playback","text":""},{"location":"user-guide/watch-history/#automatic-resume","title":"Automatic Resume","text":"<p>When you click Play on a scene you've partially watched:</p> <ol> <li>Video player opens</li> <li>You see a \"Resume from [timestamp]\" notification</li> <li>Player automatically jumps to where you left off</li> <li>Click \"Start from beginning\" if you prefer to restart</li> </ol> <p>Quick Resume</p> <p>The resume prompt appears for 5 seconds. If you do nothing, playback continues from your last position automatically!</p>"},{"location":"user-guide/watch-history/#from-scene-cards","title":"From Scene Cards","text":"<p>Scene cards show your progress visually:</p> <ul> <li>Progress bar at the bottom of the thumbnail</li> <li>Percentage indicator (e.g., \"65% watched\")</li> <li>Blue progress bar fills from left to right as you watch</li> </ul> <p>To resume from a scene card: 1. Find the scene (look for the progress bar) 2. Click Play 3. Playback resumes automatically</p>"},{"location":"user-guide/watch-history/#continue-watching","title":"Continue Watching","text":""},{"location":"user-guide/watch-history/#quick-access-to-in-progress-scenes","title":"Quick Access to In-Progress Scenes","text":"<p>The Continue Watching section shows all partially-watched scenes:</p> <p>Location: Home page (top section)</p> <p>What appears here: - Scenes you've started but not finished - Sorted by most recently watched - Shows progress percentage - Limited to your last 20 in-progress scenes</p> <p>To resume: 1. Go to Home page 2. Find the scene in Continue Watching 3. Click Play 4. Resumes from where you stopped</p> <p>Fast Resume</p> <p>Continue Watching is the fastest way to pick up where you left off!</p>"},{"location":"user-guide/watch-history/#when-scenes-disappear-from-continue-watching","title":"When Scenes Disappear from Continue Watching","text":"<p>A scene is removed from Continue Watching when: - You watch to completion (95%+ watched counts as complete) - You manually clear watch history for that scene - It falls outside your last 20 in-progress scenes</p>"},{"location":"user-guide/watch-history/#managing-watch-history","title":"Managing Watch History","text":""},{"location":"user-guide/watch-history/#viewing-your-history","title":"Viewing Your History","text":"<p>Full watch history coming in future update. Currently:</p> <ul> <li>View in-progress scenes via Continue Watching on home page</li> <li>See progress bars on scene cards throughout the app</li> <li>Check scene detail page for watch progress</li> </ul>"},{"location":"user-guide/watch-history/#marking-as-watched","title":"Marking as Watched","text":"<p>To mark a scene as fully watched without watching it:</p> <ol> <li>Open the scene detail page</li> <li>Seek to the end of the video (last 5%)</li> <li>Let it play for a few seconds</li> <li>Scene is marked as watched</li> </ol> <p>Or manually skip to 95%+ completion to trigger \"watched\" status.</p>"},{"location":"user-guide/watch-history/#clearing-watch-history","title":"Clearing Watch History","text":"<p>For a single scene:</p> <ol> <li>Open the scene detail page</li> <li>Click the \u22ee (three dots) menu</li> <li>Select \"Clear watch history\"</li> <li>Progress is reset to 0%</li> </ol> <p>For all scenes:</p> <ol> <li>Go to Settings \u2192 My Settings</li> <li>Scroll to Watch History section</li> <li>Click \"Clear all watch history\"</li> <li>Confirm the action</li> <li>All progress is reset</li> </ol> <p>Cannot Be Undone</p> <p>Clearing watch history is permanent. You cannot restore cleared progress.</p>"},{"location":"user-guide/watch-history/#privacy-data","title":"Privacy &amp; Data","text":""},{"location":"user-guide/watch-history/#whats-stored","title":"What's Stored","text":"<p>Watch history is stored in Peek's database:</p> <ul> <li>User ID - Associated with your account</li> <li>Scene ID - Which scene you watched</li> <li>Progress position - Timestamp (in seconds)</li> <li>Last watched date - When you last viewed it</li> <li>Watch count - Total number of views</li> </ul>"},{"location":"user-guide/watch-history/#whats-not-stored","title":"What's NOT Stored","text":"<ul> <li>No video file access logs - Peek doesn't log file system access</li> <li>No sharing with Stash - Watch history stays in Peek only</li> <li>No external tracking - History never leaves your Peek instance</li> </ul>"},{"location":"user-guide/watch-history/#privacy-controls","title":"Privacy Controls","text":"<ul> <li>Per-user isolation - You only see your own history</li> <li>Admin cannot see - Even admins can't view other users' watch history</li> <li>Clear anytime - You control your history data</li> </ul>"},{"location":"user-guide/watch-history/#watch-history-tips","title":"Watch History Tips","text":""},{"location":"user-guide/watch-history/#efficient-binge-watching","title":"Efficient Binge Watching","text":"<ol> <li>Start watching scenes you want to explore</li> <li>Switch between different scenes freely</li> <li>Return to Continue Watching to resume any of them</li> <li>No need to finish in one sitting</li> </ol>"},{"location":"user-guide/watch-history/#organize-with-playlists","title":"Organize with Playlists","text":"<p>Combine watch history with playlists:</p> <ol> <li>Create a \"To Watch\" playlist</li> <li>Add scenes you plan to watch later</li> <li>Watch them at your own pace</li> <li>Progress tracked automatically</li> <li>Resume from Continue Watching or the playlist</li> </ol>"},{"location":"user-guide/watch-history/#track-rewatches","title":"Track Rewatches","text":"<p>Want to rewatch a favorite scene?</p> <ol> <li>Click Play on an already-watched scene</li> <li>Choose \"Start from beginning\" when prompted</li> <li>Watch count increments</li> <li>New progress tracked</li> </ol>"},{"location":"user-guide/watch-history/#troubleshooting","title":"Troubleshooting","text":""},{"location":"user-guide/watch-history/#resume-not-working","title":"Resume not working","text":"<p>Solution: - Make sure you're logged in (watch history is per-user) - Check that you watched for at least 10 seconds (minimum tracking threshold) - Verify you're using the same user account - Try refreshing the page</p>"},{"location":"user-guide/watch-history/#progress-bar-not-showing","title":"Progress bar not showing","text":"<p>Solution: - Progress may not appear if you only watched a few seconds - Progress bars require at least 5% completion to display - Try playing the video for longer - Clear browser cache if progress seems stuck</p>"},{"location":"user-guide/watch-history/#continue-watching-is-empty","title":"Continue Watching is empty","text":"<p>Possible reasons: - You haven't started watching any scenes yet - All your in-progress scenes are completed - You cleared your watch history - You're using a different user account</p>"},{"location":"user-guide/watch-history/#progress-resets-unexpectedly","title":"Progress resets unexpectedly","text":"<p>Solution: - Check if someone else cleared watch history (admin action) - Verify you're logged in (anonymous users don't save history) - Check browser console for errors (F12 \u2192 Console) - Report as a bug if it persists</p>"},{"location":"user-guide/watch-history/#keyboard-shortcuts","title":"Keyboard Shortcuts","text":"<p>While watching a video:</p> Key Action <code>\u2190</code> Seek backward 10s <code>\u2192</code> Seek forward 10s <code>Space</code> Play/Pause <code>F</code> Toggle fullscreen <code>M</code> Mute/unmute <p>See the Keyboard Navigation Guide for complete shortcuts.</p>"},{"location":"user-guide/watch-history/#next-steps","title":"Next Steps","text":"<ul> <li>Keyboard Navigation - Complete keyboard shortcuts and TV mode</li> <li>Playlists - Organize scenes into custom playlists</li> <li>Quick Start Guide - Get started with Peek</li> </ul>"}]}